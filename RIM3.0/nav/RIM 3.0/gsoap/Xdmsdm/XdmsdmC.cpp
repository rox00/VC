/* XdmsdmC.cpp
   Generated by gSOAP 2.8.2 from Xdmsdm.h
   Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
   The generated code is released under one of the following licenses:
   GPL OR Genivia's license for commercial use.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "XdmsdmH.h"

namespace Xdmsdm {

SOAP_SOURCE_STAMP("@(#) XdmsdmC.cpp ver 2.8.2 2015-06-05 01:11:55 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_Xdmsdm_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_Xdmsdm_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_Xdmsdm_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_Xdmsdm_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_Xdmsdm_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LogType:
		return soap_in_Xdmsdm__LogType(soap, NULL, NULL, "Xdmsdm:LogType");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__SubSystemID:
		return soap_in_Xdmsdm__SubSystemID(soap, NULL, NULL, "Xdmsdm:SubSystemID");
	case SOAP_TYPE_Xdmsdm_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray:
		return soap_in_Xdmsdm__MonthReportBusFreqArray(soap, NULL, NULL, "Xdmsdm:MonthReportBusFreqArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq:
		return soap_in_Xdmsdm__MonthReportBusFreq(soap, NULL, NULL, "Xdmsdm:MonthReportBusFreq");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray:
		return soap_in_Xdmsdm__MonthReportWorkPlanArray(soap, NULL, NULL, "Xdmsdm:MonthReportWorkPlanArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan:
		return soap_in_Xdmsdm__MonthReportWorkPlan(soap, NULL, NULL, "Xdmsdm:MonthReportWorkPlan");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray:
		return soap_in_Xdmsdm__LicenseFuncArray(soap, NULL, NULL, "Xdmsdm:LicenseFuncArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc:
		return soap_in_Xdmsdm__LicenseFunc(soap, NULL, NULL, "Xdmsdm:LicenseFunc");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray:
		return soap_in_Xdmsdm__UserInfoArray(soap, NULL, NULL, "Xdmsdm:UserInfoArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo:
		return soap_in_Xdmsdm__UserInfo(soap, NULL, NULL, "Xdmsdm:UserInfo");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray:
		return soap_in_Xdmsdm__WebServiceInfoArray(soap, NULL, NULL, "Xdmsdm:WebServiceInfoArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo:
		return soap_in_Xdmsdm__WebServiceInfo(soap, NULL, NULL, "Xdmsdm:WebServiceInfo");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray:
		return soap_in_Xdmsdm__VersionInfoArray(soap, NULL, NULL, "Xdmsdm:VersionInfoArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo:
		return soap_in_Xdmsdm__VersionInfo(soap, NULL, NULL, "Xdmsdm:VersionInfo");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray:
		return soap_in_Xdmsdm__FreqLayoutArray(soap, NULL, NULL, "Xdmsdm:FreqLayoutArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout:
		return soap_in_Xdmsdm__FreqLayout(soap, NULL, NULL, "Xdmsdm:FreqLayout");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray:
		return soap_in_Xdmsdm__RegionNOArray(soap, NULL, NULL, "Xdmsdm:RegionNOArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO:
		return soap_in_Xdmsdm__RegionNO(soap, NULL, NULL, "Xdmsdm:RegionNO");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse:
		return soap_in_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse(soap, NULL, NULL, "Xdmsdm:GetMonthReportBusFreqsResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportBusFreqs:
		return soap_in_PointerTo_Xdmsdm__GetMonthReportBusFreqs(soap, NULL, NULL, "Xdmsdm:GetMonthReportBusFreqs");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse:
		return soap_in_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse(soap, NULL, NULL, "Xdmsdm:SetMonthReportBusFreqsResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportBusFreqs:
		return soap_in_PointerTo_Xdmsdm__SetMonthReportBusFreqs(soap, NULL, NULL, "Xdmsdm:SetMonthReportBusFreqs");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse:
		return soap_in_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse(soap, NULL, NULL, "Xdmsdm:GetMonthReportWorkPlansResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportWorkPlans:
		return soap_in_PointerTo_Xdmsdm__GetMonthReportWorkPlans(soap, NULL, NULL, "Xdmsdm:GetMonthReportWorkPlans");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse:
		return soap_in_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse(soap, NULL, NULL, "Xdmsdm:SetMonthReportWorkPlansResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportWorkPlans:
		return soap_in_PointerTo_Xdmsdm__SetMonthReportWorkPlans(soap, NULL, NULL, "Xdmsdm:SetMonthReportWorkPlans");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserInfoResponse:
		return soap_in_PointerTo_Xdmsdm__QueryUserInfoResponse(soap, NULL, NULL, "Xdmsdm:QueryUserInfoResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserInfo:
		return soap_in_PointerTo_Xdmsdm__QueryUserInfo(soap, NULL, NULL, "Xdmsdm:QueryUserInfo");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SendMobileMessageResponse:
		return soap_in_PointerTo_Xdmsdm__SendMobileMessageResponse(soap, NULL, NULL, "Xdmsdm:SendMobileMessageResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SendMobileMessage:
		return soap_in_PointerTo_Xdmsdm__SendMobileMessage(soap, NULL, NULL, "Xdmsdm:SendMobileMessage");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserMobileNOResponse:
		return soap_in_PointerTo_Xdmsdm__QueryUserMobileNOResponse(soap, NULL, NULL, "Xdmsdm:QueryUserMobileNOResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserMobileNO:
		return soap_in_PointerTo_Xdmsdm__QueryUserMobileNO(soap, NULL, NULL, "Xdmsdm:QueryUserMobileNO");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryStandardTimeResponse:
		return soap_in_PointerTo_Xdmsdm__QueryStandardTimeResponse(soap, NULL, NULL, "Xdmsdm:QueryStandardTimeResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryStandardTime:
		return soap_in_PointerTo_Xdmsdm__QueryStandardTime(soap, NULL, NULL, "Xdmsdm:QueryStandardTime");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SubmitOperateLogResponse:
		return soap_in_PointerTo_Xdmsdm__SubmitOperateLogResponse(soap, NULL, NULL, "Xdmsdm:SubmitOperateLogResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SubmitOperateLog:
		return soap_in_PointerTo_Xdmsdm__SubmitOperateLog(soap, NULL, NULL, "Xdmsdm:SubmitOperateLog");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse:
		return soap_in_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse(soap, NULL, NULL, "Xdmsdm:QueryUserLicenseFuncResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserLicenseFunc:
		return soap_in_PointerTo_Xdmsdm__QueryUserLicenseFunc(soap, NULL, NULL, "Xdmsdm:QueryUserLicenseFunc");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse:
		return soap_in_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse(soap, NULL, NULL, "Xdmsdm:AuthUserLicenseFuncResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserLicenseFunc:
		return soap_in_PointerTo_Xdmsdm__AuthUserLicenseFunc(soap, NULL, NULL, "Xdmsdm:AuthUserLicenseFunc");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserResponse:
		return soap_in_PointerTo_Xdmsdm__AuthUserResponse(soap, NULL, NULL, "Xdmsdm:AuthUserResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUser:
		return soap_in_PointerTo_Xdmsdm__AuthUser(soap, NULL, NULL, "Xdmsdm:AuthUser");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryWebServiceResponse:
		return soap_in_PointerTo_Xdmsdm__QueryWebServiceResponse(soap, NULL, NULL, "Xdmsdm:QueryWebServiceResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryWebService:
		return soap_in_PointerTo_Xdmsdm__QueryWebService(soap, NULL, NULL, "Xdmsdm:QueryWebService");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryFreqLayoutResponse:
		return soap_in_PointerTo_Xdmsdm__QueryFreqLayoutResponse(soap, NULL, NULL, "Xdmsdm:QueryFreqLayoutResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryFreqLayout:
		return soap_in_PointerTo_Xdmsdm__QueryFreqLayout(soap, NULL, NULL, "Xdmsdm:QueryFreqLayout");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryRegionNOResponse:
		return soap_in_PointerTo_Xdmsdm__QueryRegionNOResponse(soap, NULL, NULL, "Xdmsdm:QueryRegionNOResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryRegionNO:
		return soap_in_PointerTo_Xdmsdm__QueryRegionNO(soap, NULL, NULL, "Xdmsdm:QueryRegionNO");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryVersionInfoResponse:
		return soap_in_PointerTo_Xdmsdm__QueryVersionInfoResponse(soap, NULL, NULL, "Xdmsdm:QueryVersionInfoResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryVersionInfo:
		return soap_in_PointerTo_Xdmsdm__QueryVersionInfo(soap, NULL, NULL, "Xdmsdm:QueryVersionInfo");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreqArray:
		return soap_in_PointerToXdmsdm__MonthReportBusFreqArray(soap, NULL, NULL, "Xdmsdm:MonthReportBusFreqArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlanArray:
		return soap_in_PointerToXdmsdm__MonthReportWorkPlanArray(soap, NULL, NULL, "Xdmsdm:MonthReportWorkPlanArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfoArray:
		return soap_in_PointerToXdmsdm__UserInfoArray(soap, NULL, NULL, "Xdmsdm:UserInfoArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFuncArray:
		return soap_in_PointerToXdmsdm__LicenseFuncArray(soap, NULL, NULL, "Xdmsdm:LicenseFuncArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfoArray:
		return soap_in_PointerToXdmsdm__WebServiceInfoArray(soap, NULL, NULL, "Xdmsdm:WebServiceInfoArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayoutArray:
		return soap_in_PointerToXdmsdm__FreqLayoutArray(soap, NULL, NULL, "Xdmsdm:FreqLayoutArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNOArray:
		return soap_in_PointerToXdmsdm__RegionNOArray(soap, NULL, NULL, "Xdmsdm:RegionNOArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfoArray:
		return soap_in_PointerToXdmsdm__VersionInfoArray(soap, NULL, NULL, "Xdmsdm:VersionInfoArray");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__MonthReportBusFreq:
		return soap_in_PointerToPointerToXdmsdm__MonthReportBusFreq(soap, NULL, NULL, "Xdmsdm:MonthReportBusFreq");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreq:
		return soap_in_PointerToXdmsdm__MonthReportBusFreq(soap, NULL, NULL, "Xdmsdm:MonthReportBusFreq");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__MonthReportWorkPlan:
		return soap_in_PointerToPointerToXdmsdm__MonthReportWorkPlan(soap, NULL, NULL, "Xdmsdm:MonthReportWorkPlan");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlan:
		return soap_in_PointerToXdmsdm__MonthReportWorkPlan(soap, NULL, NULL, "Xdmsdm:MonthReportWorkPlan");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__LicenseFunc:
		return soap_in_PointerToPointerToXdmsdm__LicenseFunc(soap, NULL, NULL, "Xdmsdm:LicenseFunc");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFunc:
		return soap_in_PointerToXdmsdm__LicenseFunc(soap, NULL, NULL, "Xdmsdm:LicenseFunc");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__UserInfo:
		return soap_in_PointerToPointerToXdmsdm__UserInfo(soap, NULL, NULL, "Xdmsdm:UserInfo");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfo:
		return soap_in_PointerToXdmsdm__UserInfo(soap, NULL, NULL, "Xdmsdm:UserInfo");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__WebServiceInfo:
		return soap_in_PointerToPointerToXdmsdm__WebServiceInfo(soap, NULL, NULL, "Xdmsdm:WebServiceInfo");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfo:
		return soap_in_PointerToXdmsdm__WebServiceInfo(soap, NULL, NULL, "Xdmsdm:WebServiceInfo");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__VersionInfo:
		return soap_in_PointerToPointerToXdmsdm__VersionInfo(soap, NULL, NULL, "Xdmsdm:VersionInfo");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfo:
		return soap_in_PointerToXdmsdm__VersionInfo(soap, NULL, NULL, "Xdmsdm:VersionInfo");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__FreqLayout:
		return soap_in_PointerToPointerToXdmsdm__FreqLayout(soap, NULL, NULL, "Xdmsdm:FreqLayout");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayout:
		return soap_in_PointerToXdmsdm__FreqLayout(soap, NULL, NULL, "Xdmsdm:FreqLayout");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__RegionNO:
		return soap_in_PointerToPointerToXdmsdm__RegionNO(soap, NULL, NULL, "Xdmsdm:RegionNO");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNO:
		return soap_in_PointerToXdmsdm__RegionNO(soap, NULL, NULL, "Xdmsdm:RegionNO");
	case SOAP_TYPE_Xdmsdm__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_Xdmsdm_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_Xdmsdm_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:MonthReportBusFreqArray"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray;
			return soap_in_Xdmsdm__MonthReportBusFreqArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:MonthReportBusFreq"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq;
			return soap_in_Xdmsdm__MonthReportBusFreq(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:MonthReportWorkPlanArray"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray;
			return soap_in_Xdmsdm__MonthReportWorkPlanArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:MonthReportWorkPlan"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan;
			return soap_in_Xdmsdm__MonthReportWorkPlan(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:LicenseFuncArray"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray;
			return soap_in_Xdmsdm__LicenseFuncArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:LicenseFunc"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc;
			return soap_in_Xdmsdm__LicenseFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:UserInfoArray"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray;
			return soap_in_Xdmsdm__UserInfoArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:UserInfo"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo;
			return soap_in_Xdmsdm__UserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:WebServiceInfoArray"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray;
			return soap_in_Xdmsdm__WebServiceInfoArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:WebServiceInfo"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo;
			return soap_in_Xdmsdm__WebServiceInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:VersionInfoArray"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray;
			return soap_in_Xdmsdm__VersionInfoArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:VersionInfo"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo;
			return soap_in_Xdmsdm__VersionInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:FreqLayoutArray"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray;
			return soap_in_Xdmsdm__FreqLayoutArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:FreqLayout"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout;
			return soap_in_Xdmsdm__FreqLayout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:RegionNOArray"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray;
			return soap_in_Xdmsdm__RegionNOArray(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:RegionNO"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO;
			return soap_in_Xdmsdm__RegionNO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_Xdmsdm_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_Xdmsdm_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_Xdmsdm_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_Xdmsdm_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_Xdmsdm_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:LogType"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__LogType;
			return soap_in_Xdmsdm__LogType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:SubSystemID"))
		{	*type = SOAP_TYPE_Xdmsdm_Xdmsdm__SubSystemID;
			return soap_in_Xdmsdm__SubSystemID(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE_Xdmsdm__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_Xdmsdm_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "Xdmsdm:GetMonthReportBusFreqsResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse;
			return soap_in__Xdmsdm__GetMonthReportBusFreqsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:GetMonthReportBusFreqs"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs;
			return soap_in__Xdmsdm__GetMonthReportBusFreqs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:SetMonthReportBusFreqsResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse;
			return soap_in__Xdmsdm__SetMonthReportBusFreqsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:SetMonthReportBusFreqs"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs;
			return soap_in__Xdmsdm__SetMonthReportBusFreqs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:GetMonthReportWorkPlansResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse;
			return soap_in__Xdmsdm__GetMonthReportWorkPlansResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:GetMonthReportWorkPlans"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans;
			return soap_in__Xdmsdm__GetMonthReportWorkPlans(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:SetMonthReportWorkPlansResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse;
			return soap_in__Xdmsdm__SetMonthReportWorkPlansResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:SetMonthReportWorkPlans"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans;
			return soap_in__Xdmsdm__SetMonthReportWorkPlans(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryUserInfoResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse;
			return soap_in__Xdmsdm__QueryUserInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryUserInfo"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo;
			return soap_in__Xdmsdm__QueryUserInfo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:SendMobileMessageResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse;
			return soap_in__Xdmsdm__SendMobileMessageResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:SendMobileMessage"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage;
			return soap_in__Xdmsdm__SendMobileMessage(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryUserMobileNOResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse;
			return soap_in__Xdmsdm__QueryUserMobileNOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryUserMobileNO"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO;
			return soap_in__Xdmsdm__QueryUserMobileNO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryStandardTimeResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse;
			return soap_in__Xdmsdm__QueryStandardTimeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryStandardTime"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime;
			return soap_in__Xdmsdm__QueryStandardTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:SubmitOperateLogResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse;
			return soap_in__Xdmsdm__SubmitOperateLogResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:SubmitOperateLog"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog;
			return soap_in__Xdmsdm__SubmitOperateLog(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryUserLicenseFuncResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse;
			return soap_in__Xdmsdm__QueryUserLicenseFuncResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryUserLicenseFunc"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc;
			return soap_in__Xdmsdm__QueryUserLicenseFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:AuthUserLicenseFuncResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse;
			return soap_in__Xdmsdm__AuthUserLicenseFuncResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:AuthUserLicenseFunc"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc;
			return soap_in__Xdmsdm__AuthUserLicenseFunc(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:AuthUserResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse;
			return soap_in__Xdmsdm__AuthUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:AuthUser"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser;
			return soap_in__Xdmsdm__AuthUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryWebServiceResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse;
			return soap_in__Xdmsdm__QueryWebServiceResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryWebService"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService;
			return soap_in__Xdmsdm__QueryWebService(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryFreqLayoutResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse;
			return soap_in__Xdmsdm__QueryFreqLayoutResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryFreqLayout"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout;
			return soap_in__Xdmsdm__QueryFreqLayout(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryRegionNOResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse;
			return soap_in__Xdmsdm__QueryRegionNOResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryRegionNO"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO;
			return soap_in__Xdmsdm__QueryRegionNO(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryVersionInfoResponse"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse;
			return soap_in__Xdmsdm__QueryVersionInfoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "Xdmsdm:QueryVersionInfo"))
		{	*type = SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo;
			return soap_in__Xdmsdm__QueryVersionInfo(soap, NULL, NULL, NULL);
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_Xdmsdm_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_Xdmsdm_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_Xdmsdm_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_Xdmsdm_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_Xdmsdm_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LogType:
		return soap_out_Xdmsdm__LogType(soap, tag, id, (const enum Xdmsdm__LogType *)ptr, "Xdmsdm:LogType");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__SubSystemID:
		return soap_out_Xdmsdm__SubSystemID(soap, tag, id, (const enum Xdmsdm__SubSystemID *)ptr, "Xdmsdm:SubSystemID");
	case SOAP_TYPE_Xdmsdm_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse:
		return ((_Xdmsdm__GetMonthReportBusFreqsResponse *)ptr)->soap_out(soap, "Xdmsdm:GetMonthReportBusFreqsResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs:
		return ((_Xdmsdm__GetMonthReportBusFreqs *)ptr)->soap_out(soap, "Xdmsdm:GetMonthReportBusFreqs", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse:
		return ((_Xdmsdm__SetMonthReportBusFreqsResponse *)ptr)->soap_out(soap, "Xdmsdm:SetMonthReportBusFreqsResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs:
		return ((_Xdmsdm__SetMonthReportBusFreqs *)ptr)->soap_out(soap, "Xdmsdm:SetMonthReportBusFreqs", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse:
		return ((_Xdmsdm__GetMonthReportWorkPlansResponse *)ptr)->soap_out(soap, "Xdmsdm:GetMonthReportWorkPlansResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans:
		return ((_Xdmsdm__GetMonthReportWorkPlans *)ptr)->soap_out(soap, "Xdmsdm:GetMonthReportWorkPlans", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse:
		return ((_Xdmsdm__SetMonthReportWorkPlansResponse *)ptr)->soap_out(soap, "Xdmsdm:SetMonthReportWorkPlansResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans:
		return ((_Xdmsdm__SetMonthReportWorkPlans *)ptr)->soap_out(soap, "Xdmsdm:SetMonthReportWorkPlans", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse:
		return ((_Xdmsdm__QueryUserInfoResponse *)ptr)->soap_out(soap, "Xdmsdm:QueryUserInfoResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo:
		return ((_Xdmsdm__QueryUserInfo *)ptr)->soap_out(soap, "Xdmsdm:QueryUserInfo", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse:
		return ((_Xdmsdm__SendMobileMessageResponse *)ptr)->soap_out(soap, "Xdmsdm:SendMobileMessageResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage:
		return ((_Xdmsdm__SendMobileMessage *)ptr)->soap_out(soap, "Xdmsdm:SendMobileMessage", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse:
		return ((_Xdmsdm__QueryUserMobileNOResponse *)ptr)->soap_out(soap, "Xdmsdm:QueryUserMobileNOResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO:
		return ((_Xdmsdm__QueryUserMobileNO *)ptr)->soap_out(soap, "Xdmsdm:QueryUserMobileNO", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse:
		return ((_Xdmsdm__QueryStandardTimeResponse *)ptr)->soap_out(soap, "Xdmsdm:QueryStandardTimeResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime:
		return ((_Xdmsdm__QueryStandardTime *)ptr)->soap_out(soap, "Xdmsdm:QueryStandardTime", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse:
		return ((_Xdmsdm__SubmitOperateLogResponse *)ptr)->soap_out(soap, "Xdmsdm:SubmitOperateLogResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog:
		return ((_Xdmsdm__SubmitOperateLog *)ptr)->soap_out(soap, "Xdmsdm:SubmitOperateLog", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse:
		return ((_Xdmsdm__QueryUserLicenseFuncResponse *)ptr)->soap_out(soap, "Xdmsdm:QueryUserLicenseFuncResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc:
		return ((_Xdmsdm__QueryUserLicenseFunc *)ptr)->soap_out(soap, "Xdmsdm:QueryUserLicenseFunc", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse:
		return ((_Xdmsdm__AuthUserLicenseFuncResponse *)ptr)->soap_out(soap, "Xdmsdm:AuthUserLicenseFuncResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc:
		return ((_Xdmsdm__AuthUserLicenseFunc *)ptr)->soap_out(soap, "Xdmsdm:AuthUserLicenseFunc", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse:
		return ((_Xdmsdm__AuthUserResponse *)ptr)->soap_out(soap, "Xdmsdm:AuthUserResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser:
		return ((_Xdmsdm__AuthUser *)ptr)->soap_out(soap, "Xdmsdm:AuthUser", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse:
		return ((_Xdmsdm__QueryWebServiceResponse *)ptr)->soap_out(soap, "Xdmsdm:QueryWebServiceResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService:
		return ((_Xdmsdm__QueryWebService *)ptr)->soap_out(soap, "Xdmsdm:QueryWebService", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse:
		return ((_Xdmsdm__QueryFreqLayoutResponse *)ptr)->soap_out(soap, "Xdmsdm:QueryFreqLayoutResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout:
		return ((_Xdmsdm__QueryFreqLayout *)ptr)->soap_out(soap, "Xdmsdm:QueryFreqLayout", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse:
		return ((_Xdmsdm__QueryRegionNOResponse *)ptr)->soap_out(soap, "Xdmsdm:QueryRegionNOResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO:
		return ((_Xdmsdm__QueryRegionNO *)ptr)->soap_out(soap, "Xdmsdm:QueryRegionNO", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse:
		return ((_Xdmsdm__QueryVersionInfoResponse *)ptr)->soap_out(soap, "Xdmsdm:QueryVersionInfoResponse", id, NULL);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo:
		return ((_Xdmsdm__QueryVersionInfo *)ptr)->soap_out(soap, "Xdmsdm:QueryVersionInfo", id, NULL);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray:
		return ((Xdmsdm__MonthReportBusFreqArray *)ptr)->soap_out(soap, tag, id, "Xdmsdm:MonthReportBusFreqArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq:
		return ((Xdmsdm__MonthReportBusFreq *)ptr)->soap_out(soap, tag, id, "Xdmsdm:MonthReportBusFreq");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray:
		return ((Xdmsdm__MonthReportWorkPlanArray *)ptr)->soap_out(soap, tag, id, "Xdmsdm:MonthReportWorkPlanArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan:
		return ((Xdmsdm__MonthReportWorkPlan *)ptr)->soap_out(soap, tag, id, "Xdmsdm:MonthReportWorkPlan");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray:
		return ((Xdmsdm__LicenseFuncArray *)ptr)->soap_out(soap, tag, id, "Xdmsdm:LicenseFuncArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc:
		return ((Xdmsdm__LicenseFunc *)ptr)->soap_out(soap, tag, id, "Xdmsdm:LicenseFunc");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray:
		return ((Xdmsdm__UserInfoArray *)ptr)->soap_out(soap, tag, id, "Xdmsdm:UserInfoArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo:
		return ((Xdmsdm__UserInfo *)ptr)->soap_out(soap, tag, id, "Xdmsdm:UserInfo");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray:
		return ((Xdmsdm__WebServiceInfoArray *)ptr)->soap_out(soap, tag, id, "Xdmsdm:WebServiceInfoArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo:
		return ((Xdmsdm__WebServiceInfo *)ptr)->soap_out(soap, tag, id, "Xdmsdm:WebServiceInfo");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray:
		return ((Xdmsdm__VersionInfoArray *)ptr)->soap_out(soap, tag, id, "Xdmsdm:VersionInfoArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo:
		return ((Xdmsdm__VersionInfo *)ptr)->soap_out(soap, tag, id, "Xdmsdm:VersionInfo");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray:
		return ((Xdmsdm__FreqLayoutArray *)ptr)->soap_out(soap, tag, id, "Xdmsdm:FreqLayoutArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout:
		return ((Xdmsdm__FreqLayout *)ptr)->soap_out(soap, tag, id, "Xdmsdm:FreqLayout");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray:
		return ((Xdmsdm__RegionNOArray *)ptr)->soap_out(soap, tag, id, "Xdmsdm:RegionNOArray");
	case SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO:
		return ((Xdmsdm__RegionNO *)ptr)->soap_out(soap, tag, id, "Xdmsdm:RegionNO");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse:
		return soap_out_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse(soap, tag, id, (_Xdmsdm__GetMonthReportBusFreqsResponse *const*)ptr, "Xdmsdm:GetMonthReportBusFreqsResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportBusFreqs:
		return soap_out_PointerTo_Xdmsdm__GetMonthReportBusFreqs(soap, tag, id, (_Xdmsdm__GetMonthReportBusFreqs *const*)ptr, "Xdmsdm:GetMonthReportBusFreqs");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse:
		return soap_out_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse(soap, tag, id, (_Xdmsdm__SetMonthReportBusFreqsResponse *const*)ptr, "Xdmsdm:SetMonthReportBusFreqsResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportBusFreqs:
		return soap_out_PointerTo_Xdmsdm__SetMonthReportBusFreqs(soap, tag, id, (_Xdmsdm__SetMonthReportBusFreqs *const*)ptr, "Xdmsdm:SetMonthReportBusFreqs");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse:
		return soap_out_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse(soap, tag, id, (_Xdmsdm__GetMonthReportWorkPlansResponse *const*)ptr, "Xdmsdm:GetMonthReportWorkPlansResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportWorkPlans:
		return soap_out_PointerTo_Xdmsdm__GetMonthReportWorkPlans(soap, tag, id, (_Xdmsdm__GetMonthReportWorkPlans *const*)ptr, "Xdmsdm:GetMonthReportWorkPlans");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse:
		return soap_out_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse(soap, tag, id, (_Xdmsdm__SetMonthReportWorkPlansResponse *const*)ptr, "Xdmsdm:SetMonthReportWorkPlansResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportWorkPlans:
		return soap_out_PointerTo_Xdmsdm__SetMonthReportWorkPlans(soap, tag, id, (_Xdmsdm__SetMonthReportWorkPlans *const*)ptr, "Xdmsdm:SetMonthReportWorkPlans");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserInfoResponse:
		return soap_out_PointerTo_Xdmsdm__QueryUserInfoResponse(soap, tag, id, (_Xdmsdm__QueryUserInfoResponse *const*)ptr, "Xdmsdm:QueryUserInfoResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserInfo:
		return soap_out_PointerTo_Xdmsdm__QueryUserInfo(soap, tag, id, (_Xdmsdm__QueryUserInfo *const*)ptr, "Xdmsdm:QueryUserInfo");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SendMobileMessageResponse:
		return soap_out_PointerTo_Xdmsdm__SendMobileMessageResponse(soap, tag, id, (_Xdmsdm__SendMobileMessageResponse *const*)ptr, "Xdmsdm:SendMobileMessageResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SendMobileMessage:
		return soap_out_PointerTo_Xdmsdm__SendMobileMessage(soap, tag, id, (_Xdmsdm__SendMobileMessage *const*)ptr, "Xdmsdm:SendMobileMessage");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserMobileNOResponse:
		return soap_out_PointerTo_Xdmsdm__QueryUserMobileNOResponse(soap, tag, id, (_Xdmsdm__QueryUserMobileNOResponse *const*)ptr, "Xdmsdm:QueryUserMobileNOResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserMobileNO:
		return soap_out_PointerTo_Xdmsdm__QueryUserMobileNO(soap, tag, id, (_Xdmsdm__QueryUserMobileNO *const*)ptr, "Xdmsdm:QueryUserMobileNO");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryStandardTimeResponse:
		return soap_out_PointerTo_Xdmsdm__QueryStandardTimeResponse(soap, tag, id, (_Xdmsdm__QueryStandardTimeResponse *const*)ptr, "Xdmsdm:QueryStandardTimeResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryStandardTime:
		return soap_out_PointerTo_Xdmsdm__QueryStandardTime(soap, tag, id, (_Xdmsdm__QueryStandardTime *const*)ptr, "Xdmsdm:QueryStandardTime");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SubmitOperateLogResponse:
		return soap_out_PointerTo_Xdmsdm__SubmitOperateLogResponse(soap, tag, id, (_Xdmsdm__SubmitOperateLogResponse *const*)ptr, "Xdmsdm:SubmitOperateLogResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SubmitOperateLog:
		return soap_out_PointerTo_Xdmsdm__SubmitOperateLog(soap, tag, id, (_Xdmsdm__SubmitOperateLog *const*)ptr, "Xdmsdm:SubmitOperateLog");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse:
		return soap_out_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse(soap, tag, id, (_Xdmsdm__QueryUserLicenseFuncResponse *const*)ptr, "Xdmsdm:QueryUserLicenseFuncResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserLicenseFunc:
		return soap_out_PointerTo_Xdmsdm__QueryUserLicenseFunc(soap, tag, id, (_Xdmsdm__QueryUserLicenseFunc *const*)ptr, "Xdmsdm:QueryUserLicenseFunc");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse:
		return soap_out_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse(soap, tag, id, (_Xdmsdm__AuthUserLicenseFuncResponse *const*)ptr, "Xdmsdm:AuthUserLicenseFuncResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserLicenseFunc:
		return soap_out_PointerTo_Xdmsdm__AuthUserLicenseFunc(soap, tag, id, (_Xdmsdm__AuthUserLicenseFunc *const*)ptr, "Xdmsdm:AuthUserLicenseFunc");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserResponse:
		return soap_out_PointerTo_Xdmsdm__AuthUserResponse(soap, tag, id, (_Xdmsdm__AuthUserResponse *const*)ptr, "Xdmsdm:AuthUserResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUser:
		return soap_out_PointerTo_Xdmsdm__AuthUser(soap, tag, id, (_Xdmsdm__AuthUser *const*)ptr, "Xdmsdm:AuthUser");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryWebServiceResponse:
		return soap_out_PointerTo_Xdmsdm__QueryWebServiceResponse(soap, tag, id, (_Xdmsdm__QueryWebServiceResponse *const*)ptr, "Xdmsdm:QueryWebServiceResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryWebService:
		return soap_out_PointerTo_Xdmsdm__QueryWebService(soap, tag, id, (_Xdmsdm__QueryWebService *const*)ptr, "Xdmsdm:QueryWebService");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryFreqLayoutResponse:
		return soap_out_PointerTo_Xdmsdm__QueryFreqLayoutResponse(soap, tag, id, (_Xdmsdm__QueryFreqLayoutResponse *const*)ptr, "Xdmsdm:QueryFreqLayoutResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryFreqLayout:
		return soap_out_PointerTo_Xdmsdm__QueryFreqLayout(soap, tag, id, (_Xdmsdm__QueryFreqLayout *const*)ptr, "Xdmsdm:QueryFreqLayout");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryRegionNOResponse:
		return soap_out_PointerTo_Xdmsdm__QueryRegionNOResponse(soap, tag, id, (_Xdmsdm__QueryRegionNOResponse *const*)ptr, "Xdmsdm:QueryRegionNOResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryRegionNO:
		return soap_out_PointerTo_Xdmsdm__QueryRegionNO(soap, tag, id, (_Xdmsdm__QueryRegionNO *const*)ptr, "Xdmsdm:QueryRegionNO");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryVersionInfoResponse:
		return soap_out_PointerTo_Xdmsdm__QueryVersionInfoResponse(soap, tag, id, (_Xdmsdm__QueryVersionInfoResponse *const*)ptr, "Xdmsdm:QueryVersionInfoResponse");
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryVersionInfo:
		return soap_out_PointerTo_Xdmsdm__QueryVersionInfo(soap, tag, id, (_Xdmsdm__QueryVersionInfo *const*)ptr, "Xdmsdm:QueryVersionInfo");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreqArray:
		return soap_out_PointerToXdmsdm__MonthReportBusFreqArray(soap, tag, id, (Xdmsdm__MonthReportBusFreqArray *const*)ptr, "Xdmsdm:MonthReportBusFreqArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlanArray:
		return soap_out_PointerToXdmsdm__MonthReportWorkPlanArray(soap, tag, id, (Xdmsdm__MonthReportWorkPlanArray *const*)ptr, "Xdmsdm:MonthReportWorkPlanArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfoArray:
		return soap_out_PointerToXdmsdm__UserInfoArray(soap, tag, id, (Xdmsdm__UserInfoArray *const*)ptr, "Xdmsdm:UserInfoArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFuncArray:
		return soap_out_PointerToXdmsdm__LicenseFuncArray(soap, tag, id, (Xdmsdm__LicenseFuncArray *const*)ptr, "Xdmsdm:LicenseFuncArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfoArray:
		return soap_out_PointerToXdmsdm__WebServiceInfoArray(soap, tag, id, (Xdmsdm__WebServiceInfoArray *const*)ptr, "Xdmsdm:WebServiceInfoArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayoutArray:
		return soap_out_PointerToXdmsdm__FreqLayoutArray(soap, tag, id, (Xdmsdm__FreqLayoutArray *const*)ptr, "Xdmsdm:FreqLayoutArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNOArray:
		return soap_out_PointerToXdmsdm__RegionNOArray(soap, tag, id, (Xdmsdm__RegionNOArray *const*)ptr, "Xdmsdm:RegionNOArray");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfoArray:
		return soap_out_PointerToXdmsdm__VersionInfoArray(soap, tag, id, (Xdmsdm__VersionInfoArray *const*)ptr, "Xdmsdm:VersionInfoArray");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__MonthReportBusFreq:
		return soap_out_PointerToPointerToXdmsdm__MonthReportBusFreq(soap, tag, id, (Xdmsdm__MonthReportBusFreq **const*)ptr, "Xdmsdm:MonthReportBusFreq");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreq:
		return soap_out_PointerToXdmsdm__MonthReportBusFreq(soap, tag, id, (Xdmsdm__MonthReportBusFreq *const*)ptr, "Xdmsdm:MonthReportBusFreq");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__MonthReportWorkPlan:
		return soap_out_PointerToPointerToXdmsdm__MonthReportWorkPlan(soap, tag, id, (Xdmsdm__MonthReportWorkPlan **const*)ptr, "Xdmsdm:MonthReportWorkPlan");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlan:
		return soap_out_PointerToXdmsdm__MonthReportWorkPlan(soap, tag, id, (Xdmsdm__MonthReportWorkPlan *const*)ptr, "Xdmsdm:MonthReportWorkPlan");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__LicenseFunc:
		return soap_out_PointerToPointerToXdmsdm__LicenseFunc(soap, tag, id, (Xdmsdm__LicenseFunc **const*)ptr, "Xdmsdm:LicenseFunc");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFunc:
		return soap_out_PointerToXdmsdm__LicenseFunc(soap, tag, id, (Xdmsdm__LicenseFunc *const*)ptr, "Xdmsdm:LicenseFunc");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__UserInfo:
		return soap_out_PointerToPointerToXdmsdm__UserInfo(soap, tag, id, (Xdmsdm__UserInfo **const*)ptr, "Xdmsdm:UserInfo");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfo:
		return soap_out_PointerToXdmsdm__UserInfo(soap, tag, id, (Xdmsdm__UserInfo *const*)ptr, "Xdmsdm:UserInfo");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__WebServiceInfo:
		return soap_out_PointerToPointerToXdmsdm__WebServiceInfo(soap, tag, id, (Xdmsdm__WebServiceInfo **const*)ptr, "Xdmsdm:WebServiceInfo");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfo:
		return soap_out_PointerToXdmsdm__WebServiceInfo(soap, tag, id, (Xdmsdm__WebServiceInfo *const*)ptr, "Xdmsdm:WebServiceInfo");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__VersionInfo:
		return soap_out_PointerToPointerToXdmsdm__VersionInfo(soap, tag, id, (Xdmsdm__VersionInfo **const*)ptr, "Xdmsdm:VersionInfo");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfo:
		return soap_out_PointerToXdmsdm__VersionInfo(soap, tag, id, (Xdmsdm__VersionInfo *const*)ptr, "Xdmsdm:VersionInfo");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__FreqLayout:
		return soap_out_PointerToPointerToXdmsdm__FreqLayout(soap, tag, id, (Xdmsdm__FreqLayout **const*)ptr, "Xdmsdm:FreqLayout");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayout:
		return soap_out_PointerToXdmsdm__FreqLayout(soap, tag, id, (Xdmsdm__FreqLayout *const*)ptr, "Xdmsdm:FreqLayout");
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__RegionNO:
		return soap_out_PointerToPointerToXdmsdm__RegionNO(soap, tag, id, (Xdmsdm__RegionNO **const*)ptr, "Xdmsdm:RegionNO");
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNO:
		return soap_out_PointerToXdmsdm__RegionNO(soap, tag, id, (Xdmsdm__RegionNO *const*)ptr, "Xdmsdm:RegionNO");
	case SOAP_TYPE_Xdmsdm__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_Xdmsdm_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_Xdmsdm_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse:
		((_Xdmsdm__GetMonthReportBusFreqsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs:
		((_Xdmsdm__GetMonthReportBusFreqs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse:
		((_Xdmsdm__SetMonthReportBusFreqsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs:
		((_Xdmsdm__SetMonthReportBusFreqs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse:
		((_Xdmsdm__GetMonthReportWorkPlansResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans:
		((_Xdmsdm__GetMonthReportWorkPlans *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse:
		((_Xdmsdm__SetMonthReportWorkPlansResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans:
		((_Xdmsdm__SetMonthReportWorkPlans *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse:
		((_Xdmsdm__QueryUserInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo:
		((_Xdmsdm__QueryUserInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse:
		((_Xdmsdm__SendMobileMessageResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage:
		((_Xdmsdm__SendMobileMessage *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse:
		((_Xdmsdm__QueryUserMobileNOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO:
		((_Xdmsdm__QueryUserMobileNO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse:
		((_Xdmsdm__QueryStandardTimeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime:
		((_Xdmsdm__QueryStandardTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse:
		((_Xdmsdm__SubmitOperateLogResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog:
		((_Xdmsdm__SubmitOperateLog *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse:
		((_Xdmsdm__QueryUserLicenseFuncResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc:
		((_Xdmsdm__QueryUserLicenseFunc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse:
		((_Xdmsdm__AuthUserLicenseFuncResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc:
		((_Xdmsdm__AuthUserLicenseFunc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse:
		((_Xdmsdm__AuthUserResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser:
		((_Xdmsdm__AuthUser *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse:
		((_Xdmsdm__QueryWebServiceResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService:
		((_Xdmsdm__QueryWebService *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse:
		((_Xdmsdm__QueryFreqLayoutResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout:
		((_Xdmsdm__QueryFreqLayout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse:
		((_Xdmsdm__QueryRegionNOResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO:
		((_Xdmsdm__QueryRegionNO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse:
		((_Xdmsdm__QueryVersionInfoResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo:
		((_Xdmsdm__QueryVersionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray:
		((Xdmsdm__MonthReportBusFreqArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq:
		((Xdmsdm__MonthReportBusFreq *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray:
		((Xdmsdm__MonthReportWorkPlanArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan:
		((Xdmsdm__MonthReportWorkPlan *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray:
		((Xdmsdm__LicenseFuncArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc:
		((Xdmsdm__LicenseFunc *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray:
		((Xdmsdm__UserInfoArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo:
		((Xdmsdm__UserInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray:
		((Xdmsdm__WebServiceInfoArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo:
		((Xdmsdm__WebServiceInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray:
		((Xdmsdm__VersionInfoArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo:
		((Xdmsdm__VersionInfo *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray:
		((Xdmsdm__FreqLayoutArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout:
		((Xdmsdm__FreqLayout *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray:
		((Xdmsdm__RegionNOArray *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO:
		((Xdmsdm__RegionNO *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__GetMonthReportBusFreqs:
		soap_serialize___Xdmsdm__GetMonthReportBusFreqs(soap, (const struct __Xdmsdm__GetMonthReportBusFreqs *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SetMonthReportBusFreqs:
		soap_serialize___Xdmsdm__SetMonthReportBusFreqs(soap, (const struct __Xdmsdm__SetMonthReportBusFreqs *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__GetMonthReportWorkPlans:
		soap_serialize___Xdmsdm__GetMonthReportWorkPlans(soap, (const struct __Xdmsdm__GetMonthReportWorkPlans *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SetMonthReportWorkPlans:
		soap_serialize___Xdmsdm__SetMonthReportWorkPlans(soap, (const struct __Xdmsdm__SetMonthReportWorkPlans *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserInfo:
		soap_serialize___Xdmsdm__QueryUserInfo(soap, (const struct __Xdmsdm__QueryUserInfo *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SendMobileMessage:
		soap_serialize___Xdmsdm__SendMobileMessage(soap, (const struct __Xdmsdm__SendMobileMessage *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserMobileNO:
		soap_serialize___Xdmsdm__QueryUserMobileNO(soap, (const struct __Xdmsdm__QueryUserMobileNO *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryStandardTime:
		soap_serialize___Xdmsdm__QueryStandardTime(soap, (const struct __Xdmsdm__QueryStandardTime *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SubmitOperateLog:
		soap_serialize___Xdmsdm__SubmitOperateLog(soap, (const struct __Xdmsdm__SubmitOperateLog *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserLicenseFunc:
		soap_serialize___Xdmsdm__QueryUserLicenseFunc(soap, (const struct __Xdmsdm__QueryUserLicenseFunc *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__AuthUserLicenseFunc:
		soap_serialize___Xdmsdm__AuthUserLicenseFunc(soap, (const struct __Xdmsdm__AuthUserLicenseFunc *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__AuthUser:
		soap_serialize___Xdmsdm__AuthUser(soap, (const struct __Xdmsdm__AuthUser *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryWebService:
		soap_serialize___Xdmsdm__QueryWebService(soap, (const struct __Xdmsdm__QueryWebService *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryFreqLayout:
		soap_serialize___Xdmsdm__QueryFreqLayout(soap, (const struct __Xdmsdm__QueryFreqLayout *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryRegionNO:
		soap_serialize___Xdmsdm__QueryRegionNO(soap, (const struct __Xdmsdm__QueryRegionNO *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryVersionInfo:
		soap_serialize___Xdmsdm__QueryVersionInfo(soap, (const struct __Xdmsdm__QueryVersionInfo *)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse:
		soap_serialize_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse(soap, (_Xdmsdm__GetMonthReportBusFreqsResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportBusFreqs:
		soap_serialize_PointerTo_Xdmsdm__GetMonthReportBusFreqs(soap, (_Xdmsdm__GetMonthReportBusFreqs *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse:
		soap_serialize_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse(soap, (_Xdmsdm__SetMonthReportBusFreqsResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportBusFreqs:
		soap_serialize_PointerTo_Xdmsdm__SetMonthReportBusFreqs(soap, (_Xdmsdm__SetMonthReportBusFreqs *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse:
		soap_serialize_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse(soap, (_Xdmsdm__GetMonthReportWorkPlansResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportWorkPlans:
		soap_serialize_PointerTo_Xdmsdm__GetMonthReportWorkPlans(soap, (_Xdmsdm__GetMonthReportWorkPlans *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse:
		soap_serialize_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse(soap, (_Xdmsdm__SetMonthReportWorkPlansResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportWorkPlans:
		soap_serialize_PointerTo_Xdmsdm__SetMonthReportWorkPlans(soap, (_Xdmsdm__SetMonthReportWorkPlans *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserInfoResponse:
		soap_serialize_PointerTo_Xdmsdm__QueryUserInfoResponse(soap, (_Xdmsdm__QueryUserInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserInfo:
		soap_serialize_PointerTo_Xdmsdm__QueryUserInfo(soap, (_Xdmsdm__QueryUserInfo *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SendMobileMessageResponse:
		soap_serialize_PointerTo_Xdmsdm__SendMobileMessageResponse(soap, (_Xdmsdm__SendMobileMessageResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SendMobileMessage:
		soap_serialize_PointerTo_Xdmsdm__SendMobileMessage(soap, (_Xdmsdm__SendMobileMessage *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserMobileNOResponse:
		soap_serialize_PointerTo_Xdmsdm__QueryUserMobileNOResponse(soap, (_Xdmsdm__QueryUserMobileNOResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserMobileNO:
		soap_serialize_PointerTo_Xdmsdm__QueryUserMobileNO(soap, (_Xdmsdm__QueryUserMobileNO *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryStandardTimeResponse:
		soap_serialize_PointerTo_Xdmsdm__QueryStandardTimeResponse(soap, (_Xdmsdm__QueryStandardTimeResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryStandardTime:
		soap_serialize_PointerTo_Xdmsdm__QueryStandardTime(soap, (_Xdmsdm__QueryStandardTime *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SubmitOperateLogResponse:
		soap_serialize_PointerTo_Xdmsdm__SubmitOperateLogResponse(soap, (_Xdmsdm__SubmitOperateLogResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SubmitOperateLog:
		soap_serialize_PointerTo_Xdmsdm__SubmitOperateLog(soap, (_Xdmsdm__SubmitOperateLog *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse:
		soap_serialize_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse(soap, (_Xdmsdm__QueryUserLicenseFuncResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserLicenseFunc:
		soap_serialize_PointerTo_Xdmsdm__QueryUserLicenseFunc(soap, (_Xdmsdm__QueryUserLicenseFunc *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse:
		soap_serialize_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse(soap, (_Xdmsdm__AuthUserLicenseFuncResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserLicenseFunc:
		soap_serialize_PointerTo_Xdmsdm__AuthUserLicenseFunc(soap, (_Xdmsdm__AuthUserLicenseFunc *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserResponse:
		soap_serialize_PointerTo_Xdmsdm__AuthUserResponse(soap, (_Xdmsdm__AuthUserResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUser:
		soap_serialize_PointerTo_Xdmsdm__AuthUser(soap, (_Xdmsdm__AuthUser *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryWebServiceResponse:
		soap_serialize_PointerTo_Xdmsdm__QueryWebServiceResponse(soap, (_Xdmsdm__QueryWebServiceResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryWebService:
		soap_serialize_PointerTo_Xdmsdm__QueryWebService(soap, (_Xdmsdm__QueryWebService *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryFreqLayoutResponse:
		soap_serialize_PointerTo_Xdmsdm__QueryFreqLayoutResponse(soap, (_Xdmsdm__QueryFreqLayoutResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryFreqLayout:
		soap_serialize_PointerTo_Xdmsdm__QueryFreqLayout(soap, (_Xdmsdm__QueryFreqLayout *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryRegionNOResponse:
		soap_serialize_PointerTo_Xdmsdm__QueryRegionNOResponse(soap, (_Xdmsdm__QueryRegionNOResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryRegionNO:
		soap_serialize_PointerTo_Xdmsdm__QueryRegionNO(soap, (_Xdmsdm__QueryRegionNO *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryVersionInfoResponse:
		soap_serialize_PointerTo_Xdmsdm__QueryVersionInfoResponse(soap, (_Xdmsdm__QueryVersionInfoResponse *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryVersionInfo:
		soap_serialize_PointerTo_Xdmsdm__QueryVersionInfo(soap, (_Xdmsdm__QueryVersionInfo *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreqArray:
		soap_serialize_PointerToXdmsdm__MonthReportBusFreqArray(soap, (Xdmsdm__MonthReportBusFreqArray *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlanArray:
		soap_serialize_PointerToXdmsdm__MonthReportWorkPlanArray(soap, (Xdmsdm__MonthReportWorkPlanArray *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfoArray:
		soap_serialize_PointerToXdmsdm__UserInfoArray(soap, (Xdmsdm__UserInfoArray *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFuncArray:
		soap_serialize_PointerToXdmsdm__LicenseFuncArray(soap, (Xdmsdm__LicenseFuncArray *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfoArray:
		soap_serialize_PointerToXdmsdm__WebServiceInfoArray(soap, (Xdmsdm__WebServiceInfoArray *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayoutArray:
		soap_serialize_PointerToXdmsdm__FreqLayoutArray(soap, (Xdmsdm__FreqLayoutArray *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNOArray:
		soap_serialize_PointerToXdmsdm__RegionNOArray(soap, (Xdmsdm__RegionNOArray *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfoArray:
		soap_serialize_PointerToXdmsdm__VersionInfoArray(soap, (Xdmsdm__VersionInfoArray *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__MonthReportBusFreq:
		soap_serialize_PointerToPointerToXdmsdm__MonthReportBusFreq(soap, (Xdmsdm__MonthReportBusFreq **const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreq:
		soap_serialize_PointerToXdmsdm__MonthReportBusFreq(soap, (Xdmsdm__MonthReportBusFreq *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__MonthReportWorkPlan:
		soap_serialize_PointerToPointerToXdmsdm__MonthReportWorkPlan(soap, (Xdmsdm__MonthReportWorkPlan **const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlan:
		soap_serialize_PointerToXdmsdm__MonthReportWorkPlan(soap, (Xdmsdm__MonthReportWorkPlan *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__LicenseFunc:
		soap_serialize_PointerToPointerToXdmsdm__LicenseFunc(soap, (Xdmsdm__LicenseFunc **const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFunc:
		soap_serialize_PointerToXdmsdm__LicenseFunc(soap, (Xdmsdm__LicenseFunc *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__UserInfo:
		soap_serialize_PointerToPointerToXdmsdm__UserInfo(soap, (Xdmsdm__UserInfo **const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfo:
		soap_serialize_PointerToXdmsdm__UserInfo(soap, (Xdmsdm__UserInfo *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__WebServiceInfo:
		soap_serialize_PointerToPointerToXdmsdm__WebServiceInfo(soap, (Xdmsdm__WebServiceInfo **const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfo:
		soap_serialize_PointerToXdmsdm__WebServiceInfo(soap, (Xdmsdm__WebServiceInfo *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__VersionInfo:
		soap_serialize_PointerToPointerToXdmsdm__VersionInfo(soap, (Xdmsdm__VersionInfo **const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfo:
		soap_serialize_PointerToXdmsdm__VersionInfo(soap, (Xdmsdm__VersionInfo *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__FreqLayout:
		soap_serialize_PointerToPointerToXdmsdm__FreqLayout(soap, (Xdmsdm__FreqLayout **const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayout:
		soap_serialize_PointerToXdmsdm__FreqLayout(soap, (Xdmsdm__FreqLayout *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__RegionNO:
		soap_serialize_PointerToPointerToXdmsdm__RegionNO(soap, (Xdmsdm__RegionNO **const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNO:
		soap_serialize_PointerToXdmsdm__RegionNO(soap, (Xdmsdm__RegionNO *const*)ptr);
		break;
	case SOAP_TYPE_Xdmsdm__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_Xdmsdm_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 Xdmsdm_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_Xdmsdm_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO:
		return (void*)soap_instantiate_Xdmsdm__RegionNO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray:
		return (void*)soap_instantiate_Xdmsdm__RegionNOArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout:
		return (void*)soap_instantiate_Xdmsdm__FreqLayout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray:
		return (void*)soap_instantiate_Xdmsdm__FreqLayoutArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo:
		return (void*)soap_instantiate_Xdmsdm__VersionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray:
		return (void*)soap_instantiate_Xdmsdm__VersionInfoArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo:
		return (void*)soap_instantiate_Xdmsdm__WebServiceInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray:
		return (void*)soap_instantiate_Xdmsdm__WebServiceInfoArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo:
		return (void*)soap_instantiate_Xdmsdm__UserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray:
		return (void*)soap_instantiate_Xdmsdm__UserInfoArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc:
		return (void*)soap_instantiate_Xdmsdm__LicenseFunc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray:
		return (void*)soap_instantiate_Xdmsdm__LicenseFuncArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan:
		return (void*)soap_instantiate_Xdmsdm__MonthReportWorkPlan(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray:
		return (void*)soap_instantiate_Xdmsdm__MonthReportWorkPlanArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq:
		return (void*)soap_instantiate_Xdmsdm__MonthReportBusFreq(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray:
		return (void*)soap_instantiate_Xdmsdm__MonthReportBusFreqArray(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo:
		return (void*)soap_instantiate__Xdmsdm__QueryVersionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse:
		return (void*)soap_instantiate__Xdmsdm__QueryVersionInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO:
		return (void*)soap_instantiate__Xdmsdm__QueryRegionNO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse:
		return (void*)soap_instantiate__Xdmsdm__QueryRegionNOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout:
		return (void*)soap_instantiate__Xdmsdm__QueryFreqLayout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse:
		return (void*)soap_instantiate__Xdmsdm__QueryFreqLayoutResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService:
		return (void*)soap_instantiate__Xdmsdm__QueryWebService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse:
		return (void*)soap_instantiate__Xdmsdm__QueryWebServiceResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser:
		return (void*)soap_instantiate__Xdmsdm__AuthUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse:
		return (void*)soap_instantiate__Xdmsdm__AuthUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc:
		return (void*)soap_instantiate__Xdmsdm__AuthUserLicenseFunc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse:
		return (void*)soap_instantiate__Xdmsdm__AuthUserLicenseFuncResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc:
		return (void*)soap_instantiate__Xdmsdm__QueryUserLicenseFunc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse:
		return (void*)soap_instantiate__Xdmsdm__QueryUserLicenseFuncResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog:
		return (void*)soap_instantiate__Xdmsdm__SubmitOperateLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse:
		return (void*)soap_instantiate__Xdmsdm__SubmitOperateLogResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime:
		return (void*)soap_instantiate__Xdmsdm__QueryStandardTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse:
		return (void*)soap_instantiate__Xdmsdm__QueryStandardTimeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO:
		return (void*)soap_instantiate__Xdmsdm__QueryUserMobileNO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse:
		return (void*)soap_instantiate__Xdmsdm__QueryUserMobileNOResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage:
		return (void*)soap_instantiate__Xdmsdm__SendMobileMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse:
		return (void*)soap_instantiate__Xdmsdm__SendMobileMessageResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo:
		return (void*)soap_instantiate__Xdmsdm__QueryUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse:
		return (void*)soap_instantiate__Xdmsdm__QueryUserInfoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans:
		return (void*)soap_instantiate__Xdmsdm__SetMonthReportWorkPlans(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse:
		return (void*)soap_instantiate__Xdmsdm__SetMonthReportWorkPlansResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans:
		return (void*)soap_instantiate__Xdmsdm__GetMonthReportWorkPlans(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse:
		return (void*)soap_instantiate__Xdmsdm__GetMonthReportWorkPlansResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs:
		return (void*)soap_instantiate__Xdmsdm__SetMonthReportBusFreqs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse:
		return (void*)soap_instantiate__Xdmsdm__SetMonthReportBusFreqsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs:
		return (void*)soap_instantiate__Xdmsdm__GetMonthReportBusFreqs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse:
		return (void*)soap_instantiate__Xdmsdm__GetMonthReportBusFreqsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryVersionInfo:
		return (void*)soap_instantiate___Xdmsdm__QueryVersionInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryRegionNO:
		return (void*)soap_instantiate___Xdmsdm__QueryRegionNO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryFreqLayout:
		return (void*)soap_instantiate___Xdmsdm__QueryFreqLayout(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryWebService:
		return (void*)soap_instantiate___Xdmsdm__QueryWebService(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__AuthUser:
		return (void*)soap_instantiate___Xdmsdm__AuthUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__AuthUserLicenseFunc:
		return (void*)soap_instantiate___Xdmsdm__AuthUserLicenseFunc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserLicenseFunc:
		return (void*)soap_instantiate___Xdmsdm__QueryUserLicenseFunc(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SubmitOperateLog:
		return (void*)soap_instantiate___Xdmsdm__SubmitOperateLog(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryStandardTime:
		return (void*)soap_instantiate___Xdmsdm__QueryStandardTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserMobileNO:
		return (void*)soap_instantiate___Xdmsdm__QueryUserMobileNO(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SendMobileMessage:
		return (void*)soap_instantiate___Xdmsdm__SendMobileMessage(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserInfo:
		return (void*)soap_instantiate___Xdmsdm__QueryUserInfo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SetMonthReportWorkPlans:
		return (void*)soap_instantiate___Xdmsdm__SetMonthReportWorkPlans(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__GetMonthReportWorkPlans:
		return (void*)soap_instantiate___Xdmsdm__GetMonthReportWorkPlans(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SetMonthReportBusFreqs:
		return (void*)soap_instantiate___Xdmsdm__SetMonthReportBusFreqs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_Xdmsdm___Xdmsdm__GetMonthReportBusFreqs:
		return (void*)soap_instantiate___Xdmsdm__GetMonthReportBusFreqs(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Xdmsdm_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Xdmsdm_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Xdmsdm_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Xdmsdm_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Xdmsdm_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 Xdmsdm_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_Xdmsdm_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__RegionNO*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__RegionNO*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__RegionNOArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__RegionNOArray*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__FreqLayout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__FreqLayout*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__FreqLayoutArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__FreqLayoutArray*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__VersionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__VersionInfo*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__VersionInfoArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__VersionInfoArray*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__WebServiceInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__WebServiceInfo*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__WebServiceInfoArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__WebServiceInfoArray*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__UserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__UserInfo*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__UserInfoArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__UserInfoArray*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__LicenseFunc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__LicenseFunc*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__LicenseFuncArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__LicenseFuncArray*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__MonthReportWorkPlan*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__MonthReportWorkPlan*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__MonthReportWorkPlanArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__MonthReportWorkPlanArray*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__MonthReportBusFreq*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__MonthReportBusFreq*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray:
		if (p->size < 0)
			SOAP_DELETE((Xdmsdm__MonthReportBusFreqArray*)p->ptr);
		else
			SOAP_DELETE_ARRAY((Xdmsdm__MonthReportBusFreqArray*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryVersionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryVersionInfo*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryVersionInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryVersionInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryRegionNO*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryRegionNO*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryRegionNOResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryRegionNOResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryFreqLayout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryFreqLayout*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryFreqLayoutResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryFreqLayoutResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryWebService*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryWebService*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryWebServiceResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryWebServiceResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__AuthUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__AuthUser*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__AuthUserResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__AuthUserResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__AuthUserLicenseFunc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__AuthUserLicenseFunc*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__AuthUserLicenseFuncResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__AuthUserLicenseFuncResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryUserLicenseFunc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryUserLicenseFunc*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryUserLicenseFuncResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryUserLicenseFuncResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__SubmitOperateLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__SubmitOperateLog*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__SubmitOperateLogResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__SubmitOperateLogResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryStandardTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryStandardTime*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryStandardTimeResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryStandardTimeResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryUserMobileNO*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryUserMobileNO*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryUserMobileNOResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryUserMobileNOResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__SendMobileMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__SendMobileMessage*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__SendMobileMessageResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__SendMobileMessageResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryUserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryUserInfo*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__QueryUserInfoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__QueryUserInfoResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__SetMonthReportWorkPlans*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__SetMonthReportWorkPlans*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__SetMonthReportWorkPlansResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__SetMonthReportWorkPlansResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__GetMonthReportWorkPlans*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__GetMonthReportWorkPlans*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__GetMonthReportWorkPlansResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__GetMonthReportWorkPlansResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__SetMonthReportBusFreqs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__SetMonthReportBusFreqs*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__SetMonthReportBusFreqsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__SetMonthReportBusFreqsResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__GetMonthReportBusFreqs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__GetMonthReportBusFreqs*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse:
		if (p->size < 0)
			SOAP_DELETE((_Xdmsdm__GetMonthReportBusFreqsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((_Xdmsdm__GetMonthReportBusFreqsResponse*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryVersionInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__QueryVersionInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__QueryVersionInfo*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryRegionNO:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__QueryRegionNO*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__QueryRegionNO*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryFreqLayout:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__QueryFreqLayout*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__QueryFreqLayout*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryWebService:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__QueryWebService*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__QueryWebService*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__AuthUser:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__AuthUser*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__AuthUser*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__AuthUserLicenseFunc:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__AuthUserLicenseFunc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__AuthUserLicenseFunc*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserLicenseFunc:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__QueryUserLicenseFunc*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__QueryUserLicenseFunc*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SubmitOperateLog:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__SubmitOperateLog*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__SubmitOperateLog*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryStandardTime:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__QueryStandardTime*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__QueryStandardTime*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserMobileNO:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__QueryUserMobileNO*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__QueryUserMobileNO*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SendMobileMessage:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__SendMobileMessage*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__SendMobileMessage*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserInfo:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__QueryUserInfo*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__QueryUserInfo*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SetMonthReportWorkPlans:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__SetMonthReportWorkPlans*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__SetMonthReportWorkPlans*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__GetMonthReportWorkPlans:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__GetMonthReportWorkPlans*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__GetMonthReportWorkPlans*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__SetMonthReportBusFreqs:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__SetMonthReportBusFreqs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__SetMonthReportBusFreqs*)p->ptr);
		break;
	case SOAP_TYPE_Xdmsdm___Xdmsdm__GetMonthReportBusFreqs:
		if (p->size < 0)
			SOAP_DELETE((struct __Xdmsdm__GetMonthReportBusFreqs*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __Xdmsdm__GetMonthReportBusFreqs*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Xdmsdm_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Xdmsdm_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Xdmsdm_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Xdmsdm_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_Xdmsdm_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, Xdmsdm_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_Xdmsdm_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_Xdmsdm_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_Xdmsdm_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{	short *p;
	p = soap_inshort(soap, tag, a, type, SOAP_TYPE_Xdmsdm_short);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_short);
	if (soap_out_short(soap, tag?tag:"short", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_Xdmsdm_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_Xdmsdm_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_Xdmsdm_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_Xdmsdm_LONG64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_LONG64);
	if (soap_out_LONG64(soap, tag?tag:"long", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Xdmsdm__LogType(struct soap *soap, enum Xdmsdm__LogType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_Xdmsdm__LogType
	*a = SOAP_DEFAULT_Xdmsdm__LogType;
#else
	*a = (enum Xdmsdm__LogType)0;
#endif
}

static const struct soap_code_map soap_codes_Xdmsdm__LogType[] =
{	{ (long)Xdmsdm__LogType__xError, "xError" },
	{ (long)Xdmsdm__LogType__xWarning, "xWarning" },
	{ (long)Xdmsdm__LogType__xInfo, "xInfo" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_Xdmsdm__LogType2s(struct soap *soap, enum Xdmsdm__LogType n)
{	const char *s = soap_code_str(soap_codes_Xdmsdm__LogType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__LogType(struct soap *soap, const char *tag, int id, const enum Xdmsdm__LogType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__LogType), type) || soap_send(soap, soap_Xdmsdm__LogType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2Xdmsdm__LogType(struct soap *soap, const char *s, enum Xdmsdm__LogType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_Xdmsdm__LogType, s);
	if (map)
		*a = (enum Xdmsdm__LogType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum Xdmsdm__LogType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum Xdmsdm__LogType * SOAP_FMAC4 soap_in_Xdmsdm__LogType(struct soap *soap, const char *tag, enum Xdmsdm__LogType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum Xdmsdm__LogType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__LogType, sizeof(enum Xdmsdm__LogType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2Xdmsdm__LogType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum Xdmsdm__LogType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__LogType, 0, sizeof(enum Xdmsdm__LogType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Xdmsdm__LogType(struct soap *soap, const enum Xdmsdm__LogType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__LogType);
	if (soap_out_Xdmsdm__LogType(soap, tag?tag:"Xdmsdm:LogType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum Xdmsdm__LogType * SOAP_FMAC4 soap_get_Xdmsdm__LogType(struct soap *soap, enum Xdmsdm__LogType *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__LogType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_Xdmsdm__SubSystemID(struct soap *soap, enum Xdmsdm__SubSystemID *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_Xdmsdm__SubSystemID
	*a = SOAP_DEFAULT_Xdmsdm__SubSystemID;
#else
	*a = (enum Xdmsdm__SubSystemID)0;
#endif
}

static const struct soap_code_map soap_codes_Xdmsdm__SubSystemID[] =
{	{ (long)Xdmsdm__SubSystemID__xDMS, "xDMS" },
	{ (long)Xdmsdm__SubSystemID__xRMS, "xRMS" },
	{ (long)Xdmsdm__SubSystemID__xMSA, "xMSA" },
	{ (long)Xdmsdm__SubSystemID__xECS, "xECS" },
	{ (long)Xdmsdm__SubSystemID__xBSD, "xBSD" },
	{ (long)Xdmsdm__SubSystemID__xFRS, "xFRS" },
	{ (long)Xdmsdm__SubSystemID__xSMS, "xSMS" },
	{ (long)Xdmsdm__SubSystemID__xLES, "xLES" },
	{ (long)Xdmsdm__SubSystemID__xOAS, "xOAS" },
	{ (long)Xdmsdm__SubSystemID__xGIS, "xGIS" },
	{ (long)Xdmsdm__SubSystemID__xNULL, "xNULL" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_Xdmsdm__SubSystemID2s(struct soap *soap, enum Xdmsdm__SubSystemID n)
{	const char *s = soap_code_str(soap_codes_Xdmsdm__SubSystemID, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__SubSystemID(struct soap *soap, const char *tag, int id, const enum Xdmsdm__SubSystemID *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__SubSystemID), type) || soap_send(soap, soap_Xdmsdm__SubSystemID2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2Xdmsdm__SubSystemID(struct soap *soap, const char *s, enum Xdmsdm__SubSystemID *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_Xdmsdm__SubSystemID, s);
	if (map)
		*a = (enum Xdmsdm__SubSystemID)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum Xdmsdm__SubSystemID)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum Xdmsdm__SubSystemID * SOAP_FMAC4 soap_in_Xdmsdm__SubSystemID(struct soap *soap, const char *tag, enum Xdmsdm__SubSystemID *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum Xdmsdm__SubSystemID *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__SubSystemID, sizeof(enum Xdmsdm__SubSystemID), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2Xdmsdm__SubSystemID(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum Xdmsdm__SubSystemID *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__SubSystemID, 0, sizeof(enum Xdmsdm__SubSystemID), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_Xdmsdm__SubSystemID(struct soap *soap, const enum Xdmsdm__SubSystemID *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__SubSystemID);
	if (soap_out_Xdmsdm__SubSystemID(soap, tag?tag:"Xdmsdm:SubSystemID", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum Xdmsdm__SubSystemID * SOAP_FMAC4 soap_get_Xdmsdm__SubSystemID(struct soap *soap, enum Xdmsdm__SubSystemID *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__SubSystemID(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_Xdmsdm_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_Xdmsdm_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if ((t = soap_string_in(soap, 1, 0, -1)))
				s->assign(t);
			else
				return NULL;
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_Xdmsdm_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_Xdmsdm_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_std__string, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _Xdmsdm__GetMonthReportBusFreqsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__GetMonthReportBusFreqsResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__GetMonthReportBusFreqsResponse::sResult);
	this->_Xdmsdm__GetMonthReportBusFreqsResponse::cArray = NULL;
	/* transient soap skipped */
}

void _Xdmsdm__GetMonthReportBusFreqsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__GetMonthReportBusFreqsResponse::sResult);
	soap_serialize_PointerToXdmsdm__MonthReportBusFreqArray(soap, &this->_Xdmsdm__GetMonthReportBusFreqsResponse::cArray);
	/* transient soap skipped */
}

int _Xdmsdm__GetMonthReportBusFreqsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__GetMonthReportBusFreqsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__GetMonthReportBusFreqsResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__GetMonthReportBusFreqsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__GetMonthReportBusFreqsResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__GetMonthReportBusFreqsResponse::sResult), ""))
		return soap->error;
	if (a->_Xdmsdm__GetMonthReportBusFreqsResponse::cArray)
	{	if (soap_out_PointerToXdmsdm__MonthReportBusFreqArray(soap, "cArray", -1, &a->_Xdmsdm__GetMonthReportBusFreqsResponse::cArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "cArray"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__GetMonthReportBusFreqsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__GetMonthReportBusFreqsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportBusFreqsResponse * SOAP_FMAC4 soap_in__Xdmsdm__GetMonthReportBusFreqsResponse(struct soap *soap, const char *tag, _Xdmsdm__GetMonthReportBusFreqsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__GetMonthReportBusFreqsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse, sizeof(_Xdmsdm__GetMonthReportBusFreqsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__GetMonthReportBusFreqsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_cArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__GetMonthReportBusFreqsResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__GetMonthReportBusFreqsResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_cArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToXdmsdm__MonthReportBusFreqArray(soap, "cArray", &(a->_Xdmsdm__GetMonthReportBusFreqsResponse::cArray), "Xdmsdm:MonthReportBusFreqArray"))
				{	soap_flag_cArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__GetMonthReportBusFreqsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse, 0, sizeof(_Xdmsdm__GetMonthReportBusFreqsResponse), 0, soap_copy__Xdmsdm__GetMonthReportBusFreqsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_cArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__GetMonthReportBusFreqsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:GetMonthReportBusFreqsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__GetMonthReportBusFreqsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__GetMonthReportBusFreqsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportBusFreqsResponse * SOAP_FMAC4 soap_get__Xdmsdm__GetMonthReportBusFreqsResponse(struct soap *soap, _Xdmsdm__GetMonthReportBusFreqsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__GetMonthReportBusFreqsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__GetMonthReportBusFreqsResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__GetMonthReportBusFreqsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__GetMonthReportBusFreqsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__GetMonthReportBusFreqsResponse);
		if (size)
			*size = sizeof(_Xdmsdm__GetMonthReportBusFreqsResponse);
		((_Xdmsdm__GetMonthReportBusFreqsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__GetMonthReportBusFreqsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__GetMonthReportBusFreqsResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__GetMonthReportBusFreqsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__GetMonthReportBusFreqsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__GetMonthReportBusFreqsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__GetMonthReportBusFreqsResponse %p -> %p\n", q, p));
	*(_Xdmsdm__GetMonthReportBusFreqsResponse*)p = *(_Xdmsdm__GetMonthReportBusFreqsResponse*)q;
}

void _Xdmsdm__GetMonthReportBusFreqs::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_Xdmsdm__GetMonthReportBusFreqs::sAreaNO);
	soap_default_int(soap, &this->_Xdmsdm__GetMonthReportBusFreqs::nDate);
	/* transient soap skipped */
}

void _Xdmsdm__GetMonthReportBusFreqs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__GetMonthReportBusFreqs::sAreaNO);
	/* transient soap skipped */
}

int _Xdmsdm__GetMonthReportBusFreqs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__GetMonthReportBusFreqs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, const char *tag, int id, const _Xdmsdm__GetMonthReportBusFreqs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs), type))
		return soap->error;
	if (soap_out_std__string(soap, "sAreaNO", -1, &(a->_Xdmsdm__GetMonthReportBusFreqs::sAreaNO), ""))
		return soap->error;
	if (soap_out_int(soap, "nDate", -1, &(a->_Xdmsdm__GetMonthReportBusFreqs::nDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__GetMonthReportBusFreqs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__GetMonthReportBusFreqs(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportBusFreqs * SOAP_FMAC4 soap_in__Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, const char *tag, _Xdmsdm__GetMonthReportBusFreqs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__GetMonthReportBusFreqs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs, sizeof(_Xdmsdm__GetMonthReportBusFreqs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__GetMonthReportBusFreqs *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sAreaNO1 = 1;
	size_t soap_flag_nDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sAreaNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sAreaNO", &(a->_Xdmsdm__GetMonthReportBusFreqs::sAreaNO), "xsd:string"))
				{	soap_flag_sAreaNO1--;
					continue;
				}
			if (soap_flag_nDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nDate", &(a->_Xdmsdm__GetMonthReportBusFreqs::nDate), "xsd:int"))
				{	soap_flag_nDate1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__GetMonthReportBusFreqs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs, 0, sizeof(_Xdmsdm__GetMonthReportBusFreqs), 0, soap_copy__Xdmsdm__GetMonthReportBusFreqs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sAreaNO1 > 0 || soap_flag_nDate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__GetMonthReportBusFreqs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:GetMonthReportBusFreqs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__GetMonthReportBusFreqs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__GetMonthReportBusFreqs(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportBusFreqs * SOAP_FMAC4 soap_get__Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, _Xdmsdm__GetMonthReportBusFreqs *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__GetMonthReportBusFreqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__GetMonthReportBusFreqs * SOAP_FMAC2 soap_instantiate__Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__GetMonthReportBusFreqs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__GetMonthReportBusFreqs);
		if (size)
			*size = sizeof(_Xdmsdm__GetMonthReportBusFreqs);
		((_Xdmsdm__GetMonthReportBusFreqs*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__GetMonthReportBusFreqs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__GetMonthReportBusFreqs);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__GetMonthReportBusFreqs*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__GetMonthReportBusFreqs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__GetMonthReportBusFreqs %p -> %p\n", q, p));
	*(_Xdmsdm__GetMonthReportBusFreqs*)p = *(_Xdmsdm__GetMonthReportBusFreqs*)q;
}

void _Xdmsdm__SetMonthReportBusFreqsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__SetMonthReportBusFreqsResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__SetMonthReportBusFreqsResponse::sResult);
	/* transient soap skipped */
}

void _Xdmsdm__SetMonthReportBusFreqsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__SetMonthReportBusFreqsResponse::sResult);
	/* transient soap skipped */
}

int _Xdmsdm__SetMonthReportBusFreqsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__SetMonthReportBusFreqsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__SetMonthReportBusFreqsResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__SetMonthReportBusFreqsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__SetMonthReportBusFreqsResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__SetMonthReportBusFreqsResponse::sResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__SetMonthReportBusFreqsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__SetMonthReportBusFreqsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportBusFreqsResponse * SOAP_FMAC4 soap_in__Xdmsdm__SetMonthReportBusFreqsResponse(struct soap *soap, const char *tag, _Xdmsdm__SetMonthReportBusFreqsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__SetMonthReportBusFreqsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse, sizeof(_Xdmsdm__SetMonthReportBusFreqsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__SetMonthReportBusFreqsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__SetMonthReportBusFreqsResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__SetMonthReportBusFreqsResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__SetMonthReportBusFreqsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse, 0, sizeof(_Xdmsdm__SetMonthReportBusFreqsResponse), 0, soap_copy__Xdmsdm__SetMonthReportBusFreqsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__SetMonthReportBusFreqsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:SetMonthReportBusFreqsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__SetMonthReportBusFreqsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__SetMonthReportBusFreqsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportBusFreqsResponse * SOAP_FMAC4 soap_get__Xdmsdm__SetMonthReportBusFreqsResponse(struct soap *soap, _Xdmsdm__SetMonthReportBusFreqsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__SetMonthReportBusFreqsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__SetMonthReportBusFreqsResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__SetMonthReportBusFreqsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__SetMonthReportBusFreqsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SetMonthReportBusFreqsResponse);
		if (size)
			*size = sizeof(_Xdmsdm__SetMonthReportBusFreqsResponse);
		((_Xdmsdm__SetMonthReportBusFreqsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SetMonthReportBusFreqsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__SetMonthReportBusFreqsResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__SetMonthReportBusFreqsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__SetMonthReportBusFreqsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__SetMonthReportBusFreqsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__SetMonthReportBusFreqsResponse %p -> %p\n", q, p));
	*(_Xdmsdm__SetMonthReportBusFreqsResponse*)p = *(_Xdmsdm__SetMonthReportBusFreqsResponse*)q;
}

void _Xdmsdm__SetMonthReportBusFreqs::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Xdmsdm__SetMonthReportBusFreqs::cArray = NULL;
	/* transient soap skipped */
}

void _Xdmsdm__SetMonthReportBusFreqs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToXdmsdm__MonthReportBusFreqArray(soap, &this->_Xdmsdm__SetMonthReportBusFreqs::cArray);
	/* transient soap skipped */
}

int _Xdmsdm__SetMonthReportBusFreqs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__SetMonthReportBusFreqs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, const char *tag, int id, const _Xdmsdm__SetMonthReportBusFreqs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs), type))
		return soap->error;
	if (a->_Xdmsdm__SetMonthReportBusFreqs::cArray)
	{	if (soap_out_PointerToXdmsdm__MonthReportBusFreqArray(soap, "cArray", -1, &a->_Xdmsdm__SetMonthReportBusFreqs::cArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "cArray"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__SetMonthReportBusFreqs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__SetMonthReportBusFreqs(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportBusFreqs * SOAP_FMAC4 soap_in__Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, const char *tag, _Xdmsdm__SetMonthReportBusFreqs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__SetMonthReportBusFreqs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs, sizeof(_Xdmsdm__SetMonthReportBusFreqs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__SetMonthReportBusFreqs *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToXdmsdm__MonthReportBusFreqArray(soap, "cArray", &(a->_Xdmsdm__SetMonthReportBusFreqs::cArray), "Xdmsdm:MonthReportBusFreqArray"))
				{	soap_flag_cArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__SetMonthReportBusFreqs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs, 0, sizeof(_Xdmsdm__SetMonthReportBusFreqs), 0, soap_copy__Xdmsdm__SetMonthReportBusFreqs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__SetMonthReportBusFreqs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:SetMonthReportBusFreqs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__SetMonthReportBusFreqs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__SetMonthReportBusFreqs(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportBusFreqs * SOAP_FMAC4 soap_get__Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, _Xdmsdm__SetMonthReportBusFreqs *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__SetMonthReportBusFreqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__SetMonthReportBusFreqs * SOAP_FMAC2 soap_instantiate__Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__SetMonthReportBusFreqs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SetMonthReportBusFreqs);
		if (size)
			*size = sizeof(_Xdmsdm__SetMonthReportBusFreqs);
		((_Xdmsdm__SetMonthReportBusFreqs*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SetMonthReportBusFreqs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__SetMonthReportBusFreqs);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__SetMonthReportBusFreqs*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__SetMonthReportBusFreqs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__SetMonthReportBusFreqs %p -> %p\n", q, p));
	*(_Xdmsdm__SetMonthReportBusFreqs*)p = *(_Xdmsdm__SetMonthReportBusFreqs*)q;
}

void _Xdmsdm__GetMonthReportWorkPlansResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__GetMonthReportWorkPlansResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__GetMonthReportWorkPlansResponse::sResult);
	this->_Xdmsdm__GetMonthReportWorkPlansResponse::cArray = NULL;
	/* transient soap skipped */
}

void _Xdmsdm__GetMonthReportWorkPlansResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__GetMonthReportWorkPlansResponse::sResult);
	soap_serialize_PointerToXdmsdm__MonthReportWorkPlanArray(soap, &this->_Xdmsdm__GetMonthReportWorkPlansResponse::cArray);
	/* transient soap skipped */
}

int _Xdmsdm__GetMonthReportWorkPlansResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__GetMonthReportWorkPlansResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__GetMonthReportWorkPlansResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__GetMonthReportWorkPlansResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__GetMonthReportWorkPlansResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__GetMonthReportWorkPlansResponse::sResult), ""))
		return soap->error;
	if (a->_Xdmsdm__GetMonthReportWorkPlansResponse::cArray)
	{	if (soap_out_PointerToXdmsdm__MonthReportWorkPlanArray(soap, "cArray", -1, &a->_Xdmsdm__GetMonthReportWorkPlansResponse::cArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "cArray"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__GetMonthReportWorkPlansResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__GetMonthReportWorkPlansResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportWorkPlansResponse * SOAP_FMAC4 soap_in__Xdmsdm__GetMonthReportWorkPlansResponse(struct soap *soap, const char *tag, _Xdmsdm__GetMonthReportWorkPlansResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__GetMonthReportWorkPlansResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse, sizeof(_Xdmsdm__GetMonthReportWorkPlansResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__GetMonthReportWorkPlansResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_cArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__GetMonthReportWorkPlansResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__GetMonthReportWorkPlansResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_cArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToXdmsdm__MonthReportWorkPlanArray(soap, "cArray", &(a->_Xdmsdm__GetMonthReportWorkPlansResponse::cArray), "Xdmsdm:MonthReportWorkPlanArray"))
				{	soap_flag_cArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__GetMonthReportWorkPlansResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse, 0, sizeof(_Xdmsdm__GetMonthReportWorkPlansResponse), 0, soap_copy__Xdmsdm__GetMonthReportWorkPlansResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_cArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__GetMonthReportWorkPlansResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:GetMonthReportWorkPlansResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__GetMonthReportWorkPlansResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__GetMonthReportWorkPlansResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportWorkPlansResponse * SOAP_FMAC4 soap_get__Xdmsdm__GetMonthReportWorkPlansResponse(struct soap *soap, _Xdmsdm__GetMonthReportWorkPlansResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__GetMonthReportWorkPlansResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__GetMonthReportWorkPlansResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__GetMonthReportWorkPlansResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__GetMonthReportWorkPlansResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__GetMonthReportWorkPlansResponse);
		if (size)
			*size = sizeof(_Xdmsdm__GetMonthReportWorkPlansResponse);
		((_Xdmsdm__GetMonthReportWorkPlansResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__GetMonthReportWorkPlansResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__GetMonthReportWorkPlansResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__GetMonthReportWorkPlansResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__GetMonthReportWorkPlansResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__GetMonthReportWorkPlansResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__GetMonthReportWorkPlansResponse %p -> %p\n", q, p));
	*(_Xdmsdm__GetMonthReportWorkPlansResponse*)p = *(_Xdmsdm__GetMonthReportWorkPlansResponse*)q;
}

void _Xdmsdm__GetMonthReportWorkPlans::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_Xdmsdm__GetMonthReportWorkPlans::sAreaNO);
	soap_default_int(soap, &this->_Xdmsdm__GetMonthReportWorkPlans::nDate);
	/* transient soap skipped */
}

void _Xdmsdm__GetMonthReportWorkPlans::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__GetMonthReportWorkPlans::sAreaNO);
	/* transient soap skipped */
}

int _Xdmsdm__GetMonthReportWorkPlans::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__GetMonthReportWorkPlans(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, const char *tag, int id, const _Xdmsdm__GetMonthReportWorkPlans *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans), type))
		return soap->error;
	if (soap_out_std__string(soap, "sAreaNO", -1, &(a->_Xdmsdm__GetMonthReportWorkPlans::sAreaNO), ""))
		return soap->error;
	if (soap_out_int(soap, "nDate", -1, &(a->_Xdmsdm__GetMonthReportWorkPlans::nDate), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__GetMonthReportWorkPlans::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__GetMonthReportWorkPlans(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportWorkPlans * SOAP_FMAC4 soap_in__Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, const char *tag, _Xdmsdm__GetMonthReportWorkPlans *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__GetMonthReportWorkPlans *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans, sizeof(_Xdmsdm__GetMonthReportWorkPlans), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__GetMonthReportWorkPlans *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sAreaNO1 = 1;
	size_t soap_flag_nDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sAreaNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sAreaNO", &(a->_Xdmsdm__GetMonthReportWorkPlans::sAreaNO), "xsd:string"))
				{	soap_flag_sAreaNO1--;
					continue;
				}
			if (soap_flag_nDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nDate", &(a->_Xdmsdm__GetMonthReportWorkPlans::nDate), "xsd:int"))
				{	soap_flag_nDate1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__GetMonthReportWorkPlans *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans, 0, sizeof(_Xdmsdm__GetMonthReportWorkPlans), 0, soap_copy__Xdmsdm__GetMonthReportWorkPlans);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sAreaNO1 > 0 || soap_flag_nDate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__GetMonthReportWorkPlans::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:GetMonthReportWorkPlans", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__GetMonthReportWorkPlans::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__GetMonthReportWorkPlans(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportWorkPlans * SOAP_FMAC4 soap_get__Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, _Xdmsdm__GetMonthReportWorkPlans *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__GetMonthReportWorkPlans(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__GetMonthReportWorkPlans * SOAP_FMAC2 soap_instantiate__Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__GetMonthReportWorkPlans(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__GetMonthReportWorkPlans);
		if (size)
			*size = sizeof(_Xdmsdm__GetMonthReportWorkPlans);
		((_Xdmsdm__GetMonthReportWorkPlans*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__GetMonthReportWorkPlans[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__GetMonthReportWorkPlans);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__GetMonthReportWorkPlans*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__GetMonthReportWorkPlans*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__GetMonthReportWorkPlans %p -> %p\n", q, p));
	*(_Xdmsdm__GetMonthReportWorkPlans*)p = *(_Xdmsdm__GetMonthReportWorkPlans*)q;
}

void _Xdmsdm__SetMonthReportWorkPlansResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__SetMonthReportWorkPlansResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__SetMonthReportWorkPlansResponse::sResult);
	/* transient soap skipped */
}

void _Xdmsdm__SetMonthReportWorkPlansResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__SetMonthReportWorkPlansResponse::sResult);
	/* transient soap skipped */
}

int _Xdmsdm__SetMonthReportWorkPlansResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__SetMonthReportWorkPlansResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__SetMonthReportWorkPlansResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__SetMonthReportWorkPlansResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__SetMonthReportWorkPlansResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__SetMonthReportWorkPlansResponse::sResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__SetMonthReportWorkPlansResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__SetMonthReportWorkPlansResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportWorkPlansResponse * SOAP_FMAC4 soap_in__Xdmsdm__SetMonthReportWorkPlansResponse(struct soap *soap, const char *tag, _Xdmsdm__SetMonthReportWorkPlansResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__SetMonthReportWorkPlansResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse, sizeof(_Xdmsdm__SetMonthReportWorkPlansResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__SetMonthReportWorkPlansResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__SetMonthReportWorkPlansResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__SetMonthReportWorkPlansResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__SetMonthReportWorkPlansResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse, 0, sizeof(_Xdmsdm__SetMonthReportWorkPlansResponse), 0, soap_copy__Xdmsdm__SetMonthReportWorkPlansResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__SetMonthReportWorkPlansResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:SetMonthReportWorkPlansResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__SetMonthReportWorkPlansResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__SetMonthReportWorkPlansResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportWorkPlansResponse * SOAP_FMAC4 soap_get__Xdmsdm__SetMonthReportWorkPlansResponse(struct soap *soap, _Xdmsdm__SetMonthReportWorkPlansResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__SetMonthReportWorkPlansResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__SetMonthReportWorkPlansResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__SetMonthReportWorkPlansResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__SetMonthReportWorkPlansResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SetMonthReportWorkPlansResponse);
		if (size)
			*size = sizeof(_Xdmsdm__SetMonthReportWorkPlansResponse);
		((_Xdmsdm__SetMonthReportWorkPlansResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SetMonthReportWorkPlansResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__SetMonthReportWorkPlansResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__SetMonthReportWorkPlansResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__SetMonthReportWorkPlansResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__SetMonthReportWorkPlansResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__SetMonthReportWorkPlansResponse %p -> %p\n", q, p));
	*(_Xdmsdm__SetMonthReportWorkPlansResponse*)p = *(_Xdmsdm__SetMonthReportWorkPlansResponse*)q;
}

void _Xdmsdm__SetMonthReportWorkPlans::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_Xdmsdm__SetMonthReportWorkPlans::cArray = NULL;
	/* transient soap skipped */
}

void _Xdmsdm__SetMonthReportWorkPlans::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToXdmsdm__MonthReportWorkPlanArray(soap, &this->_Xdmsdm__SetMonthReportWorkPlans::cArray);
	/* transient soap skipped */
}

int _Xdmsdm__SetMonthReportWorkPlans::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__SetMonthReportWorkPlans(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, const char *tag, int id, const _Xdmsdm__SetMonthReportWorkPlans *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans), type))
		return soap->error;
	if (a->_Xdmsdm__SetMonthReportWorkPlans::cArray)
	{	if (soap_out_PointerToXdmsdm__MonthReportWorkPlanArray(soap, "cArray", -1, &a->_Xdmsdm__SetMonthReportWorkPlans::cArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "cArray"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__SetMonthReportWorkPlans::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__SetMonthReportWorkPlans(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportWorkPlans * SOAP_FMAC4 soap_in__Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, const char *tag, _Xdmsdm__SetMonthReportWorkPlans *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__SetMonthReportWorkPlans *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans, sizeof(_Xdmsdm__SetMonthReportWorkPlans), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__SetMonthReportWorkPlans *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToXdmsdm__MonthReportWorkPlanArray(soap, "cArray", &(a->_Xdmsdm__SetMonthReportWorkPlans::cArray), "Xdmsdm:MonthReportWorkPlanArray"))
				{	soap_flag_cArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__SetMonthReportWorkPlans *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans, 0, sizeof(_Xdmsdm__SetMonthReportWorkPlans), 0, soap_copy__Xdmsdm__SetMonthReportWorkPlans);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__SetMonthReportWorkPlans::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:SetMonthReportWorkPlans", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__SetMonthReportWorkPlans::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__SetMonthReportWorkPlans(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportWorkPlans * SOAP_FMAC4 soap_get__Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, _Xdmsdm__SetMonthReportWorkPlans *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__SetMonthReportWorkPlans(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__SetMonthReportWorkPlans * SOAP_FMAC2 soap_instantiate__Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__SetMonthReportWorkPlans(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SetMonthReportWorkPlans);
		if (size)
			*size = sizeof(_Xdmsdm__SetMonthReportWorkPlans);
		((_Xdmsdm__SetMonthReportWorkPlans*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SetMonthReportWorkPlans[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__SetMonthReportWorkPlans);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__SetMonthReportWorkPlans*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__SetMonthReportWorkPlans*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__SetMonthReportWorkPlans %p -> %p\n", q, p));
	*(_Xdmsdm__SetMonthReportWorkPlans*)p = *(_Xdmsdm__SetMonthReportWorkPlans*)q;
}

void _Xdmsdm__QueryUserInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__QueryUserInfoResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__QueryUserInfoResponse::sResult);
	this->_Xdmsdm__QueryUserInfoResponse::cArray = NULL;
	/* transient soap skipped */
}

void _Xdmsdm__QueryUserInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryUserInfoResponse::sResult);
	soap_serialize_PointerToXdmsdm__UserInfoArray(soap, &this->_Xdmsdm__QueryUserInfoResponse::cArray);
	/* transient soap skipped */
}

int _Xdmsdm__QueryUserInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryUserInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryUserInfoResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryUserInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__QueryUserInfoResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__QueryUserInfoResponse::sResult), ""))
		return soap->error;
	if (a->_Xdmsdm__QueryUserInfoResponse::cArray)
	{	if (soap_out_PointerToXdmsdm__UserInfoArray(soap, "cArray", -1, &a->_Xdmsdm__QueryUserInfoResponse::cArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "cArray"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryUserInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryUserInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserInfoResponse * SOAP_FMAC4 soap_in__Xdmsdm__QueryUserInfoResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryUserInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryUserInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse, sizeof(_Xdmsdm__QueryUserInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryUserInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_cArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__QueryUserInfoResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__QueryUserInfoResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_cArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToXdmsdm__UserInfoArray(soap, "cArray", &(a->_Xdmsdm__QueryUserInfoResponse::cArray), "Xdmsdm:UserInfoArray"))
				{	soap_flag_cArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryUserInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse, 0, sizeof(_Xdmsdm__QueryUserInfoResponse), 0, soap_copy__Xdmsdm__QueryUserInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_cArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryUserInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryUserInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryUserInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryUserInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserInfoResponse * SOAP_FMAC4 soap_get__Xdmsdm__QueryUserInfoResponse(struct soap *soap, _Xdmsdm__QueryUserInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryUserInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryUserInfoResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryUserInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryUserInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserInfoResponse);
		if (size)
			*size = sizeof(_Xdmsdm__QueryUserInfoResponse);
		((_Xdmsdm__QueryUserInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryUserInfoResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryUserInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryUserInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryUserInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryUserInfoResponse %p -> %p\n", q, p));
	*(_Xdmsdm__QueryUserInfoResponse*)p = *(_Xdmsdm__QueryUserInfoResponse*)q;
}

void _Xdmsdm__QueryUserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _Xdmsdm__QueryUserInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Xdmsdm__QueryUserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryUserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryUserInfo(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryUserInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryUserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryUserInfo(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserInfo * SOAP_FMAC4 soap_in__Xdmsdm__QueryUserInfo(struct soap *soap, const char *tag, _Xdmsdm__QueryUserInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryUserInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo, sizeof(_Xdmsdm__QueryUserInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryUserInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryUserInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo, 0, sizeof(_Xdmsdm__QueryUserInfo), 0, soap_copy__Xdmsdm__QueryUserInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _Xdmsdm__QueryUserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryUserInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryUserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryUserInfo(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserInfo * SOAP_FMAC4 soap_get__Xdmsdm__QueryUserInfo(struct soap *soap, _Xdmsdm__QueryUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryUserInfo * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserInfo);
		if (size)
			*size = sizeof(_Xdmsdm__QueryUserInfo);
		((_Xdmsdm__QueryUserInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryUserInfo);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryUserInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryUserInfo %p -> %p\n", q, p));
	*(_Xdmsdm__QueryUserInfo*)p = *(_Xdmsdm__QueryUserInfo*)q;
}

void _Xdmsdm__SendMobileMessageResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__SendMobileMessageResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__SendMobileMessageResponse::sResult);
	/* transient soap skipped */
}

void _Xdmsdm__SendMobileMessageResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__SendMobileMessageResponse::sResult);
	/* transient soap skipped */
}

int _Xdmsdm__SendMobileMessageResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__SendMobileMessageResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__SendMobileMessageResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__SendMobileMessageResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__SendMobileMessageResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__SendMobileMessageResponse::sResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__SendMobileMessageResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__SendMobileMessageResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__SendMobileMessageResponse * SOAP_FMAC4 soap_in__Xdmsdm__SendMobileMessageResponse(struct soap *soap, const char *tag, _Xdmsdm__SendMobileMessageResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__SendMobileMessageResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse, sizeof(_Xdmsdm__SendMobileMessageResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__SendMobileMessageResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__SendMobileMessageResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__SendMobileMessageResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__SendMobileMessageResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse, 0, sizeof(_Xdmsdm__SendMobileMessageResponse), 0, soap_copy__Xdmsdm__SendMobileMessageResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__SendMobileMessageResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:SendMobileMessageResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__SendMobileMessageResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__SendMobileMessageResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__SendMobileMessageResponse * SOAP_FMAC4 soap_get__Xdmsdm__SendMobileMessageResponse(struct soap *soap, _Xdmsdm__SendMobileMessageResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__SendMobileMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__SendMobileMessageResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__SendMobileMessageResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__SendMobileMessageResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SendMobileMessageResponse);
		if (size)
			*size = sizeof(_Xdmsdm__SendMobileMessageResponse);
		((_Xdmsdm__SendMobileMessageResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SendMobileMessageResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__SendMobileMessageResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__SendMobileMessageResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__SendMobileMessageResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__SendMobileMessageResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__SendMobileMessageResponse %p -> %p\n", q, p));
	*(_Xdmsdm__SendMobileMessageResponse*)p = *(_Xdmsdm__SendMobileMessageResponse*)q;
}

void _Xdmsdm__SendMobileMessage::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_Xdmsdm__SendMobileMessage::sMobileNo);
	soap_default_std__string(soap, &this->_Xdmsdm__SendMobileMessage::sMsg);
	/* transient soap skipped */
}

void _Xdmsdm__SendMobileMessage::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__SendMobileMessage::sMobileNo);
	soap_serialize_std__string(soap, &this->_Xdmsdm__SendMobileMessage::sMsg);
	/* transient soap skipped */
}

int _Xdmsdm__SendMobileMessage::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__SendMobileMessage(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__SendMobileMessage(struct soap *soap, const char *tag, int id, const _Xdmsdm__SendMobileMessage *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage), type))
		return soap->error;
	if (soap_out_std__string(soap, "sMobileNo", -1, &(a->_Xdmsdm__SendMobileMessage::sMobileNo), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sMsg", -1, &(a->_Xdmsdm__SendMobileMessage::sMsg), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__SendMobileMessage::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__SendMobileMessage(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__SendMobileMessage * SOAP_FMAC4 soap_in__Xdmsdm__SendMobileMessage(struct soap *soap, const char *tag, _Xdmsdm__SendMobileMessage *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__SendMobileMessage *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage, sizeof(_Xdmsdm__SendMobileMessage), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__SendMobileMessage *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sMobileNo1 = 1;
	size_t soap_flag_sMsg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sMobileNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sMobileNo", &(a->_Xdmsdm__SendMobileMessage::sMobileNo), "xsd:string"))
				{	soap_flag_sMobileNo1--;
					continue;
				}
			if (soap_flag_sMsg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sMsg", &(a->_Xdmsdm__SendMobileMessage::sMsg), "xsd:string"))
				{	soap_flag_sMsg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__SendMobileMessage *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage, 0, sizeof(_Xdmsdm__SendMobileMessage), 0, soap_copy__Xdmsdm__SendMobileMessage);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sMobileNo1 > 0 || soap_flag_sMsg1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__SendMobileMessage::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:SendMobileMessage", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__SendMobileMessage::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__SendMobileMessage(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__SendMobileMessage * SOAP_FMAC4 soap_get__Xdmsdm__SendMobileMessage(struct soap *soap, _Xdmsdm__SendMobileMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__SendMobileMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__SendMobileMessage * SOAP_FMAC2 soap_instantiate__Xdmsdm__SendMobileMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__SendMobileMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SendMobileMessage);
		if (size)
			*size = sizeof(_Xdmsdm__SendMobileMessage);
		((_Xdmsdm__SendMobileMessage*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SendMobileMessage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__SendMobileMessage);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__SendMobileMessage*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__SendMobileMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__SendMobileMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__SendMobileMessage %p -> %p\n", q, p));
	*(_Xdmsdm__SendMobileMessage*)p = *(_Xdmsdm__SendMobileMessage*)q;
}

void _Xdmsdm__QueryUserMobileNOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__QueryUserMobileNOResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__QueryUserMobileNOResponse::sResult);
	soap_default_std__string(soap, &this->_Xdmsdm__QueryUserMobileNOResponse::sMobileNO);
	/* transient soap skipped */
}

void _Xdmsdm__QueryUserMobileNOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryUserMobileNOResponse::sResult);
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryUserMobileNOResponse::sMobileNO);
	/* transient soap skipped */
}

int _Xdmsdm__QueryUserMobileNOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryUserMobileNOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryUserMobileNOResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryUserMobileNOResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__QueryUserMobileNOResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__QueryUserMobileNOResponse::sResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sMobileNO", -1, &(a->_Xdmsdm__QueryUserMobileNOResponse::sMobileNO), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryUserMobileNOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryUserMobileNOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserMobileNOResponse * SOAP_FMAC4 soap_in__Xdmsdm__QueryUserMobileNOResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryUserMobileNOResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryUserMobileNOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse, sizeof(_Xdmsdm__QueryUserMobileNOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryUserMobileNOResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_sMobileNO1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__QueryUserMobileNOResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__QueryUserMobileNOResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_sMobileNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sMobileNO", &(a->_Xdmsdm__QueryUserMobileNOResponse::sMobileNO), "xsd:string"))
				{	soap_flag_sMobileNO1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryUserMobileNOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse, 0, sizeof(_Xdmsdm__QueryUserMobileNOResponse), 0, soap_copy__Xdmsdm__QueryUserMobileNOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_sMobileNO1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryUserMobileNOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryUserMobileNOResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryUserMobileNOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryUserMobileNOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserMobileNOResponse * SOAP_FMAC4 soap_get__Xdmsdm__QueryUserMobileNOResponse(struct soap *soap, _Xdmsdm__QueryUserMobileNOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryUserMobileNOResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryUserMobileNOResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryUserMobileNOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryUserMobileNOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserMobileNOResponse);
		if (size)
			*size = sizeof(_Xdmsdm__QueryUserMobileNOResponse);
		((_Xdmsdm__QueryUserMobileNOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserMobileNOResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryUserMobileNOResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryUserMobileNOResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryUserMobileNOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryUserMobileNOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryUserMobileNOResponse %p -> %p\n", q, p));
	*(_Xdmsdm__QueryUserMobileNOResponse*)p = *(_Xdmsdm__QueryUserMobileNOResponse*)q;
}

void _Xdmsdm__QueryUserMobileNO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_Xdmsdm__QueryUserMobileNO::sUser);
	/* transient soap skipped */
}

void _Xdmsdm__QueryUserMobileNO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryUserMobileNO::sUser);
	/* transient soap skipped */
}

int _Xdmsdm__QueryUserMobileNO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryUserMobileNO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryUserMobileNO(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryUserMobileNO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO), type))
		return soap->error;
	if (soap_out_std__string(soap, "sUser", -1, &(a->_Xdmsdm__QueryUserMobileNO::sUser), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryUserMobileNO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryUserMobileNO(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserMobileNO * SOAP_FMAC4 soap_in__Xdmsdm__QueryUserMobileNO(struct soap *soap, const char *tag, _Xdmsdm__QueryUserMobileNO *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryUserMobileNO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO, sizeof(_Xdmsdm__QueryUserMobileNO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryUserMobileNO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sUser1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sUser", &(a->_Xdmsdm__QueryUserMobileNO::sUser), "xsd:string"))
				{	soap_flag_sUser1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryUserMobileNO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO, 0, sizeof(_Xdmsdm__QueryUserMobileNO), 0, soap_copy__Xdmsdm__QueryUserMobileNO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sUser1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryUserMobileNO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryUserMobileNO", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryUserMobileNO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryUserMobileNO(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserMobileNO * SOAP_FMAC4 soap_get__Xdmsdm__QueryUserMobileNO(struct soap *soap, _Xdmsdm__QueryUserMobileNO *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryUserMobileNO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryUserMobileNO * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryUserMobileNO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryUserMobileNO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserMobileNO);
		if (size)
			*size = sizeof(_Xdmsdm__QueryUserMobileNO);
		((_Xdmsdm__QueryUserMobileNO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserMobileNO[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryUserMobileNO);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryUserMobileNO*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryUserMobileNO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryUserMobileNO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryUserMobileNO %p -> %p\n", q, p));
	*(_Xdmsdm__QueryUserMobileNO*)p = *(_Xdmsdm__QueryUserMobileNO*)q;
}

void _Xdmsdm__QueryStandardTimeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__QueryStandardTimeResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__QueryStandardTimeResponse::sResult);
	soap_default_LONG64(soap, &this->_Xdmsdm__QueryStandardTimeResponse::nTime);
	/* transient soap skipped */
}

void _Xdmsdm__QueryStandardTimeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryStandardTimeResponse::sResult);
	/* transient soap skipped */
}

int _Xdmsdm__QueryStandardTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryStandardTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryStandardTimeResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryStandardTimeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__QueryStandardTimeResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__QueryStandardTimeResponse::sResult), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "nTime", -1, &(a->_Xdmsdm__QueryStandardTimeResponse::nTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryStandardTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryStandardTimeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryStandardTimeResponse * SOAP_FMAC4 soap_in__Xdmsdm__QueryStandardTimeResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryStandardTimeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryStandardTimeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse, sizeof(_Xdmsdm__QueryStandardTimeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryStandardTimeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_nTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__QueryStandardTimeResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__QueryStandardTimeResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_nTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "nTime", &(a->_Xdmsdm__QueryStandardTimeResponse::nTime), "xsd:long"))
				{	soap_flag_nTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryStandardTimeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse, 0, sizeof(_Xdmsdm__QueryStandardTimeResponse), 0, soap_copy__Xdmsdm__QueryStandardTimeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_nTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryStandardTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryStandardTimeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryStandardTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryStandardTimeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryStandardTimeResponse * SOAP_FMAC4 soap_get__Xdmsdm__QueryStandardTimeResponse(struct soap *soap, _Xdmsdm__QueryStandardTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryStandardTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryStandardTimeResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryStandardTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryStandardTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryStandardTimeResponse);
		if (size)
			*size = sizeof(_Xdmsdm__QueryStandardTimeResponse);
		((_Xdmsdm__QueryStandardTimeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryStandardTimeResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryStandardTimeResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryStandardTimeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryStandardTimeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryStandardTimeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryStandardTimeResponse %p -> %p\n", q, p));
	*(_Xdmsdm__QueryStandardTimeResponse*)p = *(_Xdmsdm__QueryStandardTimeResponse*)q;
}

void _Xdmsdm__QueryStandardTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _Xdmsdm__QueryStandardTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Xdmsdm__QueryStandardTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryStandardTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryStandardTime(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryStandardTime *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryStandardTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryStandardTime(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryStandardTime * SOAP_FMAC4 soap_in__Xdmsdm__QueryStandardTime(struct soap *soap, const char *tag, _Xdmsdm__QueryStandardTime *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryStandardTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime, sizeof(_Xdmsdm__QueryStandardTime), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryStandardTime *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryStandardTime *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime, 0, sizeof(_Xdmsdm__QueryStandardTime), 0, soap_copy__Xdmsdm__QueryStandardTime);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _Xdmsdm__QueryStandardTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryStandardTime", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryStandardTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryStandardTime(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryStandardTime * SOAP_FMAC4 soap_get__Xdmsdm__QueryStandardTime(struct soap *soap, _Xdmsdm__QueryStandardTime *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryStandardTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryStandardTime * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryStandardTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryStandardTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryStandardTime);
		if (size)
			*size = sizeof(_Xdmsdm__QueryStandardTime);
		((_Xdmsdm__QueryStandardTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryStandardTime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryStandardTime);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryStandardTime*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryStandardTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryStandardTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryStandardTime %p -> %p\n", q, p));
	*(_Xdmsdm__QueryStandardTime*)p = *(_Xdmsdm__QueryStandardTime*)q;
}

void _Xdmsdm__SubmitOperateLogResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__SubmitOperateLogResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__SubmitOperateLogResponse::sResult);
	/* transient soap skipped */
}

void _Xdmsdm__SubmitOperateLogResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__SubmitOperateLogResponse::sResult);
	/* transient soap skipped */
}

int _Xdmsdm__SubmitOperateLogResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__SubmitOperateLogResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__SubmitOperateLogResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__SubmitOperateLogResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__SubmitOperateLogResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__SubmitOperateLogResponse::sResult), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__SubmitOperateLogResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__SubmitOperateLogResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__SubmitOperateLogResponse * SOAP_FMAC4 soap_in__Xdmsdm__SubmitOperateLogResponse(struct soap *soap, const char *tag, _Xdmsdm__SubmitOperateLogResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__SubmitOperateLogResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse, sizeof(_Xdmsdm__SubmitOperateLogResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__SubmitOperateLogResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__SubmitOperateLogResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__SubmitOperateLogResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__SubmitOperateLogResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse, 0, sizeof(_Xdmsdm__SubmitOperateLogResponse), 0, soap_copy__Xdmsdm__SubmitOperateLogResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__SubmitOperateLogResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:SubmitOperateLogResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__SubmitOperateLogResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__SubmitOperateLogResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__SubmitOperateLogResponse * SOAP_FMAC4 soap_get__Xdmsdm__SubmitOperateLogResponse(struct soap *soap, _Xdmsdm__SubmitOperateLogResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__SubmitOperateLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__SubmitOperateLogResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__SubmitOperateLogResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__SubmitOperateLogResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SubmitOperateLogResponse);
		if (size)
			*size = sizeof(_Xdmsdm__SubmitOperateLogResponse);
		((_Xdmsdm__SubmitOperateLogResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SubmitOperateLogResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__SubmitOperateLogResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__SubmitOperateLogResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__SubmitOperateLogResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__SubmitOperateLogResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__SubmitOperateLogResponse %p -> %p\n", q, p));
	*(_Xdmsdm__SubmitOperateLogResponse*)p = *(_Xdmsdm__SubmitOperateLogResponse*)q;
}

void _Xdmsdm__SubmitOperateLog::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_Xdmsdm__SubmitOperateLog::sUser);
	soap_default_Xdmsdm__SubSystemID(soap, &this->_Xdmsdm__SubmitOperateLog::eSubSystemID);
	soap_default_std__string(soap, &this->_Xdmsdm__SubmitOperateLog::sIP);
	soap_default_std__string(soap, &this->_Xdmsdm__SubmitOperateLog::sLog);
	soap_default_Xdmsdm__LogType(soap, &this->_Xdmsdm__SubmitOperateLog::eLogType);
	/* transient soap skipped */
}

void _Xdmsdm__SubmitOperateLog::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__SubmitOperateLog::sUser);
	soap_serialize_std__string(soap, &this->_Xdmsdm__SubmitOperateLog::sIP);
	soap_serialize_std__string(soap, &this->_Xdmsdm__SubmitOperateLog::sLog);
	/* transient soap skipped */
}

int _Xdmsdm__SubmitOperateLog::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__SubmitOperateLog(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__SubmitOperateLog(struct soap *soap, const char *tag, int id, const _Xdmsdm__SubmitOperateLog *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog), type))
		return soap->error;
	if (soap_out_std__string(soap, "sUser", -1, &(a->_Xdmsdm__SubmitOperateLog::sUser), ""))
		return soap->error;
	if (soap_out_Xdmsdm__SubSystemID(soap, "eSubSystemID", -1, &(a->_Xdmsdm__SubmitOperateLog::eSubSystemID), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sIP", -1, &(a->_Xdmsdm__SubmitOperateLog::sIP), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sLog", -1, &(a->_Xdmsdm__SubmitOperateLog::sLog), ""))
		return soap->error;
	if (soap_out_Xdmsdm__LogType(soap, "eLogType", -1, &(a->_Xdmsdm__SubmitOperateLog::eLogType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__SubmitOperateLog::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__SubmitOperateLog(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__SubmitOperateLog * SOAP_FMAC4 soap_in__Xdmsdm__SubmitOperateLog(struct soap *soap, const char *tag, _Xdmsdm__SubmitOperateLog *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__SubmitOperateLog *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog, sizeof(_Xdmsdm__SubmitOperateLog), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__SubmitOperateLog *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sUser1 = 1;
	size_t soap_flag_eSubSystemID1 = 1;
	size_t soap_flag_sIP1 = 1;
	size_t soap_flag_sLog1 = 1;
	size_t soap_flag_eLogType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sUser", &(a->_Xdmsdm__SubmitOperateLog::sUser), "xsd:string"))
				{	soap_flag_sUser1--;
					continue;
				}
			if (soap_flag_eSubSystemID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Xdmsdm__SubSystemID(soap, "eSubSystemID", &(a->_Xdmsdm__SubmitOperateLog::eSubSystemID), "Xdmsdm:SubSystemID"))
				{	soap_flag_eSubSystemID1--;
					continue;
				}
			if (soap_flag_sIP1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sIP", &(a->_Xdmsdm__SubmitOperateLog::sIP), "xsd:string"))
				{	soap_flag_sIP1--;
					continue;
				}
			if (soap_flag_sLog1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sLog", &(a->_Xdmsdm__SubmitOperateLog::sLog), "xsd:string"))
				{	soap_flag_sLog1--;
					continue;
				}
			if (soap_flag_eLogType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Xdmsdm__LogType(soap, "eLogType", &(a->_Xdmsdm__SubmitOperateLog::eLogType), "Xdmsdm:LogType"))
				{	soap_flag_eLogType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__SubmitOperateLog *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog, 0, sizeof(_Xdmsdm__SubmitOperateLog), 0, soap_copy__Xdmsdm__SubmitOperateLog);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sUser1 > 0 || soap_flag_eSubSystemID1 > 0 || soap_flag_sIP1 > 0 || soap_flag_sLog1 > 0 || soap_flag_eLogType1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__SubmitOperateLog::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:SubmitOperateLog", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__SubmitOperateLog::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__SubmitOperateLog(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__SubmitOperateLog * SOAP_FMAC4 soap_get__Xdmsdm__SubmitOperateLog(struct soap *soap, _Xdmsdm__SubmitOperateLog *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__SubmitOperateLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__SubmitOperateLog * SOAP_FMAC2 soap_instantiate__Xdmsdm__SubmitOperateLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__SubmitOperateLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SubmitOperateLog);
		if (size)
			*size = sizeof(_Xdmsdm__SubmitOperateLog);
		((_Xdmsdm__SubmitOperateLog*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__SubmitOperateLog[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__SubmitOperateLog);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__SubmitOperateLog*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__SubmitOperateLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__SubmitOperateLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__SubmitOperateLog %p -> %p\n", q, p));
	*(_Xdmsdm__SubmitOperateLog*)p = *(_Xdmsdm__SubmitOperateLog*)q;
}

void _Xdmsdm__QueryUserLicenseFuncResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__QueryUserLicenseFuncResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__QueryUserLicenseFuncResponse::sResult);
	this->_Xdmsdm__QueryUserLicenseFuncResponse::LicenseFuncArray = NULL;
	/* transient soap skipped */
}

void _Xdmsdm__QueryUserLicenseFuncResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryUserLicenseFuncResponse::sResult);
	soap_serialize_PointerToXdmsdm__LicenseFuncArray(soap, &this->_Xdmsdm__QueryUserLicenseFuncResponse::LicenseFuncArray);
	/* transient soap skipped */
}

int _Xdmsdm__QueryUserLicenseFuncResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryUserLicenseFuncResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryUserLicenseFuncResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryUserLicenseFuncResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__QueryUserLicenseFuncResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__QueryUserLicenseFuncResponse::sResult), ""))
		return soap->error;
	if (a->_Xdmsdm__QueryUserLicenseFuncResponse::LicenseFuncArray)
	{	if (soap_out_PointerToXdmsdm__LicenseFuncArray(soap, "LicenseFuncArray", -1, &a->_Xdmsdm__QueryUserLicenseFuncResponse::LicenseFuncArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "LicenseFuncArray"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryUserLicenseFuncResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryUserLicenseFuncResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserLicenseFuncResponse * SOAP_FMAC4 soap_in__Xdmsdm__QueryUserLicenseFuncResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryUserLicenseFuncResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryUserLicenseFuncResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse, sizeof(_Xdmsdm__QueryUserLicenseFuncResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryUserLicenseFuncResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_LicenseFuncArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__QueryUserLicenseFuncResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__QueryUserLicenseFuncResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_LicenseFuncArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToXdmsdm__LicenseFuncArray(soap, "LicenseFuncArray", &(a->_Xdmsdm__QueryUserLicenseFuncResponse::LicenseFuncArray), "Xdmsdm:LicenseFuncArray"))
				{	soap_flag_LicenseFuncArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryUserLicenseFuncResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse, 0, sizeof(_Xdmsdm__QueryUserLicenseFuncResponse), 0, soap_copy__Xdmsdm__QueryUserLicenseFuncResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_LicenseFuncArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryUserLicenseFuncResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryUserLicenseFuncResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryUserLicenseFuncResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryUserLicenseFuncResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserLicenseFuncResponse * SOAP_FMAC4 soap_get__Xdmsdm__QueryUserLicenseFuncResponse(struct soap *soap, _Xdmsdm__QueryUserLicenseFuncResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryUserLicenseFuncResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryUserLicenseFuncResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryUserLicenseFuncResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryUserLicenseFuncResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserLicenseFuncResponse);
		if (size)
			*size = sizeof(_Xdmsdm__QueryUserLicenseFuncResponse);
		((_Xdmsdm__QueryUserLicenseFuncResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserLicenseFuncResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryUserLicenseFuncResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryUserLicenseFuncResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryUserLicenseFuncResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryUserLicenseFuncResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryUserLicenseFuncResponse %p -> %p\n", q, p));
	*(_Xdmsdm__QueryUserLicenseFuncResponse*)p = *(_Xdmsdm__QueryUserLicenseFuncResponse*)q;
}

void _Xdmsdm__QueryUserLicenseFunc::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_Xdmsdm__QueryUserLicenseFunc::sUser);
	/* transient soap skipped */
}

void _Xdmsdm__QueryUserLicenseFunc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryUserLicenseFunc::sUser);
	/* transient soap skipped */
}

int _Xdmsdm__QueryUserLicenseFunc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryUserLicenseFunc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryUserLicenseFunc(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryUserLicenseFunc *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc), type))
		return soap->error;
	if (soap_out_std__string(soap, "sUser", -1, &(a->_Xdmsdm__QueryUserLicenseFunc::sUser), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryUserLicenseFunc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryUserLicenseFunc(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserLicenseFunc * SOAP_FMAC4 soap_in__Xdmsdm__QueryUserLicenseFunc(struct soap *soap, const char *tag, _Xdmsdm__QueryUserLicenseFunc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryUserLicenseFunc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc, sizeof(_Xdmsdm__QueryUserLicenseFunc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryUserLicenseFunc *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sUser1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sUser", &(a->_Xdmsdm__QueryUserLicenseFunc::sUser), "xsd:string"))
				{	soap_flag_sUser1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryUserLicenseFunc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc, 0, sizeof(_Xdmsdm__QueryUserLicenseFunc), 0, soap_copy__Xdmsdm__QueryUserLicenseFunc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sUser1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryUserLicenseFunc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryUserLicenseFunc", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryUserLicenseFunc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryUserLicenseFunc(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserLicenseFunc * SOAP_FMAC4 soap_get__Xdmsdm__QueryUserLicenseFunc(struct soap *soap, _Xdmsdm__QueryUserLicenseFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryUserLicenseFunc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryUserLicenseFunc * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryUserLicenseFunc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryUserLicenseFunc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserLicenseFunc);
		if (size)
			*size = sizeof(_Xdmsdm__QueryUserLicenseFunc);
		((_Xdmsdm__QueryUserLicenseFunc*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryUserLicenseFunc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryUserLicenseFunc);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryUserLicenseFunc*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryUserLicenseFunc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryUserLicenseFunc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryUserLicenseFunc %p -> %p\n", q, p));
	*(_Xdmsdm__QueryUserLicenseFunc*)p = *(_Xdmsdm__QueryUserLicenseFunc*)q;
}

void _Xdmsdm__AuthUserLicenseFuncResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__AuthUserLicenseFuncResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__AuthUserLicenseFuncResponse::sResult);
	soap_default_bool(soap, &this->_Xdmsdm__AuthUserLicenseFuncResponse::bPass);
	/* transient soap skipped */
}

void _Xdmsdm__AuthUserLicenseFuncResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__AuthUserLicenseFuncResponse::sResult);
	/* transient soap skipped */
}

int _Xdmsdm__AuthUserLicenseFuncResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__AuthUserLicenseFuncResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__AuthUserLicenseFuncResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__AuthUserLicenseFuncResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__AuthUserLicenseFuncResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__AuthUserLicenseFuncResponse::sResult), ""))
		return soap->error;
	if (soap_out_bool(soap, "bPass", -1, &(a->_Xdmsdm__AuthUserLicenseFuncResponse::bPass), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__AuthUserLicenseFuncResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__AuthUserLicenseFuncResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUserLicenseFuncResponse * SOAP_FMAC4 soap_in__Xdmsdm__AuthUserLicenseFuncResponse(struct soap *soap, const char *tag, _Xdmsdm__AuthUserLicenseFuncResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__AuthUserLicenseFuncResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse, sizeof(_Xdmsdm__AuthUserLicenseFuncResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__AuthUserLicenseFuncResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_bPass1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__AuthUserLicenseFuncResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__AuthUserLicenseFuncResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_bPass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bPass", &(a->_Xdmsdm__AuthUserLicenseFuncResponse::bPass), "xsd:boolean"))
				{	soap_flag_bPass1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__AuthUserLicenseFuncResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse, 0, sizeof(_Xdmsdm__AuthUserLicenseFuncResponse), 0, soap_copy__Xdmsdm__AuthUserLicenseFuncResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_bPass1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__AuthUserLicenseFuncResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:AuthUserLicenseFuncResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__AuthUserLicenseFuncResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__AuthUserLicenseFuncResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUserLicenseFuncResponse * SOAP_FMAC4 soap_get__Xdmsdm__AuthUserLicenseFuncResponse(struct soap *soap, _Xdmsdm__AuthUserLicenseFuncResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__AuthUserLicenseFuncResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__AuthUserLicenseFuncResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__AuthUserLicenseFuncResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__AuthUserLicenseFuncResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__AuthUserLicenseFuncResponse);
		if (size)
			*size = sizeof(_Xdmsdm__AuthUserLicenseFuncResponse);
		((_Xdmsdm__AuthUserLicenseFuncResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__AuthUserLicenseFuncResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__AuthUserLicenseFuncResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__AuthUserLicenseFuncResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__AuthUserLicenseFuncResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__AuthUserLicenseFuncResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__AuthUserLicenseFuncResponse %p -> %p\n", q, p));
	*(_Xdmsdm__AuthUserLicenseFuncResponse*)p = *(_Xdmsdm__AuthUserLicenseFuncResponse*)q;
}

void _Xdmsdm__AuthUserLicenseFunc::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_Xdmsdm__AuthUserLicenseFunc::sUser);
	soap_default_std__string(soap, &this->_Xdmsdm__AuthUserLicenseFunc::sFuncNO);
	/* transient soap skipped */
}

void _Xdmsdm__AuthUserLicenseFunc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__AuthUserLicenseFunc::sUser);
	soap_serialize_std__string(soap, &this->_Xdmsdm__AuthUserLicenseFunc::sFuncNO);
	/* transient soap skipped */
}

int _Xdmsdm__AuthUserLicenseFunc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__AuthUserLicenseFunc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__AuthUserLicenseFunc(struct soap *soap, const char *tag, int id, const _Xdmsdm__AuthUserLicenseFunc *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc), type))
		return soap->error;
	if (soap_out_std__string(soap, "sUser", -1, &(a->_Xdmsdm__AuthUserLicenseFunc::sUser), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sFuncNO", -1, &(a->_Xdmsdm__AuthUserLicenseFunc::sFuncNO), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__AuthUserLicenseFunc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__AuthUserLicenseFunc(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUserLicenseFunc * SOAP_FMAC4 soap_in__Xdmsdm__AuthUserLicenseFunc(struct soap *soap, const char *tag, _Xdmsdm__AuthUserLicenseFunc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__AuthUserLicenseFunc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc, sizeof(_Xdmsdm__AuthUserLicenseFunc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__AuthUserLicenseFunc *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sUser1 = 1;
	size_t soap_flag_sFuncNO1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sUser", &(a->_Xdmsdm__AuthUserLicenseFunc::sUser), "xsd:string"))
				{	soap_flag_sUser1--;
					continue;
				}
			if (soap_flag_sFuncNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sFuncNO", &(a->_Xdmsdm__AuthUserLicenseFunc::sFuncNO), "xsd:string"))
				{	soap_flag_sFuncNO1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__AuthUserLicenseFunc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc, 0, sizeof(_Xdmsdm__AuthUserLicenseFunc), 0, soap_copy__Xdmsdm__AuthUserLicenseFunc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sUser1 > 0 || soap_flag_sFuncNO1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__AuthUserLicenseFunc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:AuthUserLicenseFunc", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__AuthUserLicenseFunc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__AuthUserLicenseFunc(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUserLicenseFunc * SOAP_FMAC4 soap_get__Xdmsdm__AuthUserLicenseFunc(struct soap *soap, _Xdmsdm__AuthUserLicenseFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__AuthUserLicenseFunc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__AuthUserLicenseFunc * SOAP_FMAC2 soap_instantiate__Xdmsdm__AuthUserLicenseFunc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__AuthUserLicenseFunc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__AuthUserLicenseFunc);
		if (size)
			*size = sizeof(_Xdmsdm__AuthUserLicenseFunc);
		((_Xdmsdm__AuthUserLicenseFunc*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__AuthUserLicenseFunc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__AuthUserLicenseFunc);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__AuthUserLicenseFunc*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__AuthUserLicenseFunc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__AuthUserLicenseFunc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__AuthUserLicenseFunc %p -> %p\n", q, p));
	*(_Xdmsdm__AuthUserLicenseFunc*)p = *(_Xdmsdm__AuthUserLicenseFunc*)q;
}

void _Xdmsdm__AuthUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__AuthUserResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__AuthUserResponse::sResult);
	soap_default_bool(soap, &this->_Xdmsdm__AuthUserResponse::bPass);
	soap_default_std__string(soap, &this->_Xdmsdm__AuthUserResponse::sUserToken);
	/* transient soap skipped */
}

void _Xdmsdm__AuthUserResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__AuthUserResponse::sResult);
	soap_serialize_std__string(soap, &this->_Xdmsdm__AuthUserResponse::sUserToken);
	/* transient soap skipped */
}

int _Xdmsdm__AuthUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__AuthUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__AuthUserResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__AuthUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__AuthUserResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__AuthUserResponse::sResult), ""))
		return soap->error;
	if (soap_out_bool(soap, "bPass", -1, &(a->_Xdmsdm__AuthUserResponse::bPass), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sUserToken", -1, &(a->_Xdmsdm__AuthUserResponse::sUserToken), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__AuthUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__AuthUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUserResponse * SOAP_FMAC4 soap_in__Xdmsdm__AuthUserResponse(struct soap *soap, const char *tag, _Xdmsdm__AuthUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__AuthUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse, sizeof(_Xdmsdm__AuthUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__AuthUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_bPass1 = 1;
	size_t soap_flag_sUserToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__AuthUserResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__AuthUserResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_bPass1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "bPass", &(a->_Xdmsdm__AuthUserResponse::bPass), "xsd:boolean"))
				{	soap_flag_bPass1--;
					continue;
				}
			if (soap_flag_sUserToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sUserToken", &(a->_Xdmsdm__AuthUserResponse::sUserToken), "xsd:string"))
				{	soap_flag_sUserToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__AuthUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse, 0, sizeof(_Xdmsdm__AuthUserResponse), 0, soap_copy__Xdmsdm__AuthUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_bPass1 > 0 || soap_flag_sUserToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__AuthUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:AuthUserResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__AuthUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__AuthUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUserResponse * SOAP_FMAC4 soap_get__Xdmsdm__AuthUserResponse(struct soap *soap, _Xdmsdm__AuthUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__AuthUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__AuthUserResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__AuthUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__AuthUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__AuthUserResponse);
		if (size)
			*size = sizeof(_Xdmsdm__AuthUserResponse);
		((_Xdmsdm__AuthUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__AuthUserResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__AuthUserResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__AuthUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__AuthUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__AuthUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__AuthUserResponse %p -> %p\n", q, p));
	*(_Xdmsdm__AuthUserResponse*)p = *(_Xdmsdm__AuthUserResponse*)q;
}

void _Xdmsdm__AuthUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_Xdmsdm__AuthUser::sUser);
	soap_default_std__string(soap, &this->_Xdmsdm__AuthUser::sPassword);
	/* transient soap skipped */
}

void _Xdmsdm__AuthUser::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__AuthUser::sUser);
	soap_serialize_std__string(soap, &this->_Xdmsdm__AuthUser::sPassword);
	/* transient soap skipped */
}

int _Xdmsdm__AuthUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__AuthUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__AuthUser(struct soap *soap, const char *tag, int id, const _Xdmsdm__AuthUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser), type))
		return soap->error;
	if (soap_out_std__string(soap, "sUser", -1, &(a->_Xdmsdm__AuthUser::sUser), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sPassword", -1, &(a->_Xdmsdm__AuthUser::sPassword), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__AuthUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__AuthUser(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUser * SOAP_FMAC4 soap_in__Xdmsdm__AuthUser(struct soap *soap, const char *tag, _Xdmsdm__AuthUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__AuthUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser, sizeof(_Xdmsdm__AuthUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__AuthUser *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sUser1 = 1;
	size_t soap_flag_sPassword1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sUser", &(a->_Xdmsdm__AuthUser::sUser), "xsd:string"))
				{	soap_flag_sUser1--;
					continue;
				}
			if (soap_flag_sPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sPassword", &(a->_Xdmsdm__AuthUser::sPassword), "xsd:string"))
				{	soap_flag_sPassword1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__AuthUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser, 0, sizeof(_Xdmsdm__AuthUser), 0, soap_copy__Xdmsdm__AuthUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sUser1 > 0 || soap_flag_sPassword1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__AuthUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:AuthUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__AuthUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__AuthUser(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUser * SOAP_FMAC4 soap_get__Xdmsdm__AuthUser(struct soap *soap, _Xdmsdm__AuthUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__AuthUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__AuthUser * SOAP_FMAC2 soap_instantiate__Xdmsdm__AuthUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__AuthUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__AuthUser);
		if (size)
			*size = sizeof(_Xdmsdm__AuthUser);
		((_Xdmsdm__AuthUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__AuthUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__AuthUser);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__AuthUser*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__AuthUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__AuthUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__AuthUser %p -> %p\n", q, p));
	*(_Xdmsdm__AuthUser*)p = *(_Xdmsdm__AuthUser*)q;
}

void _Xdmsdm__QueryWebServiceResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__QueryWebServiceResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__QueryWebServiceResponse::sResult);
	this->_Xdmsdm__QueryWebServiceResponse::WebServiceInfoArray = NULL;
	/* transient soap skipped */
}

void _Xdmsdm__QueryWebServiceResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryWebServiceResponse::sResult);
	soap_serialize_PointerToXdmsdm__WebServiceInfoArray(soap, &this->_Xdmsdm__QueryWebServiceResponse::WebServiceInfoArray);
	/* transient soap skipped */
}

int _Xdmsdm__QueryWebServiceResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryWebServiceResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryWebServiceResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryWebServiceResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__QueryWebServiceResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__QueryWebServiceResponse::sResult), ""))
		return soap->error;
	if (a->_Xdmsdm__QueryWebServiceResponse::WebServiceInfoArray)
	{	if (soap_out_PointerToXdmsdm__WebServiceInfoArray(soap, "WebServiceInfoArray", -1, &a->_Xdmsdm__QueryWebServiceResponse::WebServiceInfoArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "WebServiceInfoArray"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryWebServiceResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryWebServiceResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryWebServiceResponse * SOAP_FMAC4 soap_in__Xdmsdm__QueryWebServiceResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryWebServiceResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryWebServiceResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse, sizeof(_Xdmsdm__QueryWebServiceResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryWebServiceResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_WebServiceInfoArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__QueryWebServiceResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__QueryWebServiceResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_WebServiceInfoArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToXdmsdm__WebServiceInfoArray(soap, "WebServiceInfoArray", &(a->_Xdmsdm__QueryWebServiceResponse::WebServiceInfoArray), "Xdmsdm:WebServiceInfoArray"))
				{	soap_flag_WebServiceInfoArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryWebServiceResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse, 0, sizeof(_Xdmsdm__QueryWebServiceResponse), 0, soap_copy__Xdmsdm__QueryWebServiceResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_WebServiceInfoArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryWebServiceResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryWebServiceResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryWebServiceResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryWebServiceResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryWebServiceResponse * SOAP_FMAC4 soap_get__Xdmsdm__QueryWebServiceResponse(struct soap *soap, _Xdmsdm__QueryWebServiceResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryWebServiceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryWebServiceResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryWebServiceResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryWebServiceResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryWebServiceResponse);
		if (size)
			*size = sizeof(_Xdmsdm__QueryWebServiceResponse);
		((_Xdmsdm__QueryWebServiceResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryWebServiceResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryWebServiceResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryWebServiceResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryWebServiceResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryWebServiceResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryWebServiceResponse %p -> %p\n", q, p));
	*(_Xdmsdm__QueryWebServiceResponse*)p = *(_Xdmsdm__QueryWebServiceResponse*)q;
}

void _Xdmsdm__QueryWebService::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_Xdmsdm__SubSystemID(soap, &this->_Xdmsdm__QueryWebService::eSubSystemID);
	soap_default_int(soap, &this->_Xdmsdm__QueryWebService::nSubSystemModID);
	/* transient soap skipped */
}

void _Xdmsdm__QueryWebService::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Xdmsdm__QueryWebService::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryWebService(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryWebService(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryWebService *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService), type))
		return soap->error;
	if (soap_out_Xdmsdm__SubSystemID(soap, "eSubSystemID", -1, &(a->_Xdmsdm__QueryWebService::eSubSystemID), ""))
		return soap->error;
	if (soap_out_int(soap, "nSubSystemModID", -1, &(a->_Xdmsdm__QueryWebService::nSubSystemModID), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryWebService::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryWebService(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryWebService * SOAP_FMAC4 soap_in__Xdmsdm__QueryWebService(struct soap *soap, const char *tag, _Xdmsdm__QueryWebService *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryWebService *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService, sizeof(_Xdmsdm__QueryWebService), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryWebService *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_eSubSystemID1 = 1;
	size_t soap_flag_nSubSystemModID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eSubSystemID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_Xdmsdm__SubSystemID(soap, "eSubSystemID", &(a->_Xdmsdm__QueryWebService::eSubSystemID), "Xdmsdm:SubSystemID"))
				{	soap_flag_eSubSystemID1--;
					continue;
				}
			if (soap_flag_nSubSystemModID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nSubSystemModID", &(a->_Xdmsdm__QueryWebService::nSubSystemModID), "xsd:int"))
				{	soap_flag_nSubSystemModID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryWebService *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService, 0, sizeof(_Xdmsdm__QueryWebService), 0, soap_copy__Xdmsdm__QueryWebService);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eSubSystemID1 > 0 || soap_flag_nSubSystemModID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryWebService::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryWebService", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryWebService::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryWebService(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryWebService * SOAP_FMAC4 soap_get__Xdmsdm__QueryWebService(struct soap *soap, _Xdmsdm__QueryWebService *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryWebService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryWebService * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryWebService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryWebService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryWebService);
		if (size)
			*size = sizeof(_Xdmsdm__QueryWebService);
		((_Xdmsdm__QueryWebService*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryWebService[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryWebService);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryWebService*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryWebService*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryWebService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryWebService %p -> %p\n", q, p));
	*(_Xdmsdm__QueryWebService*)p = *(_Xdmsdm__QueryWebService*)q;
}

void _Xdmsdm__QueryFreqLayoutResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__QueryFreqLayoutResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__QueryFreqLayoutResponse::sResult);
	this->_Xdmsdm__QueryFreqLayoutResponse::cArray = NULL;
	/* transient soap skipped */
}

void _Xdmsdm__QueryFreqLayoutResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryFreqLayoutResponse::sResult);
	soap_serialize_PointerToXdmsdm__FreqLayoutArray(soap, &this->_Xdmsdm__QueryFreqLayoutResponse::cArray);
	/* transient soap skipped */
}

int _Xdmsdm__QueryFreqLayoutResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryFreqLayoutResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryFreqLayoutResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryFreqLayoutResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__QueryFreqLayoutResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__QueryFreqLayoutResponse::sResult), ""))
		return soap->error;
	if (a->_Xdmsdm__QueryFreqLayoutResponse::cArray)
	{	if (soap_out_PointerToXdmsdm__FreqLayoutArray(soap, "cArray", -1, &a->_Xdmsdm__QueryFreqLayoutResponse::cArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "cArray"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryFreqLayoutResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryFreqLayoutResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryFreqLayoutResponse * SOAP_FMAC4 soap_in__Xdmsdm__QueryFreqLayoutResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryFreqLayoutResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryFreqLayoutResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse, sizeof(_Xdmsdm__QueryFreqLayoutResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryFreqLayoutResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_cArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__QueryFreqLayoutResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__QueryFreqLayoutResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_cArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToXdmsdm__FreqLayoutArray(soap, "cArray", &(a->_Xdmsdm__QueryFreqLayoutResponse::cArray), "Xdmsdm:FreqLayoutArray"))
				{	soap_flag_cArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryFreqLayoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse, 0, sizeof(_Xdmsdm__QueryFreqLayoutResponse), 0, soap_copy__Xdmsdm__QueryFreqLayoutResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_cArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryFreqLayoutResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryFreqLayoutResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryFreqLayoutResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryFreqLayoutResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryFreqLayoutResponse * SOAP_FMAC4 soap_get__Xdmsdm__QueryFreqLayoutResponse(struct soap *soap, _Xdmsdm__QueryFreqLayoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryFreqLayoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryFreqLayoutResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryFreqLayoutResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryFreqLayoutResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryFreqLayoutResponse);
		if (size)
			*size = sizeof(_Xdmsdm__QueryFreqLayoutResponse);
		((_Xdmsdm__QueryFreqLayoutResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryFreqLayoutResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryFreqLayoutResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryFreqLayoutResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryFreqLayoutResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryFreqLayoutResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryFreqLayoutResponse %p -> %p\n", q, p));
	*(_Xdmsdm__QueryFreqLayoutResponse*)p = *(_Xdmsdm__QueryFreqLayoutResponse*)q;
}

void _Xdmsdm__QueryFreqLayout::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _Xdmsdm__QueryFreqLayout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Xdmsdm__QueryFreqLayout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryFreqLayout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryFreqLayout(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryFreqLayout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryFreqLayout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryFreqLayout(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryFreqLayout * SOAP_FMAC4 soap_in__Xdmsdm__QueryFreqLayout(struct soap *soap, const char *tag, _Xdmsdm__QueryFreqLayout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryFreqLayout *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout, sizeof(_Xdmsdm__QueryFreqLayout), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryFreqLayout *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryFreqLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout, 0, sizeof(_Xdmsdm__QueryFreqLayout), 0, soap_copy__Xdmsdm__QueryFreqLayout);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _Xdmsdm__QueryFreqLayout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryFreqLayout", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryFreqLayout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryFreqLayout(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryFreqLayout * SOAP_FMAC4 soap_get__Xdmsdm__QueryFreqLayout(struct soap *soap, _Xdmsdm__QueryFreqLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryFreqLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryFreqLayout * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryFreqLayout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryFreqLayout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryFreqLayout);
		if (size)
			*size = sizeof(_Xdmsdm__QueryFreqLayout);
		((_Xdmsdm__QueryFreqLayout*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryFreqLayout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryFreqLayout);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryFreqLayout*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryFreqLayout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryFreqLayout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryFreqLayout %p -> %p\n", q, p));
	*(_Xdmsdm__QueryFreqLayout*)p = *(_Xdmsdm__QueryFreqLayout*)q;
}

void _Xdmsdm__QueryRegionNOResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__QueryRegionNOResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__QueryRegionNOResponse::sResult);
	this->_Xdmsdm__QueryRegionNOResponse::RegionNOArray = NULL;
	/* transient soap skipped */
}

void _Xdmsdm__QueryRegionNOResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryRegionNOResponse::sResult);
	soap_serialize_PointerToXdmsdm__RegionNOArray(soap, &this->_Xdmsdm__QueryRegionNOResponse::RegionNOArray);
	/* transient soap skipped */
}

int _Xdmsdm__QueryRegionNOResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryRegionNOResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryRegionNOResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryRegionNOResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__QueryRegionNOResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__QueryRegionNOResponse::sResult), ""))
		return soap->error;
	if (a->_Xdmsdm__QueryRegionNOResponse::RegionNOArray)
	{	if (soap_out_PointerToXdmsdm__RegionNOArray(soap, "RegionNOArray", -1, &a->_Xdmsdm__QueryRegionNOResponse::RegionNOArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "RegionNOArray"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryRegionNOResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryRegionNOResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryRegionNOResponse * SOAP_FMAC4 soap_in__Xdmsdm__QueryRegionNOResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryRegionNOResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryRegionNOResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse, sizeof(_Xdmsdm__QueryRegionNOResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryRegionNOResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_RegionNOArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__QueryRegionNOResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__QueryRegionNOResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_RegionNOArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToXdmsdm__RegionNOArray(soap, "RegionNOArray", &(a->_Xdmsdm__QueryRegionNOResponse::RegionNOArray), "Xdmsdm:RegionNOArray"))
				{	soap_flag_RegionNOArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryRegionNOResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse, 0, sizeof(_Xdmsdm__QueryRegionNOResponse), 0, soap_copy__Xdmsdm__QueryRegionNOResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_RegionNOArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryRegionNOResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryRegionNOResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryRegionNOResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryRegionNOResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryRegionNOResponse * SOAP_FMAC4 soap_get__Xdmsdm__QueryRegionNOResponse(struct soap *soap, _Xdmsdm__QueryRegionNOResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryRegionNOResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryRegionNOResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryRegionNOResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryRegionNOResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryRegionNOResponse);
		if (size)
			*size = sizeof(_Xdmsdm__QueryRegionNOResponse);
		((_Xdmsdm__QueryRegionNOResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryRegionNOResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryRegionNOResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryRegionNOResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryRegionNOResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryRegionNOResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryRegionNOResponse %p -> %p\n", q, p));
	*(_Xdmsdm__QueryRegionNOResponse*)p = *(_Xdmsdm__QueryRegionNOResponse*)q;
}

void _Xdmsdm__QueryRegionNO::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _Xdmsdm__QueryRegionNO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Xdmsdm__QueryRegionNO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryRegionNO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryRegionNO(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryRegionNO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryRegionNO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryRegionNO(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryRegionNO * SOAP_FMAC4 soap_in__Xdmsdm__QueryRegionNO(struct soap *soap, const char *tag, _Xdmsdm__QueryRegionNO *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryRegionNO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO, sizeof(_Xdmsdm__QueryRegionNO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryRegionNO *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryRegionNO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO, 0, sizeof(_Xdmsdm__QueryRegionNO), 0, soap_copy__Xdmsdm__QueryRegionNO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _Xdmsdm__QueryRegionNO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryRegionNO", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryRegionNO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryRegionNO(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryRegionNO * SOAP_FMAC4 soap_get__Xdmsdm__QueryRegionNO(struct soap *soap, _Xdmsdm__QueryRegionNO *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryRegionNO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryRegionNO * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryRegionNO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryRegionNO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryRegionNO);
		if (size)
			*size = sizeof(_Xdmsdm__QueryRegionNO);
		((_Xdmsdm__QueryRegionNO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryRegionNO[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryRegionNO);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryRegionNO*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryRegionNO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryRegionNO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryRegionNO %p -> %p\n", q, p));
	*(_Xdmsdm__QueryRegionNO*)p = *(_Xdmsdm__QueryRegionNO*)q;
}

void _Xdmsdm__QueryVersionInfoResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_Xdmsdm__QueryVersionInfoResponse::nResult);
	soap_default_std__string(soap, &this->_Xdmsdm__QueryVersionInfoResponse::sResult);
	this->_Xdmsdm__QueryVersionInfoResponse::VerInfoArray = NULL;
	/* transient soap skipped */
}

void _Xdmsdm__QueryVersionInfoResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->_Xdmsdm__QueryVersionInfoResponse::sResult);
	soap_serialize_PointerToXdmsdm__VersionInfoArray(soap, &this->_Xdmsdm__QueryVersionInfoResponse::VerInfoArray);
	/* transient soap skipped */
}

int _Xdmsdm__QueryVersionInfoResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryVersionInfoResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryVersionInfoResponse(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryVersionInfoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse), type))
		return soap->error;
	if (soap_out_int(soap, "nResult", -1, &(a->_Xdmsdm__QueryVersionInfoResponse::nResult), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sResult", -1, &(a->_Xdmsdm__QueryVersionInfoResponse::sResult), ""))
		return soap->error;
	if (a->_Xdmsdm__QueryVersionInfoResponse::VerInfoArray)
	{	if (soap_out_PointerToXdmsdm__VersionInfoArray(soap, "VerInfoArray", -1, &a->_Xdmsdm__QueryVersionInfoResponse::VerInfoArray, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "VerInfoArray"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryVersionInfoResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryVersionInfoResponse(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryVersionInfoResponse * SOAP_FMAC4 soap_in__Xdmsdm__QueryVersionInfoResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryVersionInfoResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryVersionInfoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse, sizeof(_Xdmsdm__QueryVersionInfoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryVersionInfoResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_nResult1 = 1;
	size_t soap_flag_sResult1 = 1;
	size_t soap_flag_VerInfoArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nResult", &(a->_Xdmsdm__QueryVersionInfoResponse::nResult), "xsd:int"))
				{	soap_flag_nResult1--;
					continue;
				}
			if (soap_flag_sResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sResult", &(a->_Xdmsdm__QueryVersionInfoResponse::sResult), "xsd:string"))
				{	soap_flag_sResult1--;
					continue;
				}
			if (soap_flag_VerInfoArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToXdmsdm__VersionInfoArray(soap, "VerInfoArray", &(a->_Xdmsdm__QueryVersionInfoResponse::VerInfoArray), "Xdmsdm:VersionInfoArray"))
				{	soap_flag_VerInfoArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryVersionInfoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse, 0, sizeof(_Xdmsdm__QueryVersionInfoResponse), 0, soap_copy__Xdmsdm__QueryVersionInfoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_nResult1 > 0 || soap_flag_sResult1 > 0 || soap_flag_VerInfoArray1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _Xdmsdm__QueryVersionInfoResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryVersionInfoResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryVersionInfoResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryVersionInfoResponse(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryVersionInfoResponse * SOAP_FMAC4 soap_get__Xdmsdm__QueryVersionInfoResponse(struct soap *soap, _Xdmsdm__QueryVersionInfoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryVersionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryVersionInfoResponse * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryVersionInfoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryVersionInfoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryVersionInfoResponse);
		if (size)
			*size = sizeof(_Xdmsdm__QueryVersionInfoResponse);
		((_Xdmsdm__QueryVersionInfoResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryVersionInfoResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryVersionInfoResponse);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryVersionInfoResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryVersionInfoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryVersionInfoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryVersionInfoResponse %p -> %p\n", q, p));
	*(_Xdmsdm__QueryVersionInfoResponse*)p = *(_Xdmsdm__QueryVersionInfoResponse*)q;
}

void _Xdmsdm__QueryVersionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _Xdmsdm__QueryVersionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _Xdmsdm__QueryVersionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__Xdmsdm__QueryVersionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__Xdmsdm__QueryVersionInfo(struct soap *soap, const char *tag, int id, const _Xdmsdm__QueryVersionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_Xdmsdm__QueryVersionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__Xdmsdm__QueryVersionInfo(soap, tag, this, type);
}

SOAP_FMAC3 _Xdmsdm__QueryVersionInfo * SOAP_FMAC4 soap_in__Xdmsdm__QueryVersionInfo(struct soap *soap, const char *tag, _Xdmsdm__QueryVersionInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_Xdmsdm__QueryVersionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo, sizeof(_Xdmsdm__QueryVersionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_Xdmsdm__QueryVersionInfo *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_Xdmsdm__QueryVersionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo, 0, sizeof(_Xdmsdm__QueryVersionInfo), 0, soap_copy__Xdmsdm__QueryVersionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _Xdmsdm__QueryVersionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:QueryVersionInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_Xdmsdm__QueryVersionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__Xdmsdm__QueryVersionInfo(soap, this, tag, type);
}

SOAP_FMAC3 _Xdmsdm__QueryVersionInfo * SOAP_FMAC4 soap_get__Xdmsdm__QueryVersionInfo(struct soap *soap, _Xdmsdm__QueryVersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in__Xdmsdm__QueryVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _Xdmsdm__QueryVersionInfo * SOAP_FMAC2 soap_instantiate__Xdmsdm__QueryVersionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__Xdmsdm__QueryVersionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryVersionInfo);
		if (size)
			*size = sizeof(_Xdmsdm__QueryVersionInfo);
		((_Xdmsdm__QueryVersionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(_Xdmsdm__QueryVersionInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_Xdmsdm__QueryVersionInfo);
		for (int i = 0; i < n; i++)
			((_Xdmsdm__QueryVersionInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_Xdmsdm__QueryVersionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__Xdmsdm__QueryVersionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _Xdmsdm__QueryVersionInfo %p -> %p\n", q, p));
	*(_Xdmsdm__QueryVersionInfo*)p = *(_Xdmsdm__QueryVersionInfo*)q;
}

void Xdmsdm__MonthReportBusFreqArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Xdmsdm__MonthReportBusFreqArray::__sizeitem = 0;
	this->Xdmsdm__MonthReportBusFreqArray::item = NULL;
	/* transient soap skipped */
}

void Xdmsdm__MonthReportBusFreqArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->Xdmsdm__MonthReportBusFreqArray::item)
	{	int i;
		for (i = 0; i < this->Xdmsdm__MonthReportBusFreqArray::__sizeitem; i++)
		{
			soap_serialize_PointerToXdmsdm__MonthReportBusFreq(soap, this->Xdmsdm__MonthReportBusFreqArray::item + i);
		}
	}
	/* transient soap skipped */
}

int Xdmsdm__MonthReportBusFreqArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__MonthReportBusFreqArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__MonthReportBusFreqArray(struct soap *soap, const char *tag, int id, const Xdmsdm__MonthReportBusFreqArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray), type))
		return soap->error;
	if (a->Xdmsdm__MonthReportBusFreqArray::item)
	{	int i;
		for (i = 0; i < a->Xdmsdm__MonthReportBusFreqArray::__sizeitem; i++)
			if (soap_out_PointerToXdmsdm__MonthReportBusFreq(soap, "item", -1, a->Xdmsdm__MonthReportBusFreqArray::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__MonthReportBusFreqArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__MonthReportBusFreqArray(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportBusFreqArray * SOAP_FMAC4 soap_in_Xdmsdm__MonthReportBusFreqArray(struct soap *soap, const char *tag, Xdmsdm__MonthReportBusFreqArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__MonthReportBusFreqArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray, sizeof(Xdmsdm__MonthReportBusFreqArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__MonthReportBusFreqArray *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->Xdmsdm__MonthReportBusFreqArray::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->Xdmsdm__MonthReportBusFreqArray::item = (Xdmsdm__MonthReportBusFreq **)soap_push_block(soap, soap_blist_item1, sizeof(Xdmsdm__MonthReportBusFreq *));
					if (a->Xdmsdm__MonthReportBusFreqArray::item == NULL)
						return NULL;
					*a->Xdmsdm__MonthReportBusFreqArray::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToXdmsdm__MonthReportBusFreq(soap, "item", a->Xdmsdm__MonthReportBusFreqArray::item, "Xdmsdm:MonthReportBusFreq"))
				{	a->Xdmsdm__MonthReportBusFreqArray::__sizeitem++;
					a->Xdmsdm__MonthReportBusFreqArray::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Xdmsdm__MonthReportBusFreqArray::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->Xdmsdm__MonthReportBusFreqArray::__sizeitem)
			a->Xdmsdm__MonthReportBusFreqArray::item = (Xdmsdm__MonthReportBusFreq **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->Xdmsdm__MonthReportBusFreqArray::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__MonthReportBusFreqArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray, 0, sizeof(Xdmsdm__MonthReportBusFreqArray), 0, soap_copy_Xdmsdm__MonthReportBusFreqArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int Xdmsdm__MonthReportBusFreqArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:MonthReportBusFreqArray", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__MonthReportBusFreqArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__MonthReportBusFreqArray(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportBusFreqArray * SOAP_FMAC4 soap_get_Xdmsdm__MonthReportBusFreqArray(struct soap *soap, Xdmsdm__MonthReportBusFreqArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__MonthReportBusFreqArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__MonthReportBusFreqArray * SOAP_FMAC2 soap_instantiate_Xdmsdm__MonthReportBusFreqArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__MonthReportBusFreqArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__MonthReportBusFreqArray);
		if (size)
			*size = sizeof(Xdmsdm__MonthReportBusFreqArray);
		((Xdmsdm__MonthReportBusFreqArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__MonthReportBusFreqArray[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__MonthReportBusFreqArray);
		for (int i = 0; i < n; i++)
			((Xdmsdm__MonthReportBusFreqArray*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__MonthReportBusFreqArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__MonthReportBusFreqArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__MonthReportBusFreqArray %p -> %p\n", q, p));
	*(Xdmsdm__MonthReportBusFreqArray*)p = *(Xdmsdm__MonthReportBusFreqArray*)q;
}

void Xdmsdm__MonthReportBusFreq::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->Xdmsdm__MonthReportBusFreq::sUID);
	soap_default_std__string(soap, &this->Xdmsdm__MonthReportBusFreq::sAreaNO);
	soap_default_int(soap, &this->Xdmsdm__MonthReportBusFreq::nDate);
	soap_default_std__string(soap, &this->Xdmsdm__MonthReportBusFreq::sName);
	soap_default_LONG64(soap, &this->Xdmsdm__MonthReportBusFreq::nMinFreq);
	soap_default_LONG64(soap, &this->Xdmsdm__MonthReportBusFreq::nMaxFreq);
	soap_default_LONG64(soap, &this->Xdmsdm__MonthReportBusFreq::nStep);
	soap_default_std__string(soap, &this->Xdmsdm__MonthReportBusFreq::sThr);
	/* transient soap skipped */
}

void Xdmsdm__MonthReportBusFreq::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->Xdmsdm__MonthReportBusFreq::sUID);
	soap_serialize_std__string(soap, &this->Xdmsdm__MonthReportBusFreq::sAreaNO);
	soap_serialize_std__string(soap, &this->Xdmsdm__MonthReportBusFreq::sName);
	soap_serialize_std__string(soap, &this->Xdmsdm__MonthReportBusFreq::sThr);
	/* transient soap skipped */
}

int Xdmsdm__MonthReportBusFreq::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__MonthReportBusFreq(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__MonthReportBusFreq(struct soap *soap, const char *tag, int id, const Xdmsdm__MonthReportBusFreq *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq), type))
		return soap->error;
	if (soap_out_std__string(soap, "sUID", -1, &(a->Xdmsdm__MonthReportBusFreq::sUID), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sAreaNO", -1, &(a->Xdmsdm__MonthReportBusFreq::sAreaNO), ""))
		return soap->error;
	if (soap_out_int(soap, "nDate", -1, &(a->Xdmsdm__MonthReportBusFreq::nDate), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sName", -1, &(a->Xdmsdm__MonthReportBusFreq::sName), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "nMinFreq", -1, &(a->Xdmsdm__MonthReportBusFreq::nMinFreq), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "nMaxFreq", -1, &(a->Xdmsdm__MonthReportBusFreq::nMaxFreq), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "nStep", -1, &(a->Xdmsdm__MonthReportBusFreq::nStep), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sThr", -1, &(a->Xdmsdm__MonthReportBusFreq::sThr), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__MonthReportBusFreq::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__MonthReportBusFreq(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportBusFreq * SOAP_FMAC4 soap_in_Xdmsdm__MonthReportBusFreq(struct soap *soap, const char *tag, Xdmsdm__MonthReportBusFreq *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__MonthReportBusFreq *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq, sizeof(Xdmsdm__MonthReportBusFreq), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__MonthReportBusFreq *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sUID1 = 1;
	size_t soap_flag_sAreaNO1 = 1;
	size_t soap_flag_nDate1 = 1;
	size_t soap_flag_sName1 = 1;
	size_t soap_flag_nMinFreq1 = 1;
	size_t soap_flag_nMaxFreq1 = 1;
	size_t soap_flag_nStep1 = 1;
	size_t soap_flag_sThr1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sUID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sUID", &(a->Xdmsdm__MonthReportBusFreq::sUID), "xsd:string"))
				{	soap_flag_sUID1--;
					continue;
				}
			if (soap_flag_sAreaNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sAreaNO", &(a->Xdmsdm__MonthReportBusFreq::sAreaNO), "xsd:string"))
				{	soap_flag_sAreaNO1--;
					continue;
				}
			if (soap_flag_nDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nDate", &(a->Xdmsdm__MonthReportBusFreq::nDate), "xsd:int"))
				{	soap_flag_nDate1--;
					continue;
				}
			if (soap_flag_sName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sName", &(a->Xdmsdm__MonthReportBusFreq::sName), "xsd:string"))
				{	soap_flag_sName1--;
					continue;
				}
			if (soap_flag_nMinFreq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "nMinFreq", &(a->Xdmsdm__MonthReportBusFreq::nMinFreq), "xsd:long"))
				{	soap_flag_nMinFreq1--;
					continue;
				}
			if (soap_flag_nMaxFreq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "nMaxFreq", &(a->Xdmsdm__MonthReportBusFreq::nMaxFreq), "xsd:long"))
				{	soap_flag_nMaxFreq1--;
					continue;
				}
			if (soap_flag_nStep1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "nStep", &(a->Xdmsdm__MonthReportBusFreq::nStep), "xsd:long"))
				{	soap_flag_nStep1--;
					continue;
				}
			if (soap_flag_sThr1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sThr", &(a->Xdmsdm__MonthReportBusFreq::sThr), "xsd:string"))
				{	soap_flag_sThr1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__MonthReportBusFreq *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq, 0, sizeof(Xdmsdm__MonthReportBusFreq), 0, soap_copy_Xdmsdm__MonthReportBusFreq);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sUID1 > 0 || soap_flag_sAreaNO1 > 0 || soap_flag_nDate1 > 0 || soap_flag_sName1 > 0 || soap_flag_nMinFreq1 > 0 || soap_flag_nMaxFreq1 > 0 || soap_flag_nStep1 > 0 || soap_flag_sThr1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int Xdmsdm__MonthReportBusFreq::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:MonthReportBusFreq", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__MonthReportBusFreq::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__MonthReportBusFreq(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportBusFreq * SOAP_FMAC4 soap_get_Xdmsdm__MonthReportBusFreq(struct soap *soap, Xdmsdm__MonthReportBusFreq *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__MonthReportBusFreq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__MonthReportBusFreq * SOAP_FMAC2 soap_instantiate_Xdmsdm__MonthReportBusFreq(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__MonthReportBusFreq(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__MonthReportBusFreq);
		if (size)
			*size = sizeof(Xdmsdm__MonthReportBusFreq);
		((Xdmsdm__MonthReportBusFreq*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__MonthReportBusFreq[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__MonthReportBusFreq);
		for (int i = 0; i < n; i++)
			((Xdmsdm__MonthReportBusFreq*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__MonthReportBusFreq*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__MonthReportBusFreq(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__MonthReportBusFreq %p -> %p\n", q, p));
	*(Xdmsdm__MonthReportBusFreq*)p = *(Xdmsdm__MonthReportBusFreq*)q;
}

void Xdmsdm__MonthReportWorkPlanArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Xdmsdm__MonthReportWorkPlanArray::__sizeitem = 0;
	this->Xdmsdm__MonthReportWorkPlanArray::item = NULL;
	/* transient soap skipped */
}

void Xdmsdm__MonthReportWorkPlanArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->Xdmsdm__MonthReportWorkPlanArray::item)
	{	int i;
		for (i = 0; i < this->Xdmsdm__MonthReportWorkPlanArray::__sizeitem; i++)
		{
			soap_serialize_PointerToXdmsdm__MonthReportWorkPlan(soap, this->Xdmsdm__MonthReportWorkPlanArray::item + i);
		}
	}
	/* transient soap skipped */
}

int Xdmsdm__MonthReportWorkPlanArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__MonthReportWorkPlanArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__MonthReportWorkPlanArray(struct soap *soap, const char *tag, int id, const Xdmsdm__MonthReportWorkPlanArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray), type))
		return soap->error;
	if (a->Xdmsdm__MonthReportWorkPlanArray::item)
	{	int i;
		for (i = 0; i < a->Xdmsdm__MonthReportWorkPlanArray::__sizeitem; i++)
			if (soap_out_PointerToXdmsdm__MonthReportWorkPlan(soap, "item", -1, a->Xdmsdm__MonthReportWorkPlanArray::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__MonthReportWorkPlanArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__MonthReportWorkPlanArray(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportWorkPlanArray * SOAP_FMAC4 soap_in_Xdmsdm__MonthReportWorkPlanArray(struct soap *soap, const char *tag, Xdmsdm__MonthReportWorkPlanArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__MonthReportWorkPlanArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray, sizeof(Xdmsdm__MonthReportWorkPlanArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__MonthReportWorkPlanArray *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->Xdmsdm__MonthReportWorkPlanArray::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->Xdmsdm__MonthReportWorkPlanArray::item = (Xdmsdm__MonthReportWorkPlan **)soap_push_block(soap, soap_blist_item1, sizeof(Xdmsdm__MonthReportWorkPlan *));
					if (a->Xdmsdm__MonthReportWorkPlanArray::item == NULL)
						return NULL;
					*a->Xdmsdm__MonthReportWorkPlanArray::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToXdmsdm__MonthReportWorkPlan(soap, "item", a->Xdmsdm__MonthReportWorkPlanArray::item, "Xdmsdm:MonthReportWorkPlan"))
				{	a->Xdmsdm__MonthReportWorkPlanArray::__sizeitem++;
					a->Xdmsdm__MonthReportWorkPlanArray::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Xdmsdm__MonthReportWorkPlanArray::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->Xdmsdm__MonthReportWorkPlanArray::__sizeitem)
			a->Xdmsdm__MonthReportWorkPlanArray::item = (Xdmsdm__MonthReportWorkPlan **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->Xdmsdm__MonthReportWorkPlanArray::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__MonthReportWorkPlanArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray, 0, sizeof(Xdmsdm__MonthReportWorkPlanArray), 0, soap_copy_Xdmsdm__MonthReportWorkPlanArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int Xdmsdm__MonthReportWorkPlanArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:MonthReportWorkPlanArray", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__MonthReportWorkPlanArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__MonthReportWorkPlanArray(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportWorkPlanArray * SOAP_FMAC4 soap_get_Xdmsdm__MonthReportWorkPlanArray(struct soap *soap, Xdmsdm__MonthReportWorkPlanArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__MonthReportWorkPlanArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__MonthReportWorkPlanArray * SOAP_FMAC2 soap_instantiate_Xdmsdm__MonthReportWorkPlanArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__MonthReportWorkPlanArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__MonthReportWorkPlanArray);
		if (size)
			*size = sizeof(Xdmsdm__MonthReportWorkPlanArray);
		((Xdmsdm__MonthReportWorkPlanArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__MonthReportWorkPlanArray[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__MonthReportWorkPlanArray);
		for (int i = 0; i < n; i++)
			((Xdmsdm__MonthReportWorkPlanArray*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__MonthReportWorkPlanArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__MonthReportWorkPlanArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__MonthReportWorkPlanArray %p -> %p\n", q, p));
	*(Xdmsdm__MonthReportWorkPlanArray*)p = *(Xdmsdm__MonthReportWorkPlanArray*)q;
}

void Xdmsdm__MonthReportWorkPlan::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sUID);
	soap_default_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sAreaNO);
	soap_default_int(soap, &this->Xdmsdm__MonthReportWorkPlan::nDate);
	soap_default_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sWork);
	soap_default_int(soap, &this->Xdmsdm__MonthReportWorkPlan::nMonType);
	soap_default_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sRemark);
	soap_default_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sMaker);
	soap_default_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sChecker);
	/* transient soap skipped */
}

void Xdmsdm__MonthReportWorkPlan::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sUID);
	soap_serialize_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sAreaNO);
	soap_serialize_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sWork);
	soap_serialize_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sRemark);
	soap_serialize_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sMaker);
	soap_serialize_std__string(soap, &this->Xdmsdm__MonthReportWorkPlan::sChecker);
	/* transient soap skipped */
}

int Xdmsdm__MonthReportWorkPlan::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__MonthReportWorkPlan(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__MonthReportWorkPlan(struct soap *soap, const char *tag, int id, const Xdmsdm__MonthReportWorkPlan *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan), type))
		return soap->error;
	if (soap_out_std__string(soap, "sUID", -1, &(a->Xdmsdm__MonthReportWorkPlan::sUID), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sAreaNO", -1, &(a->Xdmsdm__MonthReportWorkPlan::sAreaNO), ""))
		return soap->error;
	if (soap_out_int(soap, "nDate", -1, &(a->Xdmsdm__MonthReportWorkPlan::nDate), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sWork", -1, &(a->Xdmsdm__MonthReportWorkPlan::sWork), ""))
		return soap->error;
	if (soap_out_int(soap, "nMonType", -1, &(a->Xdmsdm__MonthReportWorkPlan::nMonType), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sRemark", -1, &(a->Xdmsdm__MonthReportWorkPlan::sRemark), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sMaker", -1, &(a->Xdmsdm__MonthReportWorkPlan::sMaker), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sChecker", -1, &(a->Xdmsdm__MonthReportWorkPlan::sChecker), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__MonthReportWorkPlan::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__MonthReportWorkPlan(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportWorkPlan * SOAP_FMAC4 soap_in_Xdmsdm__MonthReportWorkPlan(struct soap *soap, const char *tag, Xdmsdm__MonthReportWorkPlan *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__MonthReportWorkPlan *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan, sizeof(Xdmsdm__MonthReportWorkPlan), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__MonthReportWorkPlan *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sUID1 = 1;
	size_t soap_flag_sAreaNO1 = 1;
	size_t soap_flag_nDate1 = 1;
	size_t soap_flag_sWork1 = 1;
	size_t soap_flag_nMonType1 = 1;
	size_t soap_flag_sRemark1 = 1;
	size_t soap_flag_sMaker1 = 1;
	size_t soap_flag_sChecker1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sUID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sUID", &(a->Xdmsdm__MonthReportWorkPlan::sUID), "xsd:string"))
				{	soap_flag_sUID1--;
					continue;
				}
			if (soap_flag_sAreaNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sAreaNO", &(a->Xdmsdm__MonthReportWorkPlan::sAreaNO), "xsd:string"))
				{	soap_flag_sAreaNO1--;
					continue;
				}
			if (soap_flag_nDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nDate", &(a->Xdmsdm__MonthReportWorkPlan::nDate), "xsd:int"))
				{	soap_flag_nDate1--;
					continue;
				}
			if (soap_flag_sWork1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sWork", &(a->Xdmsdm__MonthReportWorkPlan::sWork), "xsd:string"))
				{	soap_flag_sWork1--;
					continue;
				}
			if (soap_flag_nMonType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nMonType", &(a->Xdmsdm__MonthReportWorkPlan::nMonType), "xsd:int"))
				{	soap_flag_nMonType1--;
					continue;
				}
			if (soap_flag_sRemark1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sRemark", &(a->Xdmsdm__MonthReportWorkPlan::sRemark), "xsd:string"))
				{	soap_flag_sRemark1--;
					continue;
				}
			if (soap_flag_sMaker1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sMaker", &(a->Xdmsdm__MonthReportWorkPlan::sMaker), "xsd:string"))
				{	soap_flag_sMaker1--;
					continue;
				}
			if (soap_flag_sChecker1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sChecker", &(a->Xdmsdm__MonthReportWorkPlan::sChecker), "xsd:string"))
				{	soap_flag_sChecker1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__MonthReportWorkPlan *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan, 0, sizeof(Xdmsdm__MonthReportWorkPlan), 0, soap_copy_Xdmsdm__MonthReportWorkPlan);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sUID1 > 0 || soap_flag_sAreaNO1 > 0 || soap_flag_nDate1 > 0 || soap_flag_sWork1 > 0 || soap_flag_nMonType1 > 0 || soap_flag_sRemark1 > 0 || soap_flag_sMaker1 > 0 || soap_flag_sChecker1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int Xdmsdm__MonthReportWorkPlan::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:MonthReportWorkPlan", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__MonthReportWorkPlan::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__MonthReportWorkPlan(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportWorkPlan * SOAP_FMAC4 soap_get_Xdmsdm__MonthReportWorkPlan(struct soap *soap, Xdmsdm__MonthReportWorkPlan *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__MonthReportWorkPlan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__MonthReportWorkPlan * SOAP_FMAC2 soap_instantiate_Xdmsdm__MonthReportWorkPlan(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__MonthReportWorkPlan(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__MonthReportWorkPlan);
		if (size)
			*size = sizeof(Xdmsdm__MonthReportWorkPlan);
		((Xdmsdm__MonthReportWorkPlan*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__MonthReportWorkPlan[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__MonthReportWorkPlan);
		for (int i = 0; i < n; i++)
			((Xdmsdm__MonthReportWorkPlan*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__MonthReportWorkPlan*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__MonthReportWorkPlan(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__MonthReportWorkPlan %p -> %p\n", q, p));
	*(Xdmsdm__MonthReportWorkPlan*)p = *(Xdmsdm__MonthReportWorkPlan*)q;
}

void Xdmsdm__LicenseFuncArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Xdmsdm__LicenseFuncArray::__sizeitem = 0;
	this->Xdmsdm__LicenseFuncArray::item = NULL;
	/* transient soap skipped */
}

void Xdmsdm__LicenseFuncArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->Xdmsdm__LicenseFuncArray::item)
	{	int i;
		for (i = 0; i < this->Xdmsdm__LicenseFuncArray::__sizeitem; i++)
		{
			soap_serialize_PointerToXdmsdm__LicenseFunc(soap, this->Xdmsdm__LicenseFuncArray::item + i);
		}
	}
	/* transient soap skipped */
}

int Xdmsdm__LicenseFuncArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__LicenseFuncArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__LicenseFuncArray(struct soap *soap, const char *tag, int id, const Xdmsdm__LicenseFuncArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray), type))
		return soap->error;
	if (a->Xdmsdm__LicenseFuncArray::item)
	{	int i;
		for (i = 0; i < a->Xdmsdm__LicenseFuncArray::__sizeitem; i++)
			if (soap_out_PointerToXdmsdm__LicenseFunc(soap, "item", -1, a->Xdmsdm__LicenseFuncArray::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__LicenseFuncArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__LicenseFuncArray(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__LicenseFuncArray * SOAP_FMAC4 soap_in_Xdmsdm__LicenseFuncArray(struct soap *soap, const char *tag, Xdmsdm__LicenseFuncArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__LicenseFuncArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray, sizeof(Xdmsdm__LicenseFuncArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__LicenseFuncArray *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->Xdmsdm__LicenseFuncArray::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->Xdmsdm__LicenseFuncArray::item = (Xdmsdm__LicenseFunc **)soap_push_block(soap, soap_blist_item1, sizeof(Xdmsdm__LicenseFunc *));
					if (a->Xdmsdm__LicenseFuncArray::item == NULL)
						return NULL;
					*a->Xdmsdm__LicenseFuncArray::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToXdmsdm__LicenseFunc(soap, "item", a->Xdmsdm__LicenseFuncArray::item, "Xdmsdm:LicenseFunc"))
				{	a->Xdmsdm__LicenseFuncArray::__sizeitem++;
					a->Xdmsdm__LicenseFuncArray::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Xdmsdm__LicenseFuncArray::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->Xdmsdm__LicenseFuncArray::__sizeitem)
			a->Xdmsdm__LicenseFuncArray::item = (Xdmsdm__LicenseFunc **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->Xdmsdm__LicenseFuncArray::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__LicenseFuncArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray, 0, sizeof(Xdmsdm__LicenseFuncArray), 0, soap_copy_Xdmsdm__LicenseFuncArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int Xdmsdm__LicenseFuncArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:LicenseFuncArray", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__LicenseFuncArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__LicenseFuncArray(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__LicenseFuncArray * SOAP_FMAC4 soap_get_Xdmsdm__LicenseFuncArray(struct soap *soap, Xdmsdm__LicenseFuncArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__LicenseFuncArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__LicenseFuncArray * SOAP_FMAC2 soap_instantiate_Xdmsdm__LicenseFuncArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__LicenseFuncArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__LicenseFuncArray);
		if (size)
			*size = sizeof(Xdmsdm__LicenseFuncArray);
		((Xdmsdm__LicenseFuncArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__LicenseFuncArray[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__LicenseFuncArray);
		for (int i = 0; i < n; i++)
			((Xdmsdm__LicenseFuncArray*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__LicenseFuncArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__LicenseFuncArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__LicenseFuncArray %p -> %p\n", q, p));
	*(Xdmsdm__LicenseFuncArray*)p = *(Xdmsdm__LicenseFuncArray*)q;
}

void Xdmsdm__LicenseFunc::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->Xdmsdm__LicenseFunc::sFuncNO);
	/* transient soap skipped */
}

void Xdmsdm__LicenseFunc::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->Xdmsdm__LicenseFunc::sFuncNO);
	/* transient soap skipped */
}

int Xdmsdm__LicenseFunc::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__LicenseFunc(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__LicenseFunc(struct soap *soap, const char *tag, int id, const Xdmsdm__LicenseFunc *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc), type))
		return soap->error;
	if (soap_out_std__string(soap, "sFuncNO", -1, &(a->Xdmsdm__LicenseFunc::sFuncNO), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__LicenseFunc::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__LicenseFunc(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__LicenseFunc * SOAP_FMAC4 soap_in_Xdmsdm__LicenseFunc(struct soap *soap, const char *tag, Xdmsdm__LicenseFunc *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__LicenseFunc *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc, sizeof(Xdmsdm__LicenseFunc), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__LicenseFunc *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sFuncNO1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sFuncNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sFuncNO", &(a->Xdmsdm__LicenseFunc::sFuncNO), "xsd:string"))
				{	soap_flag_sFuncNO1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__LicenseFunc *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc, 0, sizeof(Xdmsdm__LicenseFunc), 0, soap_copy_Xdmsdm__LicenseFunc);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sFuncNO1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int Xdmsdm__LicenseFunc::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:LicenseFunc", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__LicenseFunc::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__LicenseFunc(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__LicenseFunc * SOAP_FMAC4 soap_get_Xdmsdm__LicenseFunc(struct soap *soap, Xdmsdm__LicenseFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__LicenseFunc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__LicenseFunc * SOAP_FMAC2 soap_instantiate_Xdmsdm__LicenseFunc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__LicenseFunc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__LicenseFunc);
		if (size)
			*size = sizeof(Xdmsdm__LicenseFunc);
		((Xdmsdm__LicenseFunc*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__LicenseFunc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__LicenseFunc);
		for (int i = 0; i < n; i++)
			((Xdmsdm__LicenseFunc*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__LicenseFunc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__LicenseFunc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__LicenseFunc %p -> %p\n", q, p));
	*(Xdmsdm__LicenseFunc*)p = *(Xdmsdm__LicenseFunc*)q;
}

void Xdmsdm__UserInfoArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Xdmsdm__UserInfoArray::__sizeitem = 0;
	this->Xdmsdm__UserInfoArray::item = NULL;
	/* transient soap skipped */
}

void Xdmsdm__UserInfoArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->Xdmsdm__UserInfoArray::item)
	{	int i;
		for (i = 0; i < this->Xdmsdm__UserInfoArray::__sizeitem; i++)
		{
			soap_serialize_PointerToXdmsdm__UserInfo(soap, this->Xdmsdm__UserInfoArray::item + i);
		}
	}
	/* transient soap skipped */
}

int Xdmsdm__UserInfoArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__UserInfoArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__UserInfoArray(struct soap *soap, const char *tag, int id, const Xdmsdm__UserInfoArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray), type))
		return soap->error;
	if (a->Xdmsdm__UserInfoArray::item)
	{	int i;
		for (i = 0; i < a->Xdmsdm__UserInfoArray::__sizeitem; i++)
			if (soap_out_PointerToXdmsdm__UserInfo(soap, "item", -1, a->Xdmsdm__UserInfoArray::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__UserInfoArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__UserInfoArray(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__UserInfoArray * SOAP_FMAC4 soap_in_Xdmsdm__UserInfoArray(struct soap *soap, const char *tag, Xdmsdm__UserInfoArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__UserInfoArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray, sizeof(Xdmsdm__UserInfoArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__UserInfoArray *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->Xdmsdm__UserInfoArray::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->Xdmsdm__UserInfoArray::item = (Xdmsdm__UserInfo **)soap_push_block(soap, soap_blist_item1, sizeof(Xdmsdm__UserInfo *));
					if (a->Xdmsdm__UserInfoArray::item == NULL)
						return NULL;
					*a->Xdmsdm__UserInfoArray::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToXdmsdm__UserInfo(soap, "item", a->Xdmsdm__UserInfoArray::item, "Xdmsdm:UserInfo"))
				{	a->Xdmsdm__UserInfoArray::__sizeitem++;
					a->Xdmsdm__UserInfoArray::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Xdmsdm__UserInfoArray::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->Xdmsdm__UserInfoArray::__sizeitem)
			a->Xdmsdm__UserInfoArray::item = (Xdmsdm__UserInfo **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->Xdmsdm__UserInfoArray::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__UserInfoArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray, 0, sizeof(Xdmsdm__UserInfoArray), 0, soap_copy_Xdmsdm__UserInfoArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int Xdmsdm__UserInfoArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:UserInfoArray", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__UserInfoArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__UserInfoArray(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__UserInfoArray * SOAP_FMAC4 soap_get_Xdmsdm__UserInfoArray(struct soap *soap, Xdmsdm__UserInfoArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__UserInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__UserInfoArray * SOAP_FMAC2 soap_instantiate_Xdmsdm__UserInfoArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__UserInfoArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__UserInfoArray);
		if (size)
			*size = sizeof(Xdmsdm__UserInfoArray);
		((Xdmsdm__UserInfoArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__UserInfoArray[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__UserInfoArray);
		for (int i = 0; i < n; i++)
			((Xdmsdm__UserInfoArray*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__UserInfoArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__UserInfoArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__UserInfoArray %p -> %p\n", q, p));
	*(Xdmsdm__UserInfoArray*)p = *(Xdmsdm__UserInfoArray*)q;
}

void Xdmsdm__UserInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->Xdmsdm__UserInfo::sName);
	soap_default_std__string(soap, &this->Xdmsdm__UserInfo::sID);
	soap_default_std__string(soap, &this->Xdmsdm__UserInfo::sAppleID);
	soap_default_std__string(soap, &this->Xdmsdm__UserInfo::sOther);
	/* transient soap skipped */
}

void Xdmsdm__UserInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->Xdmsdm__UserInfo::sName);
	soap_serialize_std__string(soap, &this->Xdmsdm__UserInfo::sID);
	soap_serialize_std__string(soap, &this->Xdmsdm__UserInfo::sAppleID);
	soap_serialize_std__string(soap, &this->Xdmsdm__UserInfo::sOther);
	/* transient soap skipped */
}

int Xdmsdm__UserInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__UserInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__UserInfo(struct soap *soap, const char *tag, int id, const Xdmsdm__UserInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sName", -1, &(a->Xdmsdm__UserInfo::sName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sID", -1, &(a->Xdmsdm__UserInfo::sID), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sAppleID", -1, &(a->Xdmsdm__UserInfo::sAppleID), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sOther", -1, &(a->Xdmsdm__UserInfo::sOther), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__UserInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__UserInfo(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__UserInfo * SOAP_FMAC4 soap_in_Xdmsdm__UserInfo(struct soap *soap, const char *tag, Xdmsdm__UserInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__UserInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo, sizeof(Xdmsdm__UserInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__UserInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sName1 = 1;
	size_t soap_flag_sID1 = 1;
	size_t soap_flag_sAppleID1 = 1;
	size_t soap_flag_sOther1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sName", &(a->Xdmsdm__UserInfo::sName), "xsd:string"))
				{	soap_flag_sName1--;
					continue;
				}
			if (soap_flag_sID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sID", &(a->Xdmsdm__UserInfo::sID), "xsd:string"))
				{	soap_flag_sID1--;
					continue;
				}
			if (soap_flag_sAppleID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sAppleID", &(a->Xdmsdm__UserInfo::sAppleID), "xsd:string"))
				{	soap_flag_sAppleID1--;
					continue;
				}
			if (soap_flag_sOther1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sOther", &(a->Xdmsdm__UserInfo::sOther), "xsd:string"))
				{	soap_flag_sOther1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__UserInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo, 0, sizeof(Xdmsdm__UserInfo), 0, soap_copy_Xdmsdm__UserInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sName1 > 0 || soap_flag_sID1 > 0 || soap_flag_sAppleID1 > 0 || soap_flag_sOther1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int Xdmsdm__UserInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:UserInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__UserInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__UserInfo(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__UserInfo * SOAP_FMAC4 soap_get_Xdmsdm__UserInfo(struct soap *soap, Xdmsdm__UserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__UserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__UserInfo * SOAP_FMAC2 soap_instantiate_Xdmsdm__UserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__UserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__UserInfo);
		if (size)
			*size = sizeof(Xdmsdm__UserInfo);
		((Xdmsdm__UserInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__UserInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__UserInfo);
		for (int i = 0; i < n; i++)
			((Xdmsdm__UserInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__UserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__UserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__UserInfo %p -> %p\n", q, p));
	*(Xdmsdm__UserInfo*)p = *(Xdmsdm__UserInfo*)q;
}

void Xdmsdm__WebServiceInfoArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Xdmsdm__WebServiceInfoArray::__sizeitem = 0;
	this->Xdmsdm__WebServiceInfoArray::item = NULL;
	/* transient soap skipped */
}

void Xdmsdm__WebServiceInfoArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->Xdmsdm__WebServiceInfoArray::item)
	{	int i;
		for (i = 0; i < this->Xdmsdm__WebServiceInfoArray::__sizeitem; i++)
		{
			soap_serialize_PointerToXdmsdm__WebServiceInfo(soap, this->Xdmsdm__WebServiceInfoArray::item + i);
		}
	}
	/* transient soap skipped */
}

int Xdmsdm__WebServiceInfoArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__WebServiceInfoArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__WebServiceInfoArray(struct soap *soap, const char *tag, int id, const Xdmsdm__WebServiceInfoArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray), type))
		return soap->error;
	if (a->Xdmsdm__WebServiceInfoArray::item)
	{	int i;
		for (i = 0; i < a->Xdmsdm__WebServiceInfoArray::__sizeitem; i++)
			if (soap_out_PointerToXdmsdm__WebServiceInfo(soap, "item", -1, a->Xdmsdm__WebServiceInfoArray::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__WebServiceInfoArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__WebServiceInfoArray(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__WebServiceInfoArray * SOAP_FMAC4 soap_in_Xdmsdm__WebServiceInfoArray(struct soap *soap, const char *tag, Xdmsdm__WebServiceInfoArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__WebServiceInfoArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray, sizeof(Xdmsdm__WebServiceInfoArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__WebServiceInfoArray *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->Xdmsdm__WebServiceInfoArray::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->Xdmsdm__WebServiceInfoArray::item = (Xdmsdm__WebServiceInfo **)soap_push_block(soap, soap_blist_item1, sizeof(Xdmsdm__WebServiceInfo *));
					if (a->Xdmsdm__WebServiceInfoArray::item == NULL)
						return NULL;
					*a->Xdmsdm__WebServiceInfoArray::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToXdmsdm__WebServiceInfo(soap, "item", a->Xdmsdm__WebServiceInfoArray::item, "Xdmsdm:WebServiceInfo"))
				{	a->Xdmsdm__WebServiceInfoArray::__sizeitem++;
					a->Xdmsdm__WebServiceInfoArray::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Xdmsdm__WebServiceInfoArray::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->Xdmsdm__WebServiceInfoArray::__sizeitem)
			a->Xdmsdm__WebServiceInfoArray::item = (Xdmsdm__WebServiceInfo **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->Xdmsdm__WebServiceInfoArray::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__WebServiceInfoArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray, 0, sizeof(Xdmsdm__WebServiceInfoArray), 0, soap_copy_Xdmsdm__WebServiceInfoArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int Xdmsdm__WebServiceInfoArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:WebServiceInfoArray", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__WebServiceInfoArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__WebServiceInfoArray(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__WebServiceInfoArray * SOAP_FMAC4 soap_get_Xdmsdm__WebServiceInfoArray(struct soap *soap, Xdmsdm__WebServiceInfoArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__WebServiceInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__WebServiceInfoArray * SOAP_FMAC2 soap_instantiate_Xdmsdm__WebServiceInfoArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__WebServiceInfoArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__WebServiceInfoArray);
		if (size)
			*size = sizeof(Xdmsdm__WebServiceInfoArray);
		((Xdmsdm__WebServiceInfoArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__WebServiceInfoArray[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__WebServiceInfoArray);
		for (int i = 0; i < n; i++)
			((Xdmsdm__WebServiceInfoArray*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__WebServiceInfoArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__WebServiceInfoArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__WebServiceInfoArray %p -> %p\n", q, p));
	*(Xdmsdm__WebServiceInfoArray*)p = *(Xdmsdm__WebServiceInfoArray*)q;
}

void Xdmsdm__WebServiceInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->Xdmsdm__WebServiceInfo::sName);
	soap_default_int(soap, &this->Xdmsdm__WebServiceInfo::nSubModeID);
	soap_default_std__string(soap, &this->Xdmsdm__WebServiceInfo::sLocation);
	soap_default_short(soap, &this->Xdmsdm__WebServiceInfo::nPort);
	/* transient soap skipped */
}

void Xdmsdm__WebServiceInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->Xdmsdm__WebServiceInfo::sName);
	soap_serialize_std__string(soap, &this->Xdmsdm__WebServiceInfo::sLocation);
	/* transient soap skipped */
}

int Xdmsdm__WebServiceInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__WebServiceInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__WebServiceInfo(struct soap *soap, const char *tag, int id, const Xdmsdm__WebServiceInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sName", -1, &(a->Xdmsdm__WebServiceInfo::sName), ""))
		return soap->error;
	if (soap_out_int(soap, "nSubModeID", -1, &(a->Xdmsdm__WebServiceInfo::nSubModeID), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sLocation", -1, &(a->Xdmsdm__WebServiceInfo::sLocation), ""))
		return soap->error;
	if (soap_out_short(soap, "nPort", -1, &(a->Xdmsdm__WebServiceInfo::nPort), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__WebServiceInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__WebServiceInfo(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__WebServiceInfo * SOAP_FMAC4 soap_in_Xdmsdm__WebServiceInfo(struct soap *soap, const char *tag, Xdmsdm__WebServiceInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__WebServiceInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo, sizeof(Xdmsdm__WebServiceInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__WebServiceInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sName1 = 1;
	size_t soap_flag_nSubModeID1 = 1;
	size_t soap_flag_sLocation1 = 1;
	size_t soap_flag_nPort1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sName", &(a->Xdmsdm__WebServiceInfo::sName), "xsd:string"))
				{	soap_flag_sName1--;
					continue;
				}
			if (soap_flag_nSubModeID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "nSubModeID", &(a->Xdmsdm__WebServiceInfo::nSubModeID), "xsd:int"))
				{	soap_flag_nSubModeID1--;
					continue;
				}
			if (soap_flag_sLocation1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sLocation", &(a->Xdmsdm__WebServiceInfo::sLocation), "xsd:string"))
				{	soap_flag_sLocation1--;
					continue;
				}
			if (soap_flag_nPort1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "nPort", &(a->Xdmsdm__WebServiceInfo::nPort), "xsd:short"))
				{	soap_flag_nPort1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__WebServiceInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo, 0, sizeof(Xdmsdm__WebServiceInfo), 0, soap_copy_Xdmsdm__WebServiceInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sName1 > 0 || soap_flag_nSubModeID1 > 0 || soap_flag_sLocation1 > 0 || soap_flag_nPort1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int Xdmsdm__WebServiceInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:WebServiceInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__WebServiceInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__WebServiceInfo(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__WebServiceInfo * SOAP_FMAC4 soap_get_Xdmsdm__WebServiceInfo(struct soap *soap, Xdmsdm__WebServiceInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__WebServiceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__WebServiceInfo * SOAP_FMAC2 soap_instantiate_Xdmsdm__WebServiceInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__WebServiceInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__WebServiceInfo);
		if (size)
			*size = sizeof(Xdmsdm__WebServiceInfo);
		((Xdmsdm__WebServiceInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__WebServiceInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__WebServiceInfo);
		for (int i = 0; i < n; i++)
			((Xdmsdm__WebServiceInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__WebServiceInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__WebServiceInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__WebServiceInfo %p -> %p\n", q, p));
	*(Xdmsdm__WebServiceInfo*)p = *(Xdmsdm__WebServiceInfo*)q;
}

void Xdmsdm__VersionInfoArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Xdmsdm__VersionInfoArray::__sizeitem = 0;
	this->Xdmsdm__VersionInfoArray::item = NULL;
	/* transient soap skipped */
}

void Xdmsdm__VersionInfoArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->Xdmsdm__VersionInfoArray::item)
	{	int i;
		for (i = 0; i < this->Xdmsdm__VersionInfoArray::__sizeitem; i++)
		{
			soap_serialize_PointerToXdmsdm__VersionInfo(soap, this->Xdmsdm__VersionInfoArray::item + i);
		}
	}
	/* transient soap skipped */
}

int Xdmsdm__VersionInfoArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__VersionInfoArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__VersionInfoArray(struct soap *soap, const char *tag, int id, const Xdmsdm__VersionInfoArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray), type))
		return soap->error;
	if (a->Xdmsdm__VersionInfoArray::item)
	{	int i;
		for (i = 0; i < a->Xdmsdm__VersionInfoArray::__sizeitem; i++)
			if (soap_out_PointerToXdmsdm__VersionInfo(soap, "item", -1, a->Xdmsdm__VersionInfoArray::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__VersionInfoArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__VersionInfoArray(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__VersionInfoArray * SOAP_FMAC4 soap_in_Xdmsdm__VersionInfoArray(struct soap *soap, const char *tag, Xdmsdm__VersionInfoArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__VersionInfoArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray, sizeof(Xdmsdm__VersionInfoArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__VersionInfoArray *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->Xdmsdm__VersionInfoArray::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->Xdmsdm__VersionInfoArray::item = (Xdmsdm__VersionInfo **)soap_push_block(soap, soap_blist_item1, sizeof(Xdmsdm__VersionInfo *));
					if (a->Xdmsdm__VersionInfoArray::item == NULL)
						return NULL;
					*a->Xdmsdm__VersionInfoArray::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToXdmsdm__VersionInfo(soap, "item", a->Xdmsdm__VersionInfoArray::item, "Xdmsdm:VersionInfo"))
				{	a->Xdmsdm__VersionInfoArray::__sizeitem++;
					a->Xdmsdm__VersionInfoArray::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Xdmsdm__VersionInfoArray::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->Xdmsdm__VersionInfoArray::__sizeitem)
			a->Xdmsdm__VersionInfoArray::item = (Xdmsdm__VersionInfo **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->Xdmsdm__VersionInfoArray::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__VersionInfoArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray, 0, sizeof(Xdmsdm__VersionInfoArray), 0, soap_copy_Xdmsdm__VersionInfoArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int Xdmsdm__VersionInfoArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:VersionInfoArray", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__VersionInfoArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__VersionInfoArray(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__VersionInfoArray * SOAP_FMAC4 soap_get_Xdmsdm__VersionInfoArray(struct soap *soap, Xdmsdm__VersionInfoArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__VersionInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__VersionInfoArray * SOAP_FMAC2 soap_instantiate_Xdmsdm__VersionInfoArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__VersionInfoArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__VersionInfoArray);
		if (size)
			*size = sizeof(Xdmsdm__VersionInfoArray);
		((Xdmsdm__VersionInfoArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__VersionInfoArray[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__VersionInfoArray);
		for (int i = 0; i < n; i++)
			((Xdmsdm__VersionInfoArray*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__VersionInfoArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__VersionInfoArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__VersionInfoArray %p -> %p\n", q, p));
	*(Xdmsdm__VersionInfoArray*)p = *(Xdmsdm__VersionInfoArray*)q;
}

void Xdmsdm__VersionInfo::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->Xdmsdm__VersionInfo::sName);
	soap_default_std__string(soap, &this->Xdmsdm__VersionInfo::sVersion);
	soap_default_std__string(soap, &this->Xdmsdm__VersionInfo::sDescription);
	/* transient soap skipped */
}

void Xdmsdm__VersionInfo::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->Xdmsdm__VersionInfo::sName);
	soap_serialize_std__string(soap, &this->Xdmsdm__VersionInfo::sVersion);
	soap_serialize_std__string(soap, &this->Xdmsdm__VersionInfo::sDescription);
	/* transient soap skipped */
}

int Xdmsdm__VersionInfo::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__VersionInfo(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__VersionInfo(struct soap *soap, const char *tag, int id, const Xdmsdm__VersionInfo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo), type))
		return soap->error;
	if (soap_out_std__string(soap, "sName", -1, &(a->Xdmsdm__VersionInfo::sName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sVersion", -1, &(a->Xdmsdm__VersionInfo::sVersion), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sDescription", -1, &(a->Xdmsdm__VersionInfo::sDescription), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__VersionInfo::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__VersionInfo(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__VersionInfo * SOAP_FMAC4 soap_in_Xdmsdm__VersionInfo(struct soap *soap, const char *tag, Xdmsdm__VersionInfo *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__VersionInfo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo, sizeof(Xdmsdm__VersionInfo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__VersionInfo *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sName1 = 1;
	size_t soap_flag_sVersion1 = 1;
	size_t soap_flag_sDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sName", &(a->Xdmsdm__VersionInfo::sName), "xsd:string"))
				{	soap_flag_sName1--;
					continue;
				}
			if (soap_flag_sVersion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sVersion", &(a->Xdmsdm__VersionInfo::sVersion), "xsd:string"))
				{	soap_flag_sVersion1--;
					continue;
				}
			if (soap_flag_sDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sDescription", &(a->Xdmsdm__VersionInfo::sDescription), "xsd:string"))
				{	soap_flag_sDescription1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__VersionInfo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo, 0, sizeof(Xdmsdm__VersionInfo), 0, soap_copy_Xdmsdm__VersionInfo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sName1 > 0 || soap_flag_sVersion1 > 0 || soap_flag_sDescription1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int Xdmsdm__VersionInfo::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:VersionInfo", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__VersionInfo::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__VersionInfo(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__VersionInfo * SOAP_FMAC4 soap_get_Xdmsdm__VersionInfo(struct soap *soap, Xdmsdm__VersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__VersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__VersionInfo * SOAP_FMAC2 soap_instantiate_Xdmsdm__VersionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__VersionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__VersionInfo);
		if (size)
			*size = sizeof(Xdmsdm__VersionInfo);
		((Xdmsdm__VersionInfo*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__VersionInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__VersionInfo);
		for (int i = 0; i < n; i++)
			((Xdmsdm__VersionInfo*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__VersionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__VersionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__VersionInfo %p -> %p\n", q, p));
	*(Xdmsdm__VersionInfo*)p = *(Xdmsdm__VersionInfo*)q;
}

void Xdmsdm__FreqLayoutArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Xdmsdm__FreqLayoutArray::__sizeitem = 0;
	this->Xdmsdm__FreqLayoutArray::item = NULL;
	/* transient soap skipped */
}

void Xdmsdm__FreqLayoutArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->Xdmsdm__FreqLayoutArray::item)
	{	int i;
		for (i = 0; i < this->Xdmsdm__FreqLayoutArray::__sizeitem; i++)
		{
			soap_serialize_PointerToXdmsdm__FreqLayout(soap, this->Xdmsdm__FreqLayoutArray::item + i);
		}
	}
	/* transient soap skipped */
}

int Xdmsdm__FreqLayoutArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__FreqLayoutArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__FreqLayoutArray(struct soap *soap, const char *tag, int id, const Xdmsdm__FreqLayoutArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray), type))
		return soap->error;
	if (a->Xdmsdm__FreqLayoutArray::item)
	{	int i;
		for (i = 0; i < a->Xdmsdm__FreqLayoutArray::__sizeitem; i++)
			if (soap_out_PointerToXdmsdm__FreqLayout(soap, "item", -1, a->Xdmsdm__FreqLayoutArray::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__FreqLayoutArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__FreqLayoutArray(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__FreqLayoutArray * SOAP_FMAC4 soap_in_Xdmsdm__FreqLayoutArray(struct soap *soap, const char *tag, Xdmsdm__FreqLayoutArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__FreqLayoutArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray, sizeof(Xdmsdm__FreqLayoutArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__FreqLayoutArray *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->Xdmsdm__FreqLayoutArray::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->Xdmsdm__FreqLayoutArray::item = (Xdmsdm__FreqLayout **)soap_push_block(soap, soap_blist_item1, sizeof(Xdmsdm__FreqLayout *));
					if (a->Xdmsdm__FreqLayoutArray::item == NULL)
						return NULL;
					*a->Xdmsdm__FreqLayoutArray::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToXdmsdm__FreqLayout(soap, "item", a->Xdmsdm__FreqLayoutArray::item, "Xdmsdm:FreqLayout"))
				{	a->Xdmsdm__FreqLayoutArray::__sizeitem++;
					a->Xdmsdm__FreqLayoutArray::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Xdmsdm__FreqLayoutArray::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->Xdmsdm__FreqLayoutArray::__sizeitem)
			a->Xdmsdm__FreqLayoutArray::item = (Xdmsdm__FreqLayout **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->Xdmsdm__FreqLayoutArray::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__FreqLayoutArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray, 0, sizeof(Xdmsdm__FreqLayoutArray), 0, soap_copy_Xdmsdm__FreqLayoutArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int Xdmsdm__FreqLayoutArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:FreqLayoutArray", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__FreqLayoutArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__FreqLayoutArray(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__FreqLayoutArray * SOAP_FMAC4 soap_get_Xdmsdm__FreqLayoutArray(struct soap *soap, Xdmsdm__FreqLayoutArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__FreqLayoutArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__FreqLayoutArray * SOAP_FMAC2 soap_instantiate_Xdmsdm__FreqLayoutArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__FreqLayoutArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__FreqLayoutArray);
		if (size)
			*size = sizeof(Xdmsdm__FreqLayoutArray);
		((Xdmsdm__FreqLayoutArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__FreqLayoutArray[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__FreqLayoutArray);
		for (int i = 0; i < n; i++)
			((Xdmsdm__FreqLayoutArray*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__FreqLayoutArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__FreqLayoutArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__FreqLayoutArray %p -> %p\n", q, p));
	*(Xdmsdm__FreqLayoutArray*)p = *(Xdmsdm__FreqLayoutArray*)q;
}

void Xdmsdm__FreqLayout::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->Xdmsdm__FreqLayout::sLayoutName);
	soap_default_LONG64(soap, &this->Xdmsdm__FreqLayout::nStartFreq);
	soap_default_LONG64(soap, &this->Xdmsdm__FreqLayout::nEndFreq);
	soap_default_std__string(soap, &this->Xdmsdm__FreqLayout::sGroupName);
	soap_default_LONG64(soap, &this->Xdmsdm__FreqLayout::nDistince);
	soap_default_LONG64(soap, &this->Xdmsdm__FreqLayout::nEmitWidth);
	/* transient soap skipped */
}

void Xdmsdm__FreqLayout::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->Xdmsdm__FreqLayout::sLayoutName);
	soap_serialize_std__string(soap, &this->Xdmsdm__FreqLayout::sGroupName);
	/* transient soap skipped */
}

int Xdmsdm__FreqLayout::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__FreqLayout(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__FreqLayout(struct soap *soap, const char *tag, int id, const Xdmsdm__FreqLayout *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout), type))
		return soap->error;
	if (soap_out_std__string(soap, "sLayoutName", -1, &(a->Xdmsdm__FreqLayout::sLayoutName), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "nStartFreq", -1, &(a->Xdmsdm__FreqLayout::nStartFreq), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "nEndFreq", -1, &(a->Xdmsdm__FreqLayout::nEndFreq), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sGroupName", -1, &(a->Xdmsdm__FreqLayout::sGroupName), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "nDistince", -1, &(a->Xdmsdm__FreqLayout::nDistince), ""))
		return soap->error;
	if (soap_out_LONG64(soap, "nEmitWidth", -1, &(a->Xdmsdm__FreqLayout::nEmitWidth), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__FreqLayout::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__FreqLayout(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__FreqLayout * SOAP_FMAC4 soap_in_Xdmsdm__FreqLayout(struct soap *soap, const char *tag, Xdmsdm__FreqLayout *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__FreqLayout *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout, sizeof(Xdmsdm__FreqLayout), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__FreqLayout *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sLayoutName1 = 1;
	size_t soap_flag_nStartFreq1 = 1;
	size_t soap_flag_nEndFreq1 = 1;
	size_t soap_flag_sGroupName1 = 1;
	size_t soap_flag_nDistince1 = 1;
	size_t soap_flag_nEmitWidth1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sLayoutName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sLayoutName", &(a->Xdmsdm__FreqLayout::sLayoutName), "xsd:string"))
				{	soap_flag_sLayoutName1--;
					continue;
				}
			if (soap_flag_nStartFreq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "nStartFreq", &(a->Xdmsdm__FreqLayout::nStartFreq), "xsd:long"))
				{	soap_flag_nStartFreq1--;
					continue;
				}
			if (soap_flag_nEndFreq1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "nEndFreq", &(a->Xdmsdm__FreqLayout::nEndFreq), "xsd:long"))
				{	soap_flag_nEndFreq1--;
					continue;
				}
			if (soap_flag_sGroupName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sGroupName", &(a->Xdmsdm__FreqLayout::sGroupName), "xsd:string"))
				{	soap_flag_sGroupName1--;
					continue;
				}
			if (soap_flag_nDistince1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "nDistince", &(a->Xdmsdm__FreqLayout::nDistince), "xsd:long"))
				{	soap_flag_nDistince1--;
					continue;
				}
			if (soap_flag_nEmitWidth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "nEmitWidth", &(a->Xdmsdm__FreqLayout::nEmitWidth), "xsd:long"))
				{	soap_flag_nEmitWidth1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__FreqLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout, 0, sizeof(Xdmsdm__FreqLayout), 0, soap_copy_Xdmsdm__FreqLayout);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sLayoutName1 > 0 || soap_flag_nStartFreq1 > 0 || soap_flag_nEndFreq1 > 0 || soap_flag_sGroupName1 > 0 || soap_flag_nDistince1 > 0 || soap_flag_nEmitWidth1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int Xdmsdm__FreqLayout::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:FreqLayout", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__FreqLayout::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__FreqLayout(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__FreqLayout * SOAP_FMAC4 soap_get_Xdmsdm__FreqLayout(struct soap *soap, Xdmsdm__FreqLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__FreqLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__FreqLayout * SOAP_FMAC2 soap_instantiate_Xdmsdm__FreqLayout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__FreqLayout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__FreqLayout);
		if (size)
			*size = sizeof(Xdmsdm__FreqLayout);
		((Xdmsdm__FreqLayout*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__FreqLayout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__FreqLayout);
		for (int i = 0; i < n; i++)
			((Xdmsdm__FreqLayout*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__FreqLayout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__FreqLayout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__FreqLayout %p -> %p\n", q, p));
	*(Xdmsdm__FreqLayout*)p = *(Xdmsdm__FreqLayout*)q;
}

void Xdmsdm__RegionNOArray::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->Xdmsdm__RegionNOArray::__sizeitem = 0;
	this->Xdmsdm__RegionNOArray::item = NULL;
	/* transient soap skipped */
}

void Xdmsdm__RegionNOArray::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->Xdmsdm__RegionNOArray::item)
	{	int i;
		for (i = 0; i < this->Xdmsdm__RegionNOArray::__sizeitem; i++)
		{
			soap_serialize_PointerToXdmsdm__RegionNO(soap, this->Xdmsdm__RegionNOArray::item + i);
		}
	}
	/* transient soap skipped */
}

int Xdmsdm__RegionNOArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__RegionNOArray(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__RegionNOArray(struct soap *soap, const char *tag, int id, const Xdmsdm__RegionNOArray *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray), type))
		return soap->error;
	if (a->Xdmsdm__RegionNOArray::item)
	{	int i;
		for (i = 0; i < a->Xdmsdm__RegionNOArray::__sizeitem; i++)
			if (soap_out_PointerToXdmsdm__RegionNO(soap, "item", -1, a->Xdmsdm__RegionNOArray::item + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__RegionNOArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__RegionNOArray(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__RegionNOArray * SOAP_FMAC4 soap_in_Xdmsdm__RegionNOArray(struct soap *soap, const char *tag, Xdmsdm__RegionNOArray *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__RegionNOArray *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray, sizeof(Xdmsdm__RegionNOArray), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__RegionNOArray *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_item1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "item", 1, NULL))
			{	if (a->Xdmsdm__RegionNOArray::item == NULL)
				{	if (soap_blist_item1 == NULL)
						soap_blist_item1 = soap_new_block(soap);
					a->Xdmsdm__RegionNOArray::item = (Xdmsdm__RegionNO **)soap_push_block(soap, soap_blist_item1, sizeof(Xdmsdm__RegionNO *));
					if (a->Xdmsdm__RegionNOArray::item == NULL)
						return NULL;
					*a->Xdmsdm__RegionNOArray::item = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerToXdmsdm__RegionNO(soap, "item", a->Xdmsdm__RegionNOArray::item, "Xdmsdm:RegionNO"))
				{	a->Xdmsdm__RegionNOArray::__sizeitem++;
					a->Xdmsdm__RegionNOArray::item = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Xdmsdm__RegionNOArray::item)
			soap_pop_block(soap, soap_blist_item1);
		if (a->Xdmsdm__RegionNOArray::__sizeitem)
			a->Xdmsdm__RegionNOArray::item = (Xdmsdm__RegionNO **)soap_save_block(soap, soap_blist_item1, NULL, 1);
		else
		{	a->Xdmsdm__RegionNOArray::item = NULL;
			if (soap_blist_item1)
				soap_end_block(soap, soap_blist_item1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__RegionNOArray *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray, 0, sizeof(Xdmsdm__RegionNOArray), 0, soap_copy_Xdmsdm__RegionNOArray);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int Xdmsdm__RegionNOArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:RegionNOArray", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__RegionNOArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__RegionNOArray(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__RegionNOArray * SOAP_FMAC4 soap_get_Xdmsdm__RegionNOArray(struct soap *soap, Xdmsdm__RegionNOArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__RegionNOArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__RegionNOArray * SOAP_FMAC2 soap_instantiate_Xdmsdm__RegionNOArray(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__RegionNOArray(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__RegionNOArray);
		if (size)
			*size = sizeof(Xdmsdm__RegionNOArray);
		((Xdmsdm__RegionNOArray*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__RegionNOArray[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__RegionNOArray);
		for (int i = 0; i < n; i++)
			((Xdmsdm__RegionNOArray*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__RegionNOArray*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__RegionNOArray(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__RegionNOArray %p -> %p\n", q, p));
	*(Xdmsdm__RegionNOArray*)p = *(Xdmsdm__RegionNOArray*)q;
}

void Xdmsdm__RegionNO::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->Xdmsdm__RegionNO::sName);
	soap_default_std__string(soap, &this->Xdmsdm__RegionNO::sRegionNO);
	soap_default_std__string(soap, &this->Xdmsdm__RegionNO::sNote);
	/* transient soap skipped */
}

void Xdmsdm__RegionNO::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &this->Xdmsdm__RegionNO::sName);
	soap_serialize_std__string(soap, &this->Xdmsdm__RegionNO::sRegionNO);
	soap_serialize_std__string(soap, &this->Xdmsdm__RegionNO::sNote);
	/* transient soap skipped */
}

int Xdmsdm__RegionNO::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_Xdmsdm__RegionNO(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_Xdmsdm__RegionNO(struct soap *soap, const char *tag, int id, const Xdmsdm__RegionNO *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO), type))
		return soap->error;
	if (soap_out_std__string(soap, "sName", -1, &(a->Xdmsdm__RegionNO::sName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sRegionNO", -1, &(a->Xdmsdm__RegionNO::sRegionNO), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sNote", -1, &(a->Xdmsdm__RegionNO::sNote), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *Xdmsdm__RegionNO::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_Xdmsdm__RegionNO(soap, tag, this, type);
}

SOAP_FMAC3 Xdmsdm__RegionNO * SOAP_FMAC4 soap_in_Xdmsdm__RegionNO(struct soap *soap, const char *tag, Xdmsdm__RegionNO *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (Xdmsdm__RegionNO *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO, sizeof(Xdmsdm__RegionNO), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (Xdmsdm__RegionNO *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sName1 = 1;
	size_t soap_flag_sRegionNO1 = 1;
	size_t soap_flag_sNote1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sName", &(a->Xdmsdm__RegionNO::sName), "xsd:string"))
				{	soap_flag_sName1--;
					continue;
				}
			if (soap_flag_sRegionNO1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sRegionNO", &(a->Xdmsdm__RegionNO::sRegionNO), "xsd:string"))
				{	soap_flag_sRegionNO1--;
					continue;
				}
			if (soap_flag_sNote1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sNote", &(a->Xdmsdm__RegionNO::sNote), "xsd:string"))
				{	soap_flag_sNote1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (Xdmsdm__RegionNO *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO, 0, sizeof(Xdmsdm__RegionNO), 0, soap_copy_Xdmsdm__RegionNO);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sName1 > 0 || soap_flag_sRegionNO1 > 0 || soap_flag_sNote1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int Xdmsdm__RegionNO::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO);
	if (this->soap_out(soap, tag?tag:"Xdmsdm:RegionNO", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *Xdmsdm__RegionNO::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_Xdmsdm__RegionNO(soap, this, tag, type);
}

SOAP_FMAC3 Xdmsdm__RegionNO * SOAP_FMAC4 soap_get_Xdmsdm__RegionNO(struct soap *soap, Xdmsdm__RegionNO *p, const char *tag, const char *type)
{
	if ((p = soap_in_Xdmsdm__RegionNO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 Xdmsdm__RegionNO * SOAP_FMAC2 soap_instantiate_Xdmsdm__RegionNO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_Xdmsdm__RegionNO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__RegionNO);
		if (size)
			*size = sizeof(Xdmsdm__RegionNO);
		((Xdmsdm__RegionNO*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(Xdmsdm__RegionNO[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(Xdmsdm__RegionNO);
		for (int i = 0; i < n; i++)
			((Xdmsdm__RegionNO*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (Xdmsdm__RegionNO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_Xdmsdm__RegionNO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying Xdmsdm__RegionNO %p -> %p\n", q, p));
	*(Xdmsdm__RegionNO*)p = *(Xdmsdm__RegionNO*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_SOAP_ENV__Fault, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_SOAP_ENV__Reason, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_SOAP_ENV__Detail, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_SOAP_ENV__Code, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_Xdmsdm_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm_SOAP_ENV__Header, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, struct __Xdmsdm__GetMonthReportBusFreqs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__GetMonthReportBusFreqs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, const struct __Xdmsdm__GetMonthReportBusFreqs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__GetMonthReportBusFreqs(soap, &a->Xdmsdm__GetMonthReportBusFreqs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__GetMonthReportBusFreqs *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__GetMonthReportBusFreqs(soap, "Xdmsdm:GetMonthReportBusFreqs", -1, &a->Xdmsdm__GetMonthReportBusFreqs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__GetMonthReportBusFreqs * SOAP_FMAC4 soap_in___Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, const char *tag, struct __Xdmsdm__GetMonthReportBusFreqs *a, const char *type)
{
	size_t soap_flag_Xdmsdm__GetMonthReportBusFreqs = 1;
	short soap_flag;
	a = (struct __Xdmsdm__GetMonthReportBusFreqs *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__GetMonthReportBusFreqs, sizeof(struct __Xdmsdm__GetMonthReportBusFreqs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__GetMonthReportBusFreqs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__GetMonthReportBusFreqs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__GetMonthReportBusFreqs(soap, "Xdmsdm:GetMonthReportBusFreqs", &a->Xdmsdm__GetMonthReportBusFreqs, ""))
				{	soap_flag_Xdmsdm__GetMonthReportBusFreqs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, const struct __Xdmsdm__GetMonthReportBusFreqs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__GetMonthReportBusFreqs(soap, tag?tag:"-Xdmsdm:GetMonthReportBusFreqs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__GetMonthReportBusFreqs * SOAP_FMAC4 soap_get___Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, struct __Xdmsdm__GetMonthReportBusFreqs *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__GetMonthReportBusFreqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__GetMonthReportBusFreqs * SOAP_FMAC2 soap_instantiate___Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__GetMonthReportBusFreqs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__GetMonthReportBusFreqs, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__GetMonthReportBusFreqs);
		if (size)
			*size = sizeof(struct __Xdmsdm__GetMonthReportBusFreqs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__GetMonthReportBusFreqs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__GetMonthReportBusFreqs);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__GetMonthReportBusFreqs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__GetMonthReportBusFreqs %p -> %p\n", q, p));
	*(struct __Xdmsdm__GetMonthReportBusFreqs*)p = *(struct __Xdmsdm__GetMonthReportBusFreqs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, struct __Xdmsdm__SetMonthReportBusFreqs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__SetMonthReportBusFreqs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, const struct __Xdmsdm__SetMonthReportBusFreqs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__SetMonthReportBusFreqs(soap, &a->Xdmsdm__SetMonthReportBusFreqs);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__SetMonthReportBusFreqs *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__SetMonthReportBusFreqs(soap, "Xdmsdm:SetMonthReportBusFreqs", -1, &a->Xdmsdm__SetMonthReportBusFreqs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__SetMonthReportBusFreqs * SOAP_FMAC4 soap_in___Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, const char *tag, struct __Xdmsdm__SetMonthReportBusFreqs *a, const char *type)
{
	size_t soap_flag_Xdmsdm__SetMonthReportBusFreqs = 1;
	short soap_flag;
	a = (struct __Xdmsdm__SetMonthReportBusFreqs *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__SetMonthReportBusFreqs, sizeof(struct __Xdmsdm__SetMonthReportBusFreqs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__SetMonthReportBusFreqs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__SetMonthReportBusFreqs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__SetMonthReportBusFreqs(soap, "Xdmsdm:SetMonthReportBusFreqs", &a->Xdmsdm__SetMonthReportBusFreqs, ""))
				{	soap_flag_Xdmsdm__SetMonthReportBusFreqs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, const struct __Xdmsdm__SetMonthReportBusFreqs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__SetMonthReportBusFreqs(soap, tag?tag:"-Xdmsdm:SetMonthReportBusFreqs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__SetMonthReportBusFreqs * SOAP_FMAC4 soap_get___Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, struct __Xdmsdm__SetMonthReportBusFreqs *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__SetMonthReportBusFreqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__SetMonthReportBusFreqs * SOAP_FMAC2 soap_instantiate___Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__SetMonthReportBusFreqs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__SetMonthReportBusFreqs, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__SetMonthReportBusFreqs);
		if (size)
			*size = sizeof(struct __Xdmsdm__SetMonthReportBusFreqs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__SetMonthReportBusFreqs[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__SetMonthReportBusFreqs);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__SetMonthReportBusFreqs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__SetMonthReportBusFreqs %p -> %p\n", q, p));
	*(struct __Xdmsdm__SetMonthReportBusFreqs*)p = *(struct __Xdmsdm__SetMonthReportBusFreqs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, struct __Xdmsdm__GetMonthReportWorkPlans *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__GetMonthReportWorkPlans = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, const struct __Xdmsdm__GetMonthReportWorkPlans *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__GetMonthReportWorkPlans(soap, &a->Xdmsdm__GetMonthReportWorkPlans);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__GetMonthReportWorkPlans *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__GetMonthReportWorkPlans(soap, "Xdmsdm:GetMonthReportWorkPlans", -1, &a->Xdmsdm__GetMonthReportWorkPlans, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__GetMonthReportWorkPlans * SOAP_FMAC4 soap_in___Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, const char *tag, struct __Xdmsdm__GetMonthReportWorkPlans *a, const char *type)
{
	size_t soap_flag_Xdmsdm__GetMonthReportWorkPlans = 1;
	short soap_flag;
	a = (struct __Xdmsdm__GetMonthReportWorkPlans *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__GetMonthReportWorkPlans, sizeof(struct __Xdmsdm__GetMonthReportWorkPlans), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__GetMonthReportWorkPlans(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__GetMonthReportWorkPlans && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__GetMonthReportWorkPlans(soap, "Xdmsdm:GetMonthReportWorkPlans", &a->Xdmsdm__GetMonthReportWorkPlans, ""))
				{	soap_flag_Xdmsdm__GetMonthReportWorkPlans--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, const struct __Xdmsdm__GetMonthReportWorkPlans *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__GetMonthReportWorkPlans(soap, tag?tag:"-Xdmsdm:GetMonthReportWorkPlans", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__GetMonthReportWorkPlans * SOAP_FMAC4 soap_get___Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, struct __Xdmsdm__GetMonthReportWorkPlans *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__GetMonthReportWorkPlans(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__GetMonthReportWorkPlans * SOAP_FMAC2 soap_instantiate___Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__GetMonthReportWorkPlans(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__GetMonthReportWorkPlans, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__GetMonthReportWorkPlans);
		if (size)
			*size = sizeof(struct __Xdmsdm__GetMonthReportWorkPlans);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__GetMonthReportWorkPlans[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__GetMonthReportWorkPlans);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__GetMonthReportWorkPlans*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__GetMonthReportWorkPlans %p -> %p\n", q, p));
	*(struct __Xdmsdm__GetMonthReportWorkPlans*)p = *(struct __Xdmsdm__GetMonthReportWorkPlans*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, struct __Xdmsdm__SetMonthReportWorkPlans *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__SetMonthReportWorkPlans = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, const struct __Xdmsdm__SetMonthReportWorkPlans *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__SetMonthReportWorkPlans(soap, &a->Xdmsdm__SetMonthReportWorkPlans);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__SetMonthReportWorkPlans *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__SetMonthReportWorkPlans(soap, "Xdmsdm:SetMonthReportWorkPlans", -1, &a->Xdmsdm__SetMonthReportWorkPlans, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__SetMonthReportWorkPlans * SOAP_FMAC4 soap_in___Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, const char *tag, struct __Xdmsdm__SetMonthReportWorkPlans *a, const char *type)
{
	size_t soap_flag_Xdmsdm__SetMonthReportWorkPlans = 1;
	short soap_flag;
	a = (struct __Xdmsdm__SetMonthReportWorkPlans *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__SetMonthReportWorkPlans, sizeof(struct __Xdmsdm__SetMonthReportWorkPlans), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__SetMonthReportWorkPlans(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__SetMonthReportWorkPlans && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__SetMonthReportWorkPlans(soap, "Xdmsdm:SetMonthReportWorkPlans", &a->Xdmsdm__SetMonthReportWorkPlans, ""))
				{	soap_flag_Xdmsdm__SetMonthReportWorkPlans--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, const struct __Xdmsdm__SetMonthReportWorkPlans *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__SetMonthReportWorkPlans(soap, tag?tag:"-Xdmsdm:SetMonthReportWorkPlans", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__SetMonthReportWorkPlans * SOAP_FMAC4 soap_get___Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, struct __Xdmsdm__SetMonthReportWorkPlans *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__SetMonthReportWorkPlans(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__SetMonthReportWorkPlans * SOAP_FMAC2 soap_instantiate___Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__SetMonthReportWorkPlans(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__SetMonthReportWorkPlans, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__SetMonthReportWorkPlans);
		if (size)
			*size = sizeof(struct __Xdmsdm__SetMonthReportWorkPlans);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__SetMonthReportWorkPlans[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__SetMonthReportWorkPlans);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__SetMonthReportWorkPlans*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__SetMonthReportWorkPlans %p -> %p\n", q, p));
	*(struct __Xdmsdm__SetMonthReportWorkPlans*)p = *(struct __Xdmsdm__SetMonthReportWorkPlans*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__QueryUserInfo(struct soap *soap, struct __Xdmsdm__QueryUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__QueryUserInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__QueryUserInfo(struct soap *soap, const struct __Xdmsdm__QueryUserInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__QueryUserInfo(soap, &a->Xdmsdm__QueryUserInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__QueryUserInfo(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__QueryUserInfo *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__QueryUserInfo(soap, "Xdmsdm:QueryUserInfo", -1, &a->Xdmsdm__QueryUserInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryUserInfo * SOAP_FMAC4 soap_in___Xdmsdm__QueryUserInfo(struct soap *soap, const char *tag, struct __Xdmsdm__QueryUserInfo *a, const char *type)
{
	size_t soap_flag_Xdmsdm__QueryUserInfo = 1;
	short soap_flag;
	a = (struct __Xdmsdm__QueryUserInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserInfo, sizeof(struct __Xdmsdm__QueryUserInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__QueryUserInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__QueryUserInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__QueryUserInfo(soap, "Xdmsdm:QueryUserInfo", &a->Xdmsdm__QueryUserInfo, ""))
				{	soap_flag_Xdmsdm__QueryUserInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__QueryUserInfo(struct soap *soap, const struct __Xdmsdm__QueryUserInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__QueryUserInfo(soap, tag?tag:"-Xdmsdm:QueryUserInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryUserInfo * SOAP_FMAC4 soap_get___Xdmsdm__QueryUserInfo(struct soap *soap, struct __Xdmsdm__QueryUserInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__QueryUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__QueryUserInfo * SOAP_FMAC2 soap_instantiate___Xdmsdm__QueryUserInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__QueryUserInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserInfo, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryUserInfo);
		if (size)
			*size = sizeof(struct __Xdmsdm__QueryUserInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryUserInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__QueryUserInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__QueryUserInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__QueryUserInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__QueryUserInfo %p -> %p\n", q, p));
	*(struct __Xdmsdm__QueryUserInfo*)p = *(struct __Xdmsdm__QueryUserInfo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__SendMobileMessage(struct soap *soap, struct __Xdmsdm__SendMobileMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__SendMobileMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__SendMobileMessage(struct soap *soap, const struct __Xdmsdm__SendMobileMessage *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__SendMobileMessage(soap, &a->Xdmsdm__SendMobileMessage);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__SendMobileMessage(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__SendMobileMessage *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__SendMobileMessage(soap, "Xdmsdm:SendMobileMessage", -1, &a->Xdmsdm__SendMobileMessage, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__SendMobileMessage * SOAP_FMAC4 soap_in___Xdmsdm__SendMobileMessage(struct soap *soap, const char *tag, struct __Xdmsdm__SendMobileMessage *a, const char *type)
{
	size_t soap_flag_Xdmsdm__SendMobileMessage = 1;
	short soap_flag;
	a = (struct __Xdmsdm__SendMobileMessage *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__SendMobileMessage, sizeof(struct __Xdmsdm__SendMobileMessage), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__SendMobileMessage(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__SendMobileMessage && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__SendMobileMessage(soap, "Xdmsdm:SendMobileMessage", &a->Xdmsdm__SendMobileMessage, ""))
				{	soap_flag_Xdmsdm__SendMobileMessage--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__SendMobileMessage(struct soap *soap, const struct __Xdmsdm__SendMobileMessage *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__SendMobileMessage(soap, tag?tag:"-Xdmsdm:SendMobileMessage", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__SendMobileMessage * SOAP_FMAC4 soap_get___Xdmsdm__SendMobileMessage(struct soap *soap, struct __Xdmsdm__SendMobileMessage *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__SendMobileMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__SendMobileMessage * SOAP_FMAC2 soap_instantiate___Xdmsdm__SendMobileMessage(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__SendMobileMessage(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__SendMobileMessage, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__SendMobileMessage);
		if (size)
			*size = sizeof(struct __Xdmsdm__SendMobileMessage);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__SendMobileMessage[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__SendMobileMessage);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__SendMobileMessage*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__SendMobileMessage(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__SendMobileMessage %p -> %p\n", q, p));
	*(struct __Xdmsdm__SendMobileMessage*)p = *(struct __Xdmsdm__SendMobileMessage*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__QueryUserMobileNO(struct soap *soap, struct __Xdmsdm__QueryUserMobileNO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__QueryUserMobileNO = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__QueryUserMobileNO(struct soap *soap, const struct __Xdmsdm__QueryUserMobileNO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__QueryUserMobileNO(soap, &a->Xdmsdm__QueryUserMobileNO);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__QueryUserMobileNO(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__QueryUserMobileNO *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__QueryUserMobileNO(soap, "Xdmsdm:QueryUserMobileNO", -1, &a->Xdmsdm__QueryUserMobileNO, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryUserMobileNO * SOAP_FMAC4 soap_in___Xdmsdm__QueryUserMobileNO(struct soap *soap, const char *tag, struct __Xdmsdm__QueryUserMobileNO *a, const char *type)
{
	size_t soap_flag_Xdmsdm__QueryUserMobileNO = 1;
	short soap_flag;
	a = (struct __Xdmsdm__QueryUserMobileNO *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserMobileNO, sizeof(struct __Xdmsdm__QueryUserMobileNO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__QueryUserMobileNO(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__QueryUserMobileNO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__QueryUserMobileNO(soap, "Xdmsdm:QueryUserMobileNO", &a->Xdmsdm__QueryUserMobileNO, ""))
				{	soap_flag_Xdmsdm__QueryUserMobileNO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__QueryUserMobileNO(struct soap *soap, const struct __Xdmsdm__QueryUserMobileNO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__QueryUserMobileNO(soap, tag?tag:"-Xdmsdm:QueryUserMobileNO", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryUserMobileNO * SOAP_FMAC4 soap_get___Xdmsdm__QueryUserMobileNO(struct soap *soap, struct __Xdmsdm__QueryUserMobileNO *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__QueryUserMobileNO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__QueryUserMobileNO * SOAP_FMAC2 soap_instantiate___Xdmsdm__QueryUserMobileNO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__QueryUserMobileNO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserMobileNO, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryUserMobileNO);
		if (size)
			*size = sizeof(struct __Xdmsdm__QueryUserMobileNO);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryUserMobileNO[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__QueryUserMobileNO);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__QueryUserMobileNO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__QueryUserMobileNO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__QueryUserMobileNO %p -> %p\n", q, p));
	*(struct __Xdmsdm__QueryUserMobileNO*)p = *(struct __Xdmsdm__QueryUserMobileNO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__QueryStandardTime(struct soap *soap, struct __Xdmsdm__QueryStandardTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__QueryStandardTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__QueryStandardTime(struct soap *soap, const struct __Xdmsdm__QueryStandardTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__QueryStandardTime(soap, &a->Xdmsdm__QueryStandardTime);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__QueryStandardTime(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__QueryStandardTime *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__QueryStandardTime(soap, "Xdmsdm:QueryStandardTime", -1, &a->Xdmsdm__QueryStandardTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryStandardTime * SOAP_FMAC4 soap_in___Xdmsdm__QueryStandardTime(struct soap *soap, const char *tag, struct __Xdmsdm__QueryStandardTime *a, const char *type)
{
	size_t soap_flag_Xdmsdm__QueryStandardTime = 1;
	short soap_flag;
	a = (struct __Xdmsdm__QueryStandardTime *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryStandardTime, sizeof(struct __Xdmsdm__QueryStandardTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__QueryStandardTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__QueryStandardTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__QueryStandardTime(soap, "Xdmsdm:QueryStandardTime", &a->Xdmsdm__QueryStandardTime, ""))
				{	soap_flag_Xdmsdm__QueryStandardTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__QueryStandardTime(struct soap *soap, const struct __Xdmsdm__QueryStandardTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__QueryStandardTime(soap, tag?tag:"-Xdmsdm:QueryStandardTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryStandardTime * SOAP_FMAC4 soap_get___Xdmsdm__QueryStandardTime(struct soap *soap, struct __Xdmsdm__QueryStandardTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__QueryStandardTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__QueryStandardTime * SOAP_FMAC2 soap_instantiate___Xdmsdm__QueryStandardTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__QueryStandardTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryStandardTime, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryStandardTime);
		if (size)
			*size = sizeof(struct __Xdmsdm__QueryStandardTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryStandardTime[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__QueryStandardTime);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__QueryStandardTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__QueryStandardTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__QueryStandardTime %p -> %p\n", q, p));
	*(struct __Xdmsdm__QueryStandardTime*)p = *(struct __Xdmsdm__QueryStandardTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__SubmitOperateLog(struct soap *soap, struct __Xdmsdm__SubmitOperateLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__SubmitOperateLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__SubmitOperateLog(struct soap *soap, const struct __Xdmsdm__SubmitOperateLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__SubmitOperateLog(soap, &a->Xdmsdm__SubmitOperateLog);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__SubmitOperateLog(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__SubmitOperateLog *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__SubmitOperateLog(soap, "Xdmsdm:SubmitOperateLog", -1, &a->Xdmsdm__SubmitOperateLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__SubmitOperateLog * SOAP_FMAC4 soap_in___Xdmsdm__SubmitOperateLog(struct soap *soap, const char *tag, struct __Xdmsdm__SubmitOperateLog *a, const char *type)
{
	size_t soap_flag_Xdmsdm__SubmitOperateLog = 1;
	short soap_flag;
	a = (struct __Xdmsdm__SubmitOperateLog *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__SubmitOperateLog, sizeof(struct __Xdmsdm__SubmitOperateLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__SubmitOperateLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__SubmitOperateLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__SubmitOperateLog(soap, "Xdmsdm:SubmitOperateLog", &a->Xdmsdm__SubmitOperateLog, ""))
				{	soap_flag_Xdmsdm__SubmitOperateLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__SubmitOperateLog(struct soap *soap, const struct __Xdmsdm__SubmitOperateLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__SubmitOperateLog(soap, tag?tag:"-Xdmsdm:SubmitOperateLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__SubmitOperateLog * SOAP_FMAC4 soap_get___Xdmsdm__SubmitOperateLog(struct soap *soap, struct __Xdmsdm__SubmitOperateLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__SubmitOperateLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__SubmitOperateLog * SOAP_FMAC2 soap_instantiate___Xdmsdm__SubmitOperateLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__SubmitOperateLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__SubmitOperateLog, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__SubmitOperateLog);
		if (size)
			*size = sizeof(struct __Xdmsdm__SubmitOperateLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__SubmitOperateLog[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__SubmitOperateLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__SubmitOperateLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__SubmitOperateLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__SubmitOperateLog %p -> %p\n", q, p));
	*(struct __Xdmsdm__SubmitOperateLog*)p = *(struct __Xdmsdm__SubmitOperateLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__QueryUserLicenseFunc(struct soap *soap, struct __Xdmsdm__QueryUserLicenseFunc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__QueryUserLicenseFunc = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__QueryUserLicenseFunc(struct soap *soap, const struct __Xdmsdm__QueryUserLicenseFunc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__QueryUserLicenseFunc(soap, &a->Xdmsdm__QueryUserLicenseFunc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__QueryUserLicenseFunc(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__QueryUserLicenseFunc *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__QueryUserLicenseFunc(soap, "Xdmsdm:QueryUserLicenseFunc", -1, &a->Xdmsdm__QueryUserLicenseFunc, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryUserLicenseFunc * SOAP_FMAC4 soap_in___Xdmsdm__QueryUserLicenseFunc(struct soap *soap, const char *tag, struct __Xdmsdm__QueryUserLicenseFunc *a, const char *type)
{
	size_t soap_flag_Xdmsdm__QueryUserLicenseFunc = 1;
	short soap_flag;
	a = (struct __Xdmsdm__QueryUserLicenseFunc *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserLicenseFunc, sizeof(struct __Xdmsdm__QueryUserLicenseFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__QueryUserLicenseFunc(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__QueryUserLicenseFunc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__QueryUserLicenseFunc(soap, "Xdmsdm:QueryUserLicenseFunc", &a->Xdmsdm__QueryUserLicenseFunc, ""))
				{	soap_flag_Xdmsdm__QueryUserLicenseFunc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__QueryUserLicenseFunc(struct soap *soap, const struct __Xdmsdm__QueryUserLicenseFunc *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__QueryUserLicenseFunc(soap, tag?tag:"-Xdmsdm:QueryUserLicenseFunc", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryUserLicenseFunc * SOAP_FMAC4 soap_get___Xdmsdm__QueryUserLicenseFunc(struct soap *soap, struct __Xdmsdm__QueryUserLicenseFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__QueryUserLicenseFunc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__QueryUserLicenseFunc * SOAP_FMAC2 soap_instantiate___Xdmsdm__QueryUserLicenseFunc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__QueryUserLicenseFunc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryUserLicenseFunc, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryUserLicenseFunc);
		if (size)
			*size = sizeof(struct __Xdmsdm__QueryUserLicenseFunc);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryUserLicenseFunc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__QueryUserLicenseFunc);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__QueryUserLicenseFunc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__QueryUserLicenseFunc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__QueryUserLicenseFunc %p -> %p\n", q, p));
	*(struct __Xdmsdm__QueryUserLicenseFunc*)p = *(struct __Xdmsdm__QueryUserLicenseFunc*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__AuthUserLicenseFunc(struct soap *soap, struct __Xdmsdm__AuthUserLicenseFunc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__AuthUserLicenseFunc = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__AuthUserLicenseFunc(struct soap *soap, const struct __Xdmsdm__AuthUserLicenseFunc *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__AuthUserLicenseFunc(soap, &a->Xdmsdm__AuthUserLicenseFunc);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__AuthUserLicenseFunc(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__AuthUserLicenseFunc *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__AuthUserLicenseFunc(soap, "Xdmsdm:AuthUserLicenseFunc", -1, &a->Xdmsdm__AuthUserLicenseFunc, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__AuthUserLicenseFunc * SOAP_FMAC4 soap_in___Xdmsdm__AuthUserLicenseFunc(struct soap *soap, const char *tag, struct __Xdmsdm__AuthUserLicenseFunc *a, const char *type)
{
	size_t soap_flag_Xdmsdm__AuthUserLicenseFunc = 1;
	short soap_flag;
	a = (struct __Xdmsdm__AuthUserLicenseFunc *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__AuthUserLicenseFunc, sizeof(struct __Xdmsdm__AuthUserLicenseFunc), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__AuthUserLicenseFunc(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__AuthUserLicenseFunc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__AuthUserLicenseFunc(soap, "Xdmsdm:AuthUserLicenseFunc", &a->Xdmsdm__AuthUserLicenseFunc, ""))
				{	soap_flag_Xdmsdm__AuthUserLicenseFunc--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__AuthUserLicenseFunc(struct soap *soap, const struct __Xdmsdm__AuthUserLicenseFunc *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__AuthUserLicenseFunc(soap, tag?tag:"-Xdmsdm:AuthUserLicenseFunc", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__AuthUserLicenseFunc * SOAP_FMAC4 soap_get___Xdmsdm__AuthUserLicenseFunc(struct soap *soap, struct __Xdmsdm__AuthUserLicenseFunc *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__AuthUserLicenseFunc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__AuthUserLicenseFunc * SOAP_FMAC2 soap_instantiate___Xdmsdm__AuthUserLicenseFunc(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__AuthUserLicenseFunc(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__AuthUserLicenseFunc, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__AuthUserLicenseFunc);
		if (size)
			*size = sizeof(struct __Xdmsdm__AuthUserLicenseFunc);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__AuthUserLicenseFunc[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__AuthUserLicenseFunc);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__AuthUserLicenseFunc*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__AuthUserLicenseFunc(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__AuthUserLicenseFunc %p -> %p\n", q, p));
	*(struct __Xdmsdm__AuthUserLicenseFunc*)p = *(struct __Xdmsdm__AuthUserLicenseFunc*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__AuthUser(struct soap *soap, struct __Xdmsdm__AuthUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__AuthUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__AuthUser(struct soap *soap, const struct __Xdmsdm__AuthUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__AuthUser(soap, &a->Xdmsdm__AuthUser);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__AuthUser(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__AuthUser *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__AuthUser(soap, "Xdmsdm:AuthUser", -1, &a->Xdmsdm__AuthUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__AuthUser * SOAP_FMAC4 soap_in___Xdmsdm__AuthUser(struct soap *soap, const char *tag, struct __Xdmsdm__AuthUser *a, const char *type)
{
	size_t soap_flag_Xdmsdm__AuthUser = 1;
	short soap_flag;
	a = (struct __Xdmsdm__AuthUser *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__AuthUser, sizeof(struct __Xdmsdm__AuthUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__AuthUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__AuthUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__AuthUser(soap, "Xdmsdm:AuthUser", &a->Xdmsdm__AuthUser, ""))
				{	soap_flag_Xdmsdm__AuthUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__AuthUser(struct soap *soap, const struct __Xdmsdm__AuthUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__AuthUser(soap, tag?tag:"-Xdmsdm:AuthUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__AuthUser * SOAP_FMAC4 soap_get___Xdmsdm__AuthUser(struct soap *soap, struct __Xdmsdm__AuthUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__AuthUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__AuthUser * SOAP_FMAC2 soap_instantiate___Xdmsdm__AuthUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__AuthUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__AuthUser, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__AuthUser);
		if (size)
			*size = sizeof(struct __Xdmsdm__AuthUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__AuthUser[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__AuthUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__AuthUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__AuthUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__AuthUser %p -> %p\n", q, p));
	*(struct __Xdmsdm__AuthUser*)p = *(struct __Xdmsdm__AuthUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__QueryWebService(struct soap *soap, struct __Xdmsdm__QueryWebService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__QueryWebService = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__QueryWebService(struct soap *soap, const struct __Xdmsdm__QueryWebService *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__QueryWebService(soap, &a->Xdmsdm__QueryWebService);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__QueryWebService(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__QueryWebService *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__QueryWebService(soap, "Xdmsdm:QueryWebService", -1, &a->Xdmsdm__QueryWebService, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryWebService * SOAP_FMAC4 soap_in___Xdmsdm__QueryWebService(struct soap *soap, const char *tag, struct __Xdmsdm__QueryWebService *a, const char *type)
{
	size_t soap_flag_Xdmsdm__QueryWebService = 1;
	short soap_flag;
	a = (struct __Xdmsdm__QueryWebService *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryWebService, sizeof(struct __Xdmsdm__QueryWebService), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__QueryWebService(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__QueryWebService && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__QueryWebService(soap, "Xdmsdm:QueryWebService", &a->Xdmsdm__QueryWebService, ""))
				{	soap_flag_Xdmsdm__QueryWebService--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__QueryWebService(struct soap *soap, const struct __Xdmsdm__QueryWebService *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__QueryWebService(soap, tag?tag:"-Xdmsdm:QueryWebService", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryWebService * SOAP_FMAC4 soap_get___Xdmsdm__QueryWebService(struct soap *soap, struct __Xdmsdm__QueryWebService *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__QueryWebService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__QueryWebService * SOAP_FMAC2 soap_instantiate___Xdmsdm__QueryWebService(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__QueryWebService(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryWebService, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryWebService);
		if (size)
			*size = sizeof(struct __Xdmsdm__QueryWebService);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryWebService[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__QueryWebService);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__QueryWebService*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__QueryWebService(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__QueryWebService %p -> %p\n", q, p));
	*(struct __Xdmsdm__QueryWebService*)p = *(struct __Xdmsdm__QueryWebService*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__QueryFreqLayout(struct soap *soap, struct __Xdmsdm__QueryFreqLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__QueryFreqLayout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__QueryFreqLayout(struct soap *soap, const struct __Xdmsdm__QueryFreqLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__QueryFreqLayout(soap, &a->Xdmsdm__QueryFreqLayout);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__QueryFreqLayout(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__QueryFreqLayout *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__QueryFreqLayout(soap, "Xdmsdm:QueryFreqLayout", -1, &a->Xdmsdm__QueryFreqLayout, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryFreqLayout * SOAP_FMAC4 soap_in___Xdmsdm__QueryFreqLayout(struct soap *soap, const char *tag, struct __Xdmsdm__QueryFreqLayout *a, const char *type)
{
	size_t soap_flag_Xdmsdm__QueryFreqLayout = 1;
	short soap_flag;
	a = (struct __Xdmsdm__QueryFreqLayout *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryFreqLayout, sizeof(struct __Xdmsdm__QueryFreqLayout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__QueryFreqLayout(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__QueryFreqLayout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__QueryFreqLayout(soap, "Xdmsdm:QueryFreqLayout", &a->Xdmsdm__QueryFreqLayout, ""))
				{	soap_flag_Xdmsdm__QueryFreqLayout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__QueryFreqLayout(struct soap *soap, const struct __Xdmsdm__QueryFreqLayout *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__QueryFreqLayout(soap, tag?tag:"-Xdmsdm:QueryFreqLayout", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryFreqLayout * SOAP_FMAC4 soap_get___Xdmsdm__QueryFreqLayout(struct soap *soap, struct __Xdmsdm__QueryFreqLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__QueryFreqLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__QueryFreqLayout * SOAP_FMAC2 soap_instantiate___Xdmsdm__QueryFreqLayout(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__QueryFreqLayout(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryFreqLayout, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryFreqLayout);
		if (size)
			*size = sizeof(struct __Xdmsdm__QueryFreqLayout);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryFreqLayout[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__QueryFreqLayout);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__QueryFreqLayout*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__QueryFreqLayout(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__QueryFreqLayout %p -> %p\n", q, p));
	*(struct __Xdmsdm__QueryFreqLayout*)p = *(struct __Xdmsdm__QueryFreqLayout*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__QueryRegionNO(struct soap *soap, struct __Xdmsdm__QueryRegionNO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__QueryRegionNO = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__QueryRegionNO(struct soap *soap, const struct __Xdmsdm__QueryRegionNO *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__QueryRegionNO(soap, &a->Xdmsdm__QueryRegionNO);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__QueryRegionNO(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__QueryRegionNO *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__QueryRegionNO(soap, "Xdmsdm:QueryRegionNO", -1, &a->Xdmsdm__QueryRegionNO, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryRegionNO * SOAP_FMAC4 soap_in___Xdmsdm__QueryRegionNO(struct soap *soap, const char *tag, struct __Xdmsdm__QueryRegionNO *a, const char *type)
{
	size_t soap_flag_Xdmsdm__QueryRegionNO = 1;
	short soap_flag;
	a = (struct __Xdmsdm__QueryRegionNO *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryRegionNO, sizeof(struct __Xdmsdm__QueryRegionNO), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__QueryRegionNO(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__QueryRegionNO && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__QueryRegionNO(soap, "Xdmsdm:QueryRegionNO", &a->Xdmsdm__QueryRegionNO, ""))
				{	soap_flag_Xdmsdm__QueryRegionNO--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__QueryRegionNO(struct soap *soap, const struct __Xdmsdm__QueryRegionNO *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__QueryRegionNO(soap, tag?tag:"-Xdmsdm:QueryRegionNO", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryRegionNO * SOAP_FMAC4 soap_get___Xdmsdm__QueryRegionNO(struct soap *soap, struct __Xdmsdm__QueryRegionNO *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__QueryRegionNO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__QueryRegionNO * SOAP_FMAC2 soap_instantiate___Xdmsdm__QueryRegionNO(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__QueryRegionNO(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryRegionNO, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryRegionNO);
		if (size)
			*size = sizeof(struct __Xdmsdm__QueryRegionNO);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryRegionNO[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__QueryRegionNO);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__QueryRegionNO*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__QueryRegionNO(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__QueryRegionNO %p -> %p\n", q, p));
	*(struct __Xdmsdm__QueryRegionNO*)p = *(struct __Xdmsdm__QueryRegionNO*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___Xdmsdm__QueryVersionInfo(struct soap *soap, struct __Xdmsdm__QueryVersionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Xdmsdm__QueryVersionInfo = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___Xdmsdm__QueryVersionInfo(struct soap *soap, const struct __Xdmsdm__QueryVersionInfo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_Xdmsdm__QueryVersionInfo(soap, &a->Xdmsdm__QueryVersionInfo);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___Xdmsdm__QueryVersionInfo(struct soap *soap, const char *tag, int id, const struct __Xdmsdm__QueryVersionInfo *a, const char *type)
{
	if (soap_out_PointerTo_Xdmsdm__QueryVersionInfo(soap, "Xdmsdm:QueryVersionInfo", -1, &a->Xdmsdm__QueryVersionInfo, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryVersionInfo * SOAP_FMAC4 soap_in___Xdmsdm__QueryVersionInfo(struct soap *soap, const char *tag, struct __Xdmsdm__QueryVersionInfo *a, const char *type)
{
	size_t soap_flag_Xdmsdm__QueryVersionInfo = 1;
	short soap_flag;
	a = (struct __Xdmsdm__QueryVersionInfo *)soap_id_enter(soap, "", a, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryVersionInfo, sizeof(struct __Xdmsdm__QueryVersionInfo), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___Xdmsdm__QueryVersionInfo(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Xdmsdm__QueryVersionInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_Xdmsdm__QueryVersionInfo(soap, "Xdmsdm:QueryVersionInfo", &a->Xdmsdm__QueryVersionInfo, ""))
				{	soap_flag_Xdmsdm__QueryVersionInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___Xdmsdm__QueryVersionInfo(struct soap *soap, const struct __Xdmsdm__QueryVersionInfo *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___Xdmsdm__QueryVersionInfo(soap, tag?tag:"-Xdmsdm:QueryVersionInfo", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __Xdmsdm__QueryVersionInfo * SOAP_FMAC4 soap_get___Xdmsdm__QueryVersionInfo(struct soap *soap, struct __Xdmsdm__QueryVersionInfo *p, const char *tag, const char *type)
{
	if ((p = soap_in___Xdmsdm__QueryVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __Xdmsdm__QueryVersionInfo * SOAP_FMAC2 soap_instantiate___Xdmsdm__QueryVersionInfo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___Xdmsdm__QueryVersionInfo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_Xdmsdm___Xdmsdm__QueryVersionInfo, n, Xdmsdm_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryVersionInfo);
		if (size)
			*size = sizeof(struct __Xdmsdm__QueryVersionInfo);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __Xdmsdm__QueryVersionInfo[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __Xdmsdm__QueryVersionInfo);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __Xdmsdm__QueryVersionInfo*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___Xdmsdm__QueryVersionInfo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __Xdmsdm__QueryVersionInfo %p -> %p\n", q, p));
	*(struct __Xdmsdm__QueryVersionInfo*)p = *(struct __Xdmsdm__QueryVersionInfo*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse(struct soap *soap, _Xdmsdm__GetMonthReportBusFreqsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__GetMonthReportBusFreqsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportBusFreqsResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse(struct soap *soap, const char *tag, _Xdmsdm__GetMonthReportBusFreqsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__GetMonthReportBusFreqsResponse **)soap_malloc(soap, sizeof(_Xdmsdm__GetMonthReportBusFreqsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__GetMonthReportBusFreqsResponse *)soap_instantiate__Xdmsdm__GetMonthReportBusFreqsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__GetMonthReportBusFreqsResponse ** p = (_Xdmsdm__GetMonthReportBusFreqsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqsResponse, sizeof(_Xdmsdm__GetMonthReportBusFreqsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse(struct soap *soap, _Xdmsdm__GetMonthReportBusFreqsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse);
	if (soap_out_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse(soap, tag?tag:"Xdmsdm:GetMonthReportBusFreqsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportBusFreqsResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse(struct soap *soap, _Xdmsdm__GetMonthReportBusFreqsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__GetMonthReportBusFreqsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, _Xdmsdm__GetMonthReportBusFreqs *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, const char *tag, int id, _Xdmsdm__GetMonthReportBusFreqs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportBusFreqs ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, const char *tag, _Xdmsdm__GetMonthReportBusFreqs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__GetMonthReportBusFreqs **)soap_malloc(soap, sizeof(_Xdmsdm__GetMonthReportBusFreqs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__GetMonthReportBusFreqs *)soap_instantiate__Xdmsdm__GetMonthReportBusFreqs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__GetMonthReportBusFreqs ** p = (_Xdmsdm__GetMonthReportBusFreqs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportBusFreqs, sizeof(_Xdmsdm__GetMonthReportBusFreqs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, _Xdmsdm__GetMonthReportBusFreqs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportBusFreqs);
	if (soap_out_PointerTo_Xdmsdm__GetMonthReportBusFreqs(soap, tag?tag:"Xdmsdm:GetMonthReportBusFreqs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportBusFreqs ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__GetMonthReportBusFreqs(struct soap *soap, _Xdmsdm__GetMonthReportBusFreqs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__GetMonthReportBusFreqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse(struct soap *soap, _Xdmsdm__SetMonthReportBusFreqsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__SetMonthReportBusFreqsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportBusFreqsResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse(struct soap *soap, const char *tag, _Xdmsdm__SetMonthReportBusFreqsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__SetMonthReportBusFreqsResponse **)soap_malloc(soap, sizeof(_Xdmsdm__SetMonthReportBusFreqsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__SetMonthReportBusFreqsResponse *)soap_instantiate__Xdmsdm__SetMonthReportBusFreqsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__SetMonthReportBusFreqsResponse ** p = (_Xdmsdm__SetMonthReportBusFreqsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqsResponse, sizeof(_Xdmsdm__SetMonthReportBusFreqsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse(struct soap *soap, _Xdmsdm__SetMonthReportBusFreqsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse);
	if (soap_out_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse(soap, tag?tag:"Xdmsdm:SetMonthReportBusFreqsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportBusFreqsResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse(struct soap *soap, _Xdmsdm__SetMonthReportBusFreqsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__SetMonthReportBusFreqsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, _Xdmsdm__SetMonthReportBusFreqs *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, const char *tag, int id, _Xdmsdm__SetMonthReportBusFreqs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportBusFreqs ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, const char *tag, _Xdmsdm__SetMonthReportBusFreqs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__SetMonthReportBusFreqs **)soap_malloc(soap, sizeof(_Xdmsdm__SetMonthReportBusFreqs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__SetMonthReportBusFreqs *)soap_instantiate__Xdmsdm__SetMonthReportBusFreqs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__SetMonthReportBusFreqs ** p = (_Xdmsdm__SetMonthReportBusFreqs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportBusFreqs, sizeof(_Xdmsdm__SetMonthReportBusFreqs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, _Xdmsdm__SetMonthReportBusFreqs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportBusFreqs);
	if (soap_out_PointerTo_Xdmsdm__SetMonthReportBusFreqs(soap, tag?tag:"Xdmsdm:SetMonthReportBusFreqs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportBusFreqs ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__SetMonthReportBusFreqs(struct soap *soap, _Xdmsdm__SetMonthReportBusFreqs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__SetMonthReportBusFreqs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse(struct soap *soap, _Xdmsdm__GetMonthReportWorkPlansResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__GetMonthReportWorkPlansResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportWorkPlansResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse(struct soap *soap, const char *tag, _Xdmsdm__GetMonthReportWorkPlansResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__GetMonthReportWorkPlansResponse **)soap_malloc(soap, sizeof(_Xdmsdm__GetMonthReportWorkPlansResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__GetMonthReportWorkPlansResponse *)soap_instantiate__Xdmsdm__GetMonthReportWorkPlansResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__GetMonthReportWorkPlansResponse ** p = (_Xdmsdm__GetMonthReportWorkPlansResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlansResponse, sizeof(_Xdmsdm__GetMonthReportWorkPlansResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse(struct soap *soap, _Xdmsdm__GetMonthReportWorkPlansResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse);
	if (soap_out_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse(soap, tag?tag:"Xdmsdm:GetMonthReportWorkPlansResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportWorkPlansResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse(struct soap *soap, _Xdmsdm__GetMonthReportWorkPlansResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__GetMonthReportWorkPlansResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, _Xdmsdm__GetMonthReportWorkPlans *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, const char *tag, int id, _Xdmsdm__GetMonthReportWorkPlans *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportWorkPlans ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, const char *tag, _Xdmsdm__GetMonthReportWorkPlans **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__GetMonthReportWorkPlans **)soap_malloc(soap, sizeof(_Xdmsdm__GetMonthReportWorkPlans *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__GetMonthReportWorkPlans *)soap_instantiate__Xdmsdm__GetMonthReportWorkPlans(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__GetMonthReportWorkPlans ** p = (_Xdmsdm__GetMonthReportWorkPlans **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__GetMonthReportWorkPlans, sizeof(_Xdmsdm__GetMonthReportWorkPlans), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, _Xdmsdm__GetMonthReportWorkPlans *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__GetMonthReportWorkPlans);
	if (soap_out_PointerTo_Xdmsdm__GetMonthReportWorkPlans(soap, tag?tag:"Xdmsdm:GetMonthReportWorkPlans", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__GetMonthReportWorkPlans ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__GetMonthReportWorkPlans(struct soap *soap, _Xdmsdm__GetMonthReportWorkPlans **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__GetMonthReportWorkPlans(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse(struct soap *soap, _Xdmsdm__SetMonthReportWorkPlansResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__SetMonthReportWorkPlansResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportWorkPlansResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse(struct soap *soap, const char *tag, _Xdmsdm__SetMonthReportWorkPlansResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__SetMonthReportWorkPlansResponse **)soap_malloc(soap, sizeof(_Xdmsdm__SetMonthReportWorkPlansResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__SetMonthReportWorkPlansResponse *)soap_instantiate__Xdmsdm__SetMonthReportWorkPlansResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__SetMonthReportWorkPlansResponse ** p = (_Xdmsdm__SetMonthReportWorkPlansResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlansResponse, sizeof(_Xdmsdm__SetMonthReportWorkPlansResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse(struct soap *soap, _Xdmsdm__SetMonthReportWorkPlansResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse);
	if (soap_out_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse(soap, tag?tag:"Xdmsdm:SetMonthReportWorkPlansResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportWorkPlansResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse(struct soap *soap, _Xdmsdm__SetMonthReportWorkPlansResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__SetMonthReportWorkPlansResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, _Xdmsdm__SetMonthReportWorkPlans *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, const char *tag, int id, _Xdmsdm__SetMonthReportWorkPlans *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportWorkPlans ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, const char *tag, _Xdmsdm__SetMonthReportWorkPlans **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__SetMonthReportWorkPlans **)soap_malloc(soap, sizeof(_Xdmsdm__SetMonthReportWorkPlans *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__SetMonthReportWorkPlans *)soap_instantiate__Xdmsdm__SetMonthReportWorkPlans(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__SetMonthReportWorkPlans ** p = (_Xdmsdm__SetMonthReportWorkPlans **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__SetMonthReportWorkPlans, sizeof(_Xdmsdm__SetMonthReportWorkPlans), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, _Xdmsdm__SetMonthReportWorkPlans *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SetMonthReportWorkPlans);
	if (soap_out_PointerTo_Xdmsdm__SetMonthReportWorkPlans(soap, tag?tag:"Xdmsdm:SetMonthReportWorkPlans", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__SetMonthReportWorkPlans ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__SetMonthReportWorkPlans(struct soap *soap, _Xdmsdm__SetMonthReportWorkPlans **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__SetMonthReportWorkPlans(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryUserInfoResponse(struct soap *soap, _Xdmsdm__QueryUserInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryUserInfoResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryUserInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryUserInfoResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryUserInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryUserInfoResponse **)soap_malloc(soap, sizeof(_Xdmsdm__QueryUserInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryUserInfoResponse *)soap_instantiate__Xdmsdm__QueryUserInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryUserInfoResponse ** p = (_Xdmsdm__QueryUserInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfoResponse, sizeof(_Xdmsdm__QueryUserInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryUserInfoResponse(struct soap *soap, _Xdmsdm__QueryUserInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserInfoResponse);
	if (soap_out_PointerTo_Xdmsdm__QueryUserInfoResponse(soap, tag?tag:"Xdmsdm:QueryUserInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryUserInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryUserInfoResponse(struct soap *soap, _Xdmsdm__QueryUserInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryUserInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryUserInfo(struct soap *soap, _Xdmsdm__QueryUserInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryUserInfo(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryUserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserInfo ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryUserInfo(struct soap *soap, const char *tag, _Xdmsdm__QueryUserInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryUserInfo **)soap_malloc(soap, sizeof(_Xdmsdm__QueryUserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryUserInfo *)soap_instantiate__Xdmsdm__QueryUserInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryUserInfo ** p = (_Xdmsdm__QueryUserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserInfo, sizeof(_Xdmsdm__QueryUserInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryUserInfo(struct soap *soap, _Xdmsdm__QueryUserInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserInfo);
	if (soap_out_PointerTo_Xdmsdm__QueryUserInfo(soap, tag?tag:"Xdmsdm:QueryUserInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryUserInfo ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryUserInfo(struct soap *soap, _Xdmsdm__QueryUserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryUserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__SendMobileMessageResponse(struct soap *soap, _Xdmsdm__SendMobileMessageResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__SendMobileMessageResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__SendMobileMessageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__SendMobileMessageResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__SendMobileMessageResponse(struct soap *soap, const char *tag, _Xdmsdm__SendMobileMessageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__SendMobileMessageResponse **)soap_malloc(soap, sizeof(_Xdmsdm__SendMobileMessageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__SendMobileMessageResponse *)soap_instantiate__Xdmsdm__SendMobileMessageResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__SendMobileMessageResponse ** p = (_Xdmsdm__SendMobileMessageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessageResponse, sizeof(_Xdmsdm__SendMobileMessageResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__SendMobileMessageResponse(struct soap *soap, _Xdmsdm__SendMobileMessageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SendMobileMessageResponse);
	if (soap_out_PointerTo_Xdmsdm__SendMobileMessageResponse(soap, tag?tag:"Xdmsdm:SendMobileMessageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__SendMobileMessageResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__SendMobileMessageResponse(struct soap *soap, _Xdmsdm__SendMobileMessageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__SendMobileMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__SendMobileMessage(struct soap *soap, _Xdmsdm__SendMobileMessage *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__SendMobileMessage(struct soap *soap, const char *tag, int id, _Xdmsdm__SendMobileMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__SendMobileMessage ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__SendMobileMessage(struct soap *soap, const char *tag, _Xdmsdm__SendMobileMessage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__SendMobileMessage **)soap_malloc(soap, sizeof(_Xdmsdm__SendMobileMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__SendMobileMessage *)soap_instantiate__Xdmsdm__SendMobileMessage(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__SendMobileMessage ** p = (_Xdmsdm__SendMobileMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__SendMobileMessage, sizeof(_Xdmsdm__SendMobileMessage), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__SendMobileMessage(struct soap *soap, _Xdmsdm__SendMobileMessage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SendMobileMessage);
	if (soap_out_PointerTo_Xdmsdm__SendMobileMessage(soap, tag?tag:"Xdmsdm:SendMobileMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__SendMobileMessage ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__SendMobileMessage(struct soap *soap, _Xdmsdm__SendMobileMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__SendMobileMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryUserMobileNOResponse(struct soap *soap, _Xdmsdm__QueryUserMobileNOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryUserMobileNOResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryUserMobileNOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserMobileNOResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryUserMobileNOResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryUserMobileNOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryUserMobileNOResponse **)soap_malloc(soap, sizeof(_Xdmsdm__QueryUserMobileNOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryUserMobileNOResponse *)soap_instantiate__Xdmsdm__QueryUserMobileNOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryUserMobileNOResponse ** p = (_Xdmsdm__QueryUserMobileNOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNOResponse, sizeof(_Xdmsdm__QueryUserMobileNOResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryUserMobileNOResponse(struct soap *soap, _Xdmsdm__QueryUserMobileNOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserMobileNOResponse);
	if (soap_out_PointerTo_Xdmsdm__QueryUserMobileNOResponse(soap, tag?tag:"Xdmsdm:QueryUserMobileNOResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryUserMobileNOResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryUserMobileNOResponse(struct soap *soap, _Xdmsdm__QueryUserMobileNOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryUserMobileNOResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryUserMobileNO(struct soap *soap, _Xdmsdm__QueryUserMobileNO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryUserMobileNO(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryUserMobileNO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserMobileNO ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryUserMobileNO(struct soap *soap, const char *tag, _Xdmsdm__QueryUserMobileNO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryUserMobileNO **)soap_malloc(soap, sizeof(_Xdmsdm__QueryUserMobileNO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryUserMobileNO *)soap_instantiate__Xdmsdm__QueryUserMobileNO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryUserMobileNO ** p = (_Xdmsdm__QueryUserMobileNO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserMobileNO, sizeof(_Xdmsdm__QueryUserMobileNO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryUserMobileNO(struct soap *soap, _Xdmsdm__QueryUserMobileNO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserMobileNO);
	if (soap_out_PointerTo_Xdmsdm__QueryUserMobileNO(soap, tag?tag:"Xdmsdm:QueryUserMobileNO", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryUserMobileNO ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryUserMobileNO(struct soap *soap, _Xdmsdm__QueryUserMobileNO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryUserMobileNO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryStandardTimeResponse(struct soap *soap, _Xdmsdm__QueryStandardTimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryStandardTimeResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryStandardTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryStandardTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryStandardTimeResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryStandardTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryStandardTimeResponse **)soap_malloc(soap, sizeof(_Xdmsdm__QueryStandardTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryStandardTimeResponse *)soap_instantiate__Xdmsdm__QueryStandardTimeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryStandardTimeResponse ** p = (_Xdmsdm__QueryStandardTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTimeResponse, sizeof(_Xdmsdm__QueryStandardTimeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryStandardTimeResponse(struct soap *soap, _Xdmsdm__QueryStandardTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryStandardTimeResponse);
	if (soap_out_PointerTo_Xdmsdm__QueryStandardTimeResponse(soap, tag?tag:"Xdmsdm:QueryStandardTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryStandardTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryStandardTimeResponse(struct soap *soap, _Xdmsdm__QueryStandardTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryStandardTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryStandardTime(struct soap *soap, _Xdmsdm__QueryStandardTime *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryStandardTime(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryStandardTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryStandardTime ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryStandardTime(struct soap *soap, const char *tag, _Xdmsdm__QueryStandardTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryStandardTime **)soap_malloc(soap, sizeof(_Xdmsdm__QueryStandardTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryStandardTime *)soap_instantiate__Xdmsdm__QueryStandardTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryStandardTime ** p = (_Xdmsdm__QueryStandardTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryStandardTime, sizeof(_Xdmsdm__QueryStandardTime), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryStandardTime(struct soap *soap, _Xdmsdm__QueryStandardTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryStandardTime);
	if (soap_out_PointerTo_Xdmsdm__QueryStandardTime(soap, tag?tag:"Xdmsdm:QueryStandardTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryStandardTime ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryStandardTime(struct soap *soap, _Xdmsdm__QueryStandardTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryStandardTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__SubmitOperateLogResponse(struct soap *soap, _Xdmsdm__SubmitOperateLogResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__SubmitOperateLogResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__SubmitOperateLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__SubmitOperateLogResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__SubmitOperateLogResponse(struct soap *soap, const char *tag, _Xdmsdm__SubmitOperateLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__SubmitOperateLogResponse **)soap_malloc(soap, sizeof(_Xdmsdm__SubmitOperateLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__SubmitOperateLogResponse *)soap_instantiate__Xdmsdm__SubmitOperateLogResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__SubmitOperateLogResponse ** p = (_Xdmsdm__SubmitOperateLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLogResponse, sizeof(_Xdmsdm__SubmitOperateLogResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__SubmitOperateLogResponse(struct soap *soap, _Xdmsdm__SubmitOperateLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SubmitOperateLogResponse);
	if (soap_out_PointerTo_Xdmsdm__SubmitOperateLogResponse(soap, tag?tag:"Xdmsdm:SubmitOperateLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__SubmitOperateLogResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__SubmitOperateLogResponse(struct soap *soap, _Xdmsdm__SubmitOperateLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__SubmitOperateLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__SubmitOperateLog(struct soap *soap, _Xdmsdm__SubmitOperateLog *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__SubmitOperateLog(struct soap *soap, const char *tag, int id, _Xdmsdm__SubmitOperateLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__SubmitOperateLog ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__SubmitOperateLog(struct soap *soap, const char *tag, _Xdmsdm__SubmitOperateLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__SubmitOperateLog **)soap_malloc(soap, sizeof(_Xdmsdm__SubmitOperateLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__SubmitOperateLog *)soap_instantiate__Xdmsdm__SubmitOperateLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__SubmitOperateLog ** p = (_Xdmsdm__SubmitOperateLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__SubmitOperateLog, sizeof(_Xdmsdm__SubmitOperateLog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__SubmitOperateLog(struct soap *soap, _Xdmsdm__SubmitOperateLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__SubmitOperateLog);
	if (soap_out_PointerTo_Xdmsdm__SubmitOperateLog(soap, tag?tag:"Xdmsdm:SubmitOperateLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__SubmitOperateLog ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__SubmitOperateLog(struct soap *soap, _Xdmsdm__SubmitOperateLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__SubmitOperateLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse(struct soap *soap, _Xdmsdm__QueryUserLicenseFuncResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryUserLicenseFuncResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserLicenseFuncResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryUserLicenseFuncResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryUserLicenseFuncResponse **)soap_malloc(soap, sizeof(_Xdmsdm__QueryUserLicenseFuncResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryUserLicenseFuncResponse *)soap_instantiate__Xdmsdm__QueryUserLicenseFuncResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryUserLicenseFuncResponse ** p = (_Xdmsdm__QueryUserLicenseFuncResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFuncResponse, sizeof(_Xdmsdm__QueryUserLicenseFuncResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse(struct soap *soap, _Xdmsdm__QueryUserLicenseFuncResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse);
	if (soap_out_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse(soap, tag?tag:"Xdmsdm:QueryUserLicenseFuncResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryUserLicenseFuncResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse(struct soap *soap, _Xdmsdm__QueryUserLicenseFuncResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryUserLicenseFuncResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryUserLicenseFunc(struct soap *soap, _Xdmsdm__QueryUserLicenseFunc *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryUserLicenseFunc(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryUserLicenseFunc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryUserLicenseFunc ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryUserLicenseFunc(struct soap *soap, const char *tag, _Xdmsdm__QueryUserLicenseFunc **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryUserLicenseFunc **)soap_malloc(soap, sizeof(_Xdmsdm__QueryUserLicenseFunc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryUserLicenseFunc *)soap_instantiate__Xdmsdm__QueryUserLicenseFunc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryUserLicenseFunc ** p = (_Xdmsdm__QueryUserLicenseFunc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryUserLicenseFunc, sizeof(_Xdmsdm__QueryUserLicenseFunc), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryUserLicenseFunc(struct soap *soap, _Xdmsdm__QueryUserLicenseFunc *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryUserLicenseFunc);
	if (soap_out_PointerTo_Xdmsdm__QueryUserLicenseFunc(soap, tag?tag:"Xdmsdm:QueryUserLicenseFunc", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryUserLicenseFunc ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryUserLicenseFunc(struct soap *soap, _Xdmsdm__QueryUserLicenseFunc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryUserLicenseFunc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse(struct soap *soap, _Xdmsdm__AuthUserLicenseFuncResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__AuthUserLicenseFuncResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUserLicenseFuncResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse(struct soap *soap, const char *tag, _Xdmsdm__AuthUserLicenseFuncResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__AuthUserLicenseFuncResponse **)soap_malloc(soap, sizeof(_Xdmsdm__AuthUserLicenseFuncResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__AuthUserLicenseFuncResponse *)soap_instantiate__Xdmsdm__AuthUserLicenseFuncResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__AuthUserLicenseFuncResponse ** p = (_Xdmsdm__AuthUserLicenseFuncResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFuncResponse, sizeof(_Xdmsdm__AuthUserLicenseFuncResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse(struct soap *soap, _Xdmsdm__AuthUserLicenseFuncResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse);
	if (soap_out_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse(soap, tag?tag:"Xdmsdm:AuthUserLicenseFuncResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__AuthUserLicenseFuncResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse(struct soap *soap, _Xdmsdm__AuthUserLicenseFuncResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__AuthUserLicenseFuncResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__AuthUserLicenseFunc(struct soap *soap, _Xdmsdm__AuthUserLicenseFunc *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__AuthUserLicenseFunc(struct soap *soap, const char *tag, int id, _Xdmsdm__AuthUserLicenseFunc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUserLicenseFunc ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__AuthUserLicenseFunc(struct soap *soap, const char *tag, _Xdmsdm__AuthUserLicenseFunc **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__AuthUserLicenseFunc **)soap_malloc(soap, sizeof(_Xdmsdm__AuthUserLicenseFunc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__AuthUserLicenseFunc *)soap_instantiate__Xdmsdm__AuthUserLicenseFunc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__AuthUserLicenseFunc ** p = (_Xdmsdm__AuthUserLicenseFunc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserLicenseFunc, sizeof(_Xdmsdm__AuthUserLicenseFunc), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__AuthUserLicenseFunc(struct soap *soap, _Xdmsdm__AuthUserLicenseFunc *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserLicenseFunc);
	if (soap_out_PointerTo_Xdmsdm__AuthUserLicenseFunc(soap, tag?tag:"Xdmsdm:AuthUserLicenseFunc", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__AuthUserLicenseFunc ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__AuthUserLicenseFunc(struct soap *soap, _Xdmsdm__AuthUserLicenseFunc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__AuthUserLicenseFunc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__AuthUserResponse(struct soap *soap, _Xdmsdm__AuthUserResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__AuthUserResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__AuthUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUserResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__AuthUserResponse(struct soap *soap, const char *tag, _Xdmsdm__AuthUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__AuthUserResponse **)soap_malloc(soap, sizeof(_Xdmsdm__AuthUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__AuthUserResponse *)soap_instantiate__Xdmsdm__AuthUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__AuthUserResponse ** p = (_Xdmsdm__AuthUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUserResponse, sizeof(_Xdmsdm__AuthUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__AuthUserResponse(struct soap *soap, _Xdmsdm__AuthUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUserResponse);
	if (soap_out_PointerTo_Xdmsdm__AuthUserResponse(soap, tag?tag:"Xdmsdm:AuthUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__AuthUserResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__AuthUserResponse(struct soap *soap, _Xdmsdm__AuthUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__AuthUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__AuthUser(struct soap *soap, _Xdmsdm__AuthUser *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__AuthUser(struct soap *soap, const char *tag, int id, _Xdmsdm__AuthUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__AuthUser ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__AuthUser(struct soap *soap, const char *tag, _Xdmsdm__AuthUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__AuthUser **)soap_malloc(soap, sizeof(_Xdmsdm__AuthUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__AuthUser *)soap_instantiate__Xdmsdm__AuthUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__AuthUser ** p = (_Xdmsdm__AuthUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__AuthUser, sizeof(_Xdmsdm__AuthUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__AuthUser(struct soap *soap, _Xdmsdm__AuthUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__AuthUser);
	if (soap_out_PointerTo_Xdmsdm__AuthUser(soap, tag?tag:"Xdmsdm:AuthUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__AuthUser ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__AuthUser(struct soap *soap, _Xdmsdm__AuthUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__AuthUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryWebServiceResponse(struct soap *soap, _Xdmsdm__QueryWebServiceResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryWebServiceResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryWebServiceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryWebServiceResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryWebServiceResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryWebServiceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryWebServiceResponse **)soap_malloc(soap, sizeof(_Xdmsdm__QueryWebServiceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryWebServiceResponse *)soap_instantiate__Xdmsdm__QueryWebServiceResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryWebServiceResponse ** p = (_Xdmsdm__QueryWebServiceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebServiceResponse, sizeof(_Xdmsdm__QueryWebServiceResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryWebServiceResponse(struct soap *soap, _Xdmsdm__QueryWebServiceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryWebServiceResponse);
	if (soap_out_PointerTo_Xdmsdm__QueryWebServiceResponse(soap, tag?tag:"Xdmsdm:QueryWebServiceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryWebServiceResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryWebServiceResponse(struct soap *soap, _Xdmsdm__QueryWebServiceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryWebServiceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryWebService(struct soap *soap, _Xdmsdm__QueryWebService *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryWebService(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryWebService *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryWebService ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryWebService(struct soap *soap, const char *tag, _Xdmsdm__QueryWebService **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryWebService **)soap_malloc(soap, sizeof(_Xdmsdm__QueryWebService *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryWebService *)soap_instantiate__Xdmsdm__QueryWebService(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryWebService ** p = (_Xdmsdm__QueryWebService **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryWebService, sizeof(_Xdmsdm__QueryWebService), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryWebService(struct soap *soap, _Xdmsdm__QueryWebService *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryWebService);
	if (soap_out_PointerTo_Xdmsdm__QueryWebService(soap, tag?tag:"Xdmsdm:QueryWebService", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryWebService ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryWebService(struct soap *soap, _Xdmsdm__QueryWebService **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryWebService(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryFreqLayoutResponse(struct soap *soap, _Xdmsdm__QueryFreqLayoutResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryFreqLayoutResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryFreqLayoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryFreqLayoutResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryFreqLayoutResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryFreqLayoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryFreqLayoutResponse **)soap_malloc(soap, sizeof(_Xdmsdm__QueryFreqLayoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryFreqLayoutResponse *)soap_instantiate__Xdmsdm__QueryFreqLayoutResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryFreqLayoutResponse ** p = (_Xdmsdm__QueryFreqLayoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayoutResponse, sizeof(_Xdmsdm__QueryFreqLayoutResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryFreqLayoutResponse(struct soap *soap, _Xdmsdm__QueryFreqLayoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryFreqLayoutResponse);
	if (soap_out_PointerTo_Xdmsdm__QueryFreqLayoutResponse(soap, tag?tag:"Xdmsdm:QueryFreqLayoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryFreqLayoutResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryFreqLayoutResponse(struct soap *soap, _Xdmsdm__QueryFreqLayoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryFreqLayoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryFreqLayout(struct soap *soap, _Xdmsdm__QueryFreqLayout *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryFreqLayout(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryFreqLayout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryFreqLayout ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryFreqLayout(struct soap *soap, const char *tag, _Xdmsdm__QueryFreqLayout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryFreqLayout **)soap_malloc(soap, sizeof(_Xdmsdm__QueryFreqLayout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryFreqLayout *)soap_instantiate__Xdmsdm__QueryFreqLayout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryFreqLayout ** p = (_Xdmsdm__QueryFreqLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryFreqLayout, sizeof(_Xdmsdm__QueryFreqLayout), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryFreqLayout(struct soap *soap, _Xdmsdm__QueryFreqLayout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryFreqLayout);
	if (soap_out_PointerTo_Xdmsdm__QueryFreqLayout(soap, tag?tag:"Xdmsdm:QueryFreqLayout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryFreqLayout ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryFreqLayout(struct soap *soap, _Xdmsdm__QueryFreqLayout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryFreqLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryRegionNOResponse(struct soap *soap, _Xdmsdm__QueryRegionNOResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryRegionNOResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryRegionNOResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryRegionNOResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryRegionNOResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryRegionNOResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryRegionNOResponse **)soap_malloc(soap, sizeof(_Xdmsdm__QueryRegionNOResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryRegionNOResponse *)soap_instantiate__Xdmsdm__QueryRegionNOResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryRegionNOResponse ** p = (_Xdmsdm__QueryRegionNOResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNOResponse, sizeof(_Xdmsdm__QueryRegionNOResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryRegionNOResponse(struct soap *soap, _Xdmsdm__QueryRegionNOResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryRegionNOResponse);
	if (soap_out_PointerTo_Xdmsdm__QueryRegionNOResponse(soap, tag?tag:"Xdmsdm:QueryRegionNOResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryRegionNOResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryRegionNOResponse(struct soap *soap, _Xdmsdm__QueryRegionNOResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryRegionNOResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryRegionNO(struct soap *soap, _Xdmsdm__QueryRegionNO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryRegionNO(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryRegionNO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryRegionNO ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryRegionNO(struct soap *soap, const char *tag, _Xdmsdm__QueryRegionNO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryRegionNO **)soap_malloc(soap, sizeof(_Xdmsdm__QueryRegionNO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryRegionNO *)soap_instantiate__Xdmsdm__QueryRegionNO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryRegionNO ** p = (_Xdmsdm__QueryRegionNO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryRegionNO, sizeof(_Xdmsdm__QueryRegionNO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryRegionNO(struct soap *soap, _Xdmsdm__QueryRegionNO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryRegionNO);
	if (soap_out_PointerTo_Xdmsdm__QueryRegionNO(soap, tag?tag:"Xdmsdm:QueryRegionNO", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryRegionNO ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryRegionNO(struct soap *soap, _Xdmsdm__QueryRegionNO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryRegionNO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryVersionInfoResponse(struct soap *soap, _Xdmsdm__QueryVersionInfoResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryVersionInfoResponse(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryVersionInfoResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryVersionInfoResponse ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryVersionInfoResponse(struct soap *soap, const char *tag, _Xdmsdm__QueryVersionInfoResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryVersionInfoResponse **)soap_malloc(soap, sizeof(_Xdmsdm__QueryVersionInfoResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryVersionInfoResponse *)soap_instantiate__Xdmsdm__QueryVersionInfoResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryVersionInfoResponse ** p = (_Xdmsdm__QueryVersionInfoResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfoResponse, sizeof(_Xdmsdm__QueryVersionInfoResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryVersionInfoResponse(struct soap *soap, _Xdmsdm__QueryVersionInfoResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryVersionInfoResponse);
	if (soap_out_PointerTo_Xdmsdm__QueryVersionInfoResponse(soap, tag?tag:"Xdmsdm:QueryVersionInfoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryVersionInfoResponse ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryVersionInfoResponse(struct soap *soap, _Xdmsdm__QueryVersionInfoResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryVersionInfoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_Xdmsdm__QueryVersionInfo(struct soap *soap, _Xdmsdm__QueryVersionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_Xdmsdm__QueryVersionInfo(struct soap *soap, const char *tag, int id, _Xdmsdm__QueryVersionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _Xdmsdm__QueryVersionInfo ** SOAP_FMAC4 soap_in_PointerTo_Xdmsdm__QueryVersionInfo(struct soap *soap, const char *tag, _Xdmsdm__QueryVersionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_Xdmsdm__QueryVersionInfo **)soap_malloc(soap, sizeof(_Xdmsdm__QueryVersionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_Xdmsdm__QueryVersionInfo *)soap_instantiate__Xdmsdm__QueryVersionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_Xdmsdm__QueryVersionInfo ** p = (_Xdmsdm__QueryVersionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm__Xdmsdm__QueryVersionInfo, sizeof(_Xdmsdm__QueryVersionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_Xdmsdm__QueryVersionInfo(struct soap *soap, _Xdmsdm__QueryVersionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerTo_Xdmsdm__QueryVersionInfo);
	if (soap_out_PointerTo_Xdmsdm__QueryVersionInfo(soap, tag?tag:"Xdmsdm:QueryVersionInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _Xdmsdm__QueryVersionInfo ** SOAP_FMAC4 soap_get_PointerTo_Xdmsdm__QueryVersionInfo(struct soap *soap, _Xdmsdm__QueryVersionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_Xdmsdm__QueryVersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__MonthReportBusFreqArray(struct soap *soap, Xdmsdm__MonthReportBusFreqArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__MonthReportBusFreqArray(struct soap *soap, const char *tag, int id, Xdmsdm__MonthReportBusFreqArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportBusFreqArray ** SOAP_FMAC4 soap_in_PointerToXdmsdm__MonthReportBusFreqArray(struct soap *soap, const char *tag, Xdmsdm__MonthReportBusFreqArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__MonthReportBusFreqArray **)soap_malloc(soap, sizeof(Xdmsdm__MonthReportBusFreqArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__MonthReportBusFreqArray *)soap_instantiate_Xdmsdm__MonthReportBusFreqArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__MonthReportBusFreqArray ** p = (Xdmsdm__MonthReportBusFreqArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreqArray, sizeof(Xdmsdm__MonthReportBusFreqArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__MonthReportBusFreqArray(struct soap *soap, Xdmsdm__MonthReportBusFreqArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreqArray);
	if (soap_out_PointerToXdmsdm__MonthReportBusFreqArray(soap, tag?tag:"Xdmsdm:MonthReportBusFreqArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__MonthReportBusFreqArray ** SOAP_FMAC4 soap_get_PointerToXdmsdm__MonthReportBusFreqArray(struct soap *soap, Xdmsdm__MonthReportBusFreqArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__MonthReportBusFreqArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__MonthReportWorkPlanArray(struct soap *soap, Xdmsdm__MonthReportWorkPlanArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__MonthReportWorkPlanArray(struct soap *soap, const char *tag, int id, Xdmsdm__MonthReportWorkPlanArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportWorkPlanArray ** SOAP_FMAC4 soap_in_PointerToXdmsdm__MonthReportWorkPlanArray(struct soap *soap, const char *tag, Xdmsdm__MonthReportWorkPlanArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__MonthReportWorkPlanArray **)soap_malloc(soap, sizeof(Xdmsdm__MonthReportWorkPlanArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__MonthReportWorkPlanArray *)soap_instantiate_Xdmsdm__MonthReportWorkPlanArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__MonthReportWorkPlanArray ** p = (Xdmsdm__MonthReportWorkPlanArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlanArray, sizeof(Xdmsdm__MonthReportWorkPlanArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__MonthReportWorkPlanArray(struct soap *soap, Xdmsdm__MonthReportWorkPlanArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlanArray);
	if (soap_out_PointerToXdmsdm__MonthReportWorkPlanArray(soap, tag?tag:"Xdmsdm:MonthReportWorkPlanArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__MonthReportWorkPlanArray ** SOAP_FMAC4 soap_get_PointerToXdmsdm__MonthReportWorkPlanArray(struct soap *soap, Xdmsdm__MonthReportWorkPlanArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__MonthReportWorkPlanArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__UserInfoArray(struct soap *soap, Xdmsdm__UserInfoArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__UserInfoArray(struct soap *soap, const char *tag, int id, Xdmsdm__UserInfoArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__UserInfoArray ** SOAP_FMAC4 soap_in_PointerToXdmsdm__UserInfoArray(struct soap *soap, const char *tag, Xdmsdm__UserInfoArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__UserInfoArray **)soap_malloc(soap, sizeof(Xdmsdm__UserInfoArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__UserInfoArray *)soap_instantiate_Xdmsdm__UserInfoArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__UserInfoArray ** p = (Xdmsdm__UserInfoArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfoArray, sizeof(Xdmsdm__UserInfoArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__UserInfoArray(struct soap *soap, Xdmsdm__UserInfoArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfoArray);
	if (soap_out_PointerToXdmsdm__UserInfoArray(soap, tag?tag:"Xdmsdm:UserInfoArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__UserInfoArray ** SOAP_FMAC4 soap_get_PointerToXdmsdm__UserInfoArray(struct soap *soap, Xdmsdm__UserInfoArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__UserInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__LicenseFuncArray(struct soap *soap, Xdmsdm__LicenseFuncArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__LicenseFuncArray(struct soap *soap, const char *tag, int id, Xdmsdm__LicenseFuncArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__LicenseFuncArray ** SOAP_FMAC4 soap_in_PointerToXdmsdm__LicenseFuncArray(struct soap *soap, const char *tag, Xdmsdm__LicenseFuncArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__LicenseFuncArray **)soap_malloc(soap, sizeof(Xdmsdm__LicenseFuncArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__LicenseFuncArray *)soap_instantiate_Xdmsdm__LicenseFuncArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__LicenseFuncArray ** p = (Xdmsdm__LicenseFuncArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFuncArray, sizeof(Xdmsdm__LicenseFuncArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__LicenseFuncArray(struct soap *soap, Xdmsdm__LicenseFuncArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFuncArray);
	if (soap_out_PointerToXdmsdm__LicenseFuncArray(soap, tag?tag:"Xdmsdm:LicenseFuncArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__LicenseFuncArray ** SOAP_FMAC4 soap_get_PointerToXdmsdm__LicenseFuncArray(struct soap *soap, Xdmsdm__LicenseFuncArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__LicenseFuncArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__WebServiceInfoArray(struct soap *soap, Xdmsdm__WebServiceInfoArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__WebServiceInfoArray(struct soap *soap, const char *tag, int id, Xdmsdm__WebServiceInfoArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__WebServiceInfoArray ** SOAP_FMAC4 soap_in_PointerToXdmsdm__WebServiceInfoArray(struct soap *soap, const char *tag, Xdmsdm__WebServiceInfoArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__WebServiceInfoArray **)soap_malloc(soap, sizeof(Xdmsdm__WebServiceInfoArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__WebServiceInfoArray *)soap_instantiate_Xdmsdm__WebServiceInfoArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__WebServiceInfoArray ** p = (Xdmsdm__WebServiceInfoArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfoArray, sizeof(Xdmsdm__WebServiceInfoArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__WebServiceInfoArray(struct soap *soap, Xdmsdm__WebServiceInfoArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfoArray);
	if (soap_out_PointerToXdmsdm__WebServiceInfoArray(soap, tag?tag:"Xdmsdm:WebServiceInfoArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__WebServiceInfoArray ** SOAP_FMAC4 soap_get_PointerToXdmsdm__WebServiceInfoArray(struct soap *soap, Xdmsdm__WebServiceInfoArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__WebServiceInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__FreqLayoutArray(struct soap *soap, Xdmsdm__FreqLayoutArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__FreqLayoutArray(struct soap *soap, const char *tag, int id, Xdmsdm__FreqLayoutArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__FreqLayoutArray ** SOAP_FMAC4 soap_in_PointerToXdmsdm__FreqLayoutArray(struct soap *soap, const char *tag, Xdmsdm__FreqLayoutArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__FreqLayoutArray **)soap_malloc(soap, sizeof(Xdmsdm__FreqLayoutArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__FreqLayoutArray *)soap_instantiate_Xdmsdm__FreqLayoutArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__FreqLayoutArray ** p = (Xdmsdm__FreqLayoutArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayoutArray, sizeof(Xdmsdm__FreqLayoutArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__FreqLayoutArray(struct soap *soap, Xdmsdm__FreqLayoutArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayoutArray);
	if (soap_out_PointerToXdmsdm__FreqLayoutArray(soap, tag?tag:"Xdmsdm:FreqLayoutArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__FreqLayoutArray ** SOAP_FMAC4 soap_get_PointerToXdmsdm__FreqLayoutArray(struct soap *soap, Xdmsdm__FreqLayoutArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__FreqLayoutArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__RegionNOArray(struct soap *soap, Xdmsdm__RegionNOArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__RegionNOArray(struct soap *soap, const char *tag, int id, Xdmsdm__RegionNOArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__RegionNOArray ** SOAP_FMAC4 soap_in_PointerToXdmsdm__RegionNOArray(struct soap *soap, const char *tag, Xdmsdm__RegionNOArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__RegionNOArray **)soap_malloc(soap, sizeof(Xdmsdm__RegionNOArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__RegionNOArray *)soap_instantiate_Xdmsdm__RegionNOArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__RegionNOArray ** p = (Xdmsdm__RegionNOArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNOArray, sizeof(Xdmsdm__RegionNOArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__RegionNOArray(struct soap *soap, Xdmsdm__RegionNOArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNOArray);
	if (soap_out_PointerToXdmsdm__RegionNOArray(soap, tag?tag:"Xdmsdm:RegionNOArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__RegionNOArray ** SOAP_FMAC4 soap_get_PointerToXdmsdm__RegionNOArray(struct soap *soap, Xdmsdm__RegionNOArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__RegionNOArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__VersionInfoArray(struct soap *soap, Xdmsdm__VersionInfoArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__VersionInfoArray(struct soap *soap, const char *tag, int id, Xdmsdm__VersionInfoArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__VersionInfoArray ** SOAP_FMAC4 soap_in_PointerToXdmsdm__VersionInfoArray(struct soap *soap, const char *tag, Xdmsdm__VersionInfoArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__VersionInfoArray **)soap_malloc(soap, sizeof(Xdmsdm__VersionInfoArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__VersionInfoArray *)soap_instantiate_Xdmsdm__VersionInfoArray(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__VersionInfoArray ** p = (Xdmsdm__VersionInfoArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfoArray, sizeof(Xdmsdm__VersionInfoArray), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__VersionInfoArray(struct soap *soap, Xdmsdm__VersionInfoArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfoArray);
	if (soap_out_PointerToXdmsdm__VersionInfoArray(soap, tag?tag:"Xdmsdm:VersionInfoArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__VersionInfoArray ** SOAP_FMAC4 soap_get_PointerToXdmsdm__VersionInfoArray(struct soap *soap, Xdmsdm__VersionInfoArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__VersionInfoArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToXdmsdm__MonthReportBusFreq(struct soap *soap, Xdmsdm__MonthReportBusFreq **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreq))
		soap_serialize_PointerToXdmsdm__MonthReportBusFreq(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToXdmsdm__MonthReportBusFreq(struct soap *soap, const char *tag, int id, Xdmsdm__MonthReportBusFreq **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreq);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToXdmsdm__MonthReportBusFreq(soap, tag, id, *a, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportBusFreq *** SOAP_FMAC4 soap_in_PointerToPointerToXdmsdm__MonthReportBusFreq(struct soap *soap, const char *tag, Xdmsdm__MonthReportBusFreq ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__MonthReportBusFreq ***)soap_malloc(soap, sizeof(Xdmsdm__MonthReportBusFreq **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToXdmsdm__MonthReportBusFreq(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (Xdmsdm__MonthReportBusFreq ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreq, sizeof(Xdmsdm__MonthReportBusFreq *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToXdmsdm__MonthReportBusFreq(struct soap *soap, Xdmsdm__MonthReportBusFreq **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__MonthReportBusFreq);
	if (soap_out_PointerToPointerToXdmsdm__MonthReportBusFreq(soap, tag?tag:"Xdmsdm:MonthReportBusFreq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__MonthReportBusFreq *** SOAP_FMAC4 soap_get_PointerToPointerToXdmsdm__MonthReportBusFreq(struct soap *soap, Xdmsdm__MonthReportBusFreq ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToXdmsdm__MonthReportBusFreq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__MonthReportBusFreq(struct soap *soap, Xdmsdm__MonthReportBusFreq *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__MonthReportBusFreq(struct soap *soap, const char *tag, int id, Xdmsdm__MonthReportBusFreq *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportBusFreq ** SOAP_FMAC4 soap_in_PointerToXdmsdm__MonthReportBusFreq(struct soap *soap, const char *tag, Xdmsdm__MonthReportBusFreq **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__MonthReportBusFreq **)soap_malloc(soap, sizeof(Xdmsdm__MonthReportBusFreq *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__MonthReportBusFreq *)soap_instantiate_Xdmsdm__MonthReportBusFreq(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__MonthReportBusFreq ** p = (Xdmsdm__MonthReportBusFreq **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportBusFreq, sizeof(Xdmsdm__MonthReportBusFreq), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__MonthReportBusFreq(struct soap *soap, Xdmsdm__MonthReportBusFreq *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportBusFreq);
	if (soap_out_PointerToXdmsdm__MonthReportBusFreq(soap, tag?tag:"Xdmsdm:MonthReportBusFreq", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__MonthReportBusFreq ** SOAP_FMAC4 soap_get_PointerToXdmsdm__MonthReportBusFreq(struct soap *soap, Xdmsdm__MonthReportBusFreq **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__MonthReportBusFreq(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToXdmsdm__MonthReportWorkPlan(struct soap *soap, Xdmsdm__MonthReportWorkPlan **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlan))
		soap_serialize_PointerToXdmsdm__MonthReportWorkPlan(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToXdmsdm__MonthReportWorkPlan(struct soap *soap, const char *tag, int id, Xdmsdm__MonthReportWorkPlan **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlan);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToXdmsdm__MonthReportWorkPlan(soap, tag, id, *a, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportWorkPlan *** SOAP_FMAC4 soap_in_PointerToPointerToXdmsdm__MonthReportWorkPlan(struct soap *soap, const char *tag, Xdmsdm__MonthReportWorkPlan ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__MonthReportWorkPlan ***)soap_malloc(soap, sizeof(Xdmsdm__MonthReportWorkPlan **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToXdmsdm__MonthReportWorkPlan(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (Xdmsdm__MonthReportWorkPlan ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlan, sizeof(Xdmsdm__MonthReportWorkPlan *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToXdmsdm__MonthReportWorkPlan(struct soap *soap, Xdmsdm__MonthReportWorkPlan **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__MonthReportWorkPlan);
	if (soap_out_PointerToPointerToXdmsdm__MonthReportWorkPlan(soap, tag?tag:"Xdmsdm:MonthReportWorkPlan", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__MonthReportWorkPlan *** SOAP_FMAC4 soap_get_PointerToPointerToXdmsdm__MonthReportWorkPlan(struct soap *soap, Xdmsdm__MonthReportWorkPlan ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToXdmsdm__MonthReportWorkPlan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__MonthReportWorkPlan(struct soap *soap, Xdmsdm__MonthReportWorkPlan *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__MonthReportWorkPlan(struct soap *soap, const char *tag, int id, Xdmsdm__MonthReportWorkPlan *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__MonthReportWorkPlan ** SOAP_FMAC4 soap_in_PointerToXdmsdm__MonthReportWorkPlan(struct soap *soap, const char *tag, Xdmsdm__MonthReportWorkPlan **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__MonthReportWorkPlan **)soap_malloc(soap, sizeof(Xdmsdm__MonthReportWorkPlan *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__MonthReportWorkPlan *)soap_instantiate_Xdmsdm__MonthReportWorkPlan(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__MonthReportWorkPlan ** p = (Xdmsdm__MonthReportWorkPlan **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__MonthReportWorkPlan, sizeof(Xdmsdm__MonthReportWorkPlan), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__MonthReportWorkPlan(struct soap *soap, Xdmsdm__MonthReportWorkPlan *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__MonthReportWorkPlan);
	if (soap_out_PointerToXdmsdm__MonthReportWorkPlan(soap, tag?tag:"Xdmsdm:MonthReportWorkPlan", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__MonthReportWorkPlan ** SOAP_FMAC4 soap_get_PointerToXdmsdm__MonthReportWorkPlan(struct soap *soap, Xdmsdm__MonthReportWorkPlan **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__MonthReportWorkPlan(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToXdmsdm__LicenseFunc(struct soap *soap, Xdmsdm__LicenseFunc **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFunc))
		soap_serialize_PointerToXdmsdm__LicenseFunc(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToXdmsdm__LicenseFunc(struct soap *soap, const char *tag, int id, Xdmsdm__LicenseFunc **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFunc);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToXdmsdm__LicenseFunc(soap, tag, id, *a, type);
}

SOAP_FMAC3 Xdmsdm__LicenseFunc *** SOAP_FMAC4 soap_in_PointerToPointerToXdmsdm__LicenseFunc(struct soap *soap, const char *tag, Xdmsdm__LicenseFunc ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__LicenseFunc ***)soap_malloc(soap, sizeof(Xdmsdm__LicenseFunc **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToXdmsdm__LicenseFunc(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (Xdmsdm__LicenseFunc ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFunc, sizeof(Xdmsdm__LicenseFunc *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToXdmsdm__LicenseFunc(struct soap *soap, Xdmsdm__LicenseFunc **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__LicenseFunc);
	if (soap_out_PointerToPointerToXdmsdm__LicenseFunc(soap, tag?tag:"Xdmsdm:LicenseFunc", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__LicenseFunc *** SOAP_FMAC4 soap_get_PointerToPointerToXdmsdm__LicenseFunc(struct soap *soap, Xdmsdm__LicenseFunc ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToXdmsdm__LicenseFunc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__LicenseFunc(struct soap *soap, Xdmsdm__LicenseFunc *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__LicenseFunc(struct soap *soap, const char *tag, int id, Xdmsdm__LicenseFunc *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__LicenseFunc ** SOAP_FMAC4 soap_in_PointerToXdmsdm__LicenseFunc(struct soap *soap, const char *tag, Xdmsdm__LicenseFunc **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__LicenseFunc **)soap_malloc(soap, sizeof(Xdmsdm__LicenseFunc *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__LicenseFunc *)soap_instantiate_Xdmsdm__LicenseFunc(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__LicenseFunc ** p = (Xdmsdm__LicenseFunc **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__LicenseFunc, sizeof(Xdmsdm__LicenseFunc), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__LicenseFunc(struct soap *soap, Xdmsdm__LicenseFunc *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__LicenseFunc);
	if (soap_out_PointerToXdmsdm__LicenseFunc(soap, tag?tag:"Xdmsdm:LicenseFunc", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__LicenseFunc ** SOAP_FMAC4 soap_get_PointerToXdmsdm__LicenseFunc(struct soap *soap, Xdmsdm__LicenseFunc **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__LicenseFunc(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToXdmsdm__UserInfo(struct soap *soap, Xdmsdm__UserInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfo))
		soap_serialize_PointerToXdmsdm__UserInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToXdmsdm__UserInfo(struct soap *soap, const char *tag, int id, Xdmsdm__UserInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToXdmsdm__UserInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 Xdmsdm__UserInfo *** SOAP_FMAC4 soap_in_PointerToPointerToXdmsdm__UserInfo(struct soap *soap, const char *tag, Xdmsdm__UserInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__UserInfo ***)soap_malloc(soap, sizeof(Xdmsdm__UserInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToXdmsdm__UserInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (Xdmsdm__UserInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfo, sizeof(Xdmsdm__UserInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToXdmsdm__UserInfo(struct soap *soap, Xdmsdm__UserInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__UserInfo);
	if (soap_out_PointerToPointerToXdmsdm__UserInfo(soap, tag?tag:"Xdmsdm:UserInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__UserInfo *** SOAP_FMAC4 soap_get_PointerToPointerToXdmsdm__UserInfo(struct soap *soap, Xdmsdm__UserInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToXdmsdm__UserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__UserInfo(struct soap *soap, Xdmsdm__UserInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__UserInfo(struct soap *soap, const char *tag, int id, Xdmsdm__UserInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__UserInfo ** SOAP_FMAC4 soap_in_PointerToXdmsdm__UserInfo(struct soap *soap, const char *tag, Xdmsdm__UserInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__UserInfo **)soap_malloc(soap, sizeof(Xdmsdm__UserInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__UserInfo *)soap_instantiate_Xdmsdm__UserInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__UserInfo ** p = (Xdmsdm__UserInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__UserInfo, sizeof(Xdmsdm__UserInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__UserInfo(struct soap *soap, Xdmsdm__UserInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__UserInfo);
	if (soap_out_PointerToXdmsdm__UserInfo(soap, tag?tag:"Xdmsdm:UserInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__UserInfo ** SOAP_FMAC4 soap_get_PointerToXdmsdm__UserInfo(struct soap *soap, Xdmsdm__UserInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__UserInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToXdmsdm__WebServiceInfo(struct soap *soap, Xdmsdm__WebServiceInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfo))
		soap_serialize_PointerToXdmsdm__WebServiceInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToXdmsdm__WebServiceInfo(struct soap *soap, const char *tag, int id, Xdmsdm__WebServiceInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToXdmsdm__WebServiceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 Xdmsdm__WebServiceInfo *** SOAP_FMAC4 soap_in_PointerToPointerToXdmsdm__WebServiceInfo(struct soap *soap, const char *tag, Xdmsdm__WebServiceInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__WebServiceInfo ***)soap_malloc(soap, sizeof(Xdmsdm__WebServiceInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToXdmsdm__WebServiceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (Xdmsdm__WebServiceInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfo, sizeof(Xdmsdm__WebServiceInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToXdmsdm__WebServiceInfo(struct soap *soap, Xdmsdm__WebServiceInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__WebServiceInfo);
	if (soap_out_PointerToPointerToXdmsdm__WebServiceInfo(soap, tag?tag:"Xdmsdm:WebServiceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__WebServiceInfo *** SOAP_FMAC4 soap_get_PointerToPointerToXdmsdm__WebServiceInfo(struct soap *soap, Xdmsdm__WebServiceInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToXdmsdm__WebServiceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__WebServiceInfo(struct soap *soap, Xdmsdm__WebServiceInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__WebServiceInfo(struct soap *soap, const char *tag, int id, Xdmsdm__WebServiceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__WebServiceInfo ** SOAP_FMAC4 soap_in_PointerToXdmsdm__WebServiceInfo(struct soap *soap, const char *tag, Xdmsdm__WebServiceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__WebServiceInfo **)soap_malloc(soap, sizeof(Xdmsdm__WebServiceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__WebServiceInfo *)soap_instantiate_Xdmsdm__WebServiceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__WebServiceInfo ** p = (Xdmsdm__WebServiceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__WebServiceInfo, sizeof(Xdmsdm__WebServiceInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__WebServiceInfo(struct soap *soap, Xdmsdm__WebServiceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__WebServiceInfo);
	if (soap_out_PointerToXdmsdm__WebServiceInfo(soap, tag?tag:"Xdmsdm:WebServiceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__WebServiceInfo ** SOAP_FMAC4 soap_get_PointerToXdmsdm__WebServiceInfo(struct soap *soap, Xdmsdm__WebServiceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__WebServiceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToXdmsdm__VersionInfo(struct soap *soap, Xdmsdm__VersionInfo **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfo))
		soap_serialize_PointerToXdmsdm__VersionInfo(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToXdmsdm__VersionInfo(struct soap *soap, const char *tag, int id, Xdmsdm__VersionInfo **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfo);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToXdmsdm__VersionInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 Xdmsdm__VersionInfo *** SOAP_FMAC4 soap_in_PointerToPointerToXdmsdm__VersionInfo(struct soap *soap, const char *tag, Xdmsdm__VersionInfo ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__VersionInfo ***)soap_malloc(soap, sizeof(Xdmsdm__VersionInfo **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToXdmsdm__VersionInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (Xdmsdm__VersionInfo ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfo, sizeof(Xdmsdm__VersionInfo *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToXdmsdm__VersionInfo(struct soap *soap, Xdmsdm__VersionInfo **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__VersionInfo);
	if (soap_out_PointerToPointerToXdmsdm__VersionInfo(soap, tag?tag:"Xdmsdm:VersionInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__VersionInfo *** SOAP_FMAC4 soap_get_PointerToPointerToXdmsdm__VersionInfo(struct soap *soap, Xdmsdm__VersionInfo ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToXdmsdm__VersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__VersionInfo(struct soap *soap, Xdmsdm__VersionInfo *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__VersionInfo(struct soap *soap, const char *tag, int id, Xdmsdm__VersionInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__VersionInfo ** SOAP_FMAC4 soap_in_PointerToXdmsdm__VersionInfo(struct soap *soap, const char *tag, Xdmsdm__VersionInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__VersionInfo **)soap_malloc(soap, sizeof(Xdmsdm__VersionInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__VersionInfo *)soap_instantiate_Xdmsdm__VersionInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__VersionInfo ** p = (Xdmsdm__VersionInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__VersionInfo, sizeof(Xdmsdm__VersionInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__VersionInfo(struct soap *soap, Xdmsdm__VersionInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__VersionInfo);
	if (soap_out_PointerToXdmsdm__VersionInfo(soap, tag?tag:"Xdmsdm:VersionInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__VersionInfo ** SOAP_FMAC4 soap_get_PointerToXdmsdm__VersionInfo(struct soap *soap, Xdmsdm__VersionInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__VersionInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToXdmsdm__FreqLayout(struct soap *soap, Xdmsdm__FreqLayout **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayout))
		soap_serialize_PointerToXdmsdm__FreqLayout(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToXdmsdm__FreqLayout(struct soap *soap, const char *tag, int id, Xdmsdm__FreqLayout **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayout);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToXdmsdm__FreqLayout(soap, tag, id, *a, type);
}

SOAP_FMAC3 Xdmsdm__FreqLayout *** SOAP_FMAC4 soap_in_PointerToPointerToXdmsdm__FreqLayout(struct soap *soap, const char *tag, Xdmsdm__FreqLayout ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__FreqLayout ***)soap_malloc(soap, sizeof(Xdmsdm__FreqLayout **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToXdmsdm__FreqLayout(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (Xdmsdm__FreqLayout ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayout, sizeof(Xdmsdm__FreqLayout *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToXdmsdm__FreqLayout(struct soap *soap, Xdmsdm__FreqLayout **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__FreqLayout);
	if (soap_out_PointerToPointerToXdmsdm__FreqLayout(soap, tag?tag:"Xdmsdm:FreqLayout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__FreqLayout *** SOAP_FMAC4 soap_get_PointerToPointerToXdmsdm__FreqLayout(struct soap *soap, Xdmsdm__FreqLayout ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToXdmsdm__FreqLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__FreqLayout(struct soap *soap, Xdmsdm__FreqLayout *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__FreqLayout(struct soap *soap, const char *tag, int id, Xdmsdm__FreqLayout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__FreqLayout ** SOAP_FMAC4 soap_in_PointerToXdmsdm__FreqLayout(struct soap *soap, const char *tag, Xdmsdm__FreqLayout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__FreqLayout **)soap_malloc(soap, sizeof(Xdmsdm__FreqLayout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__FreqLayout *)soap_instantiate_Xdmsdm__FreqLayout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__FreqLayout ** p = (Xdmsdm__FreqLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__FreqLayout, sizeof(Xdmsdm__FreqLayout), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__FreqLayout(struct soap *soap, Xdmsdm__FreqLayout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__FreqLayout);
	if (soap_out_PointerToXdmsdm__FreqLayout(soap, tag?tag:"Xdmsdm:FreqLayout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__FreqLayout ** SOAP_FMAC4 soap_get_PointerToXdmsdm__FreqLayout(struct soap *soap, Xdmsdm__FreqLayout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__FreqLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToXdmsdm__RegionNO(struct soap *soap, Xdmsdm__RegionNO **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNO))
		soap_serialize_PointerToXdmsdm__RegionNO(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToXdmsdm__RegionNO(struct soap *soap, const char *tag, int id, Xdmsdm__RegionNO **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNO);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToXdmsdm__RegionNO(soap, tag, id, *a, type);
}

SOAP_FMAC3 Xdmsdm__RegionNO *** SOAP_FMAC4 soap_in_PointerToPointerToXdmsdm__RegionNO(struct soap *soap, const char *tag, Xdmsdm__RegionNO ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__RegionNO ***)soap_malloc(soap, sizeof(Xdmsdm__RegionNO **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToXdmsdm__RegionNO(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (Xdmsdm__RegionNO ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNO, sizeof(Xdmsdm__RegionNO *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToXdmsdm__RegionNO(struct soap *soap, Xdmsdm__RegionNO **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToPointerToXdmsdm__RegionNO);
	if (soap_out_PointerToPointerToXdmsdm__RegionNO(soap, tag?tag:"Xdmsdm:RegionNO", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__RegionNO *** SOAP_FMAC4 soap_get_PointerToPointerToXdmsdm__RegionNO(struct soap *soap, Xdmsdm__RegionNO ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToXdmsdm__RegionNO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToXdmsdm__RegionNO(struct soap *soap, Xdmsdm__RegionNO *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToXdmsdm__RegionNO(struct soap *soap, const char *tag, int id, Xdmsdm__RegionNO *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 Xdmsdm__RegionNO ** SOAP_FMAC4 soap_in_PointerToXdmsdm__RegionNO(struct soap *soap, const char *tag, Xdmsdm__RegionNO **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (Xdmsdm__RegionNO **)soap_malloc(soap, sizeof(Xdmsdm__RegionNO *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (Xdmsdm__RegionNO *)soap_instantiate_Xdmsdm__RegionNO(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	Xdmsdm__RegionNO ** p = (Xdmsdm__RegionNO **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_Xdmsdm_Xdmsdm__RegionNO, sizeof(Xdmsdm__RegionNO), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToXdmsdm__RegionNO(struct soap *soap, Xdmsdm__RegionNO *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_PointerToXdmsdm__RegionNO);
	if (soap_out_PointerToXdmsdm__RegionNO(soap, tag?tag:"Xdmsdm:RegionNO", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 Xdmsdm__RegionNO ** SOAP_FMAC4 soap_get_PointerToXdmsdm__RegionNO(struct soap *soap, Xdmsdm__RegionNO **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToXdmsdm__RegionNO(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_Xdmsdm__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_Xdmsdm__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_Xdmsdm_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_Xdmsdm_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_Xdmsdm_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_Xdmsdm_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

} // namespace Xdmsdm


#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of XdmsdmC.cpp */
